
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>migrate-config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jamesainslie/terraform-provider-dotfiles/cmd/migrate-config/main.go (0.0%)</option>
				
				<option value="file1">github.com/jamesainslie/terraform-provider-dotfiles/internal/errors/errors.go (86.0%)</option>
				
				<option value="file2">github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops/enhanced_backup.go (80.3%)</option>
				
				<option value="file3">github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops/operations.go (51.2%)</option>
				
				<option value="file4">github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops/permissions.go (51.2%)</option>
				
				<option value="file5">github.com/jamesainslie/terraform-provider-dotfiles/internal/git/operations.go (24.5%)</option>
				
				<option value="file6">github.com/jamesainslie/terraform-provider-dotfiles/internal/idempotency/idempotency.go (53.1%)</option>
				
				<option value="file7">github.com/jamesainslie/terraform-provider-dotfiles/internal/migration/migrate.go (75.4%)</option>
				
				<option value="file8">github.com/jamesainslie/terraform-provider-dotfiles/internal/platform/darwin.go (73.4%)</option>
				
				<option value="file9">github.com/jamesainslie/terraform-provider-dotfiles/internal/platform/linux.go (17.6%)</option>
				
				<option value="file10">github.com/jamesainslie/terraform-provider-dotfiles/internal/platform/platform.go (70.0%)</option>
				
				<option value="file11">github.com/jamesainslie/terraform-provider-dotfiles/internal/platform/windows.go (15.6%)</option>
				
				<option value="file12">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/application_resource.go (25.8%)</option>
				
				<option value="file13">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/client.go (56.4%)</option>
				
				<option value="file14">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/config.go (88.1%)</option>
				
				<option value="file15">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/directory_resource.go (4.9%)</option>
				
				<option value="file16">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/enhanced_backup_models.go (100.0%)</option>
				
				<option value="file17">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/enhanced_template_models.go (100.0%)</option>
				
				<option value="file18">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/file_info_data_source.go (50.0%)</option>
				
				<option value="file19">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/file_resource.go (27.6%)</option>
				
				<option value="file20">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/permissions.go (47.5%)</option>
				
				<option value="file21">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/provider.go (14.1%)</option>
				
				<option value="file22">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/repository_resource.go (20.8%)</option>
				
				<option value="file23">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/symlink_resource.go (7.5%)</option>
				
				<option value="file24">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/system_data_source.go (58.8%)</option>
				
				<option value="file25">github.com/jamesainslie/terraform-provider-dotfiles/internal/services/backup_service.go (66.0%)</option>
				
				<option value="file26">github.com/jamesainslie/terraform-provider-dotfiles/internal/services/cache_service.go (98.3%)</option>
				
				<option value="file27">github.com/jamesainslie/terraform-provider-dotfiles/internal/services/registry.go (97.3%)</option>
				
				<option value="file28">github.com/jamesainslie/terraform-provider-dotfiles/internal/services/template_service.go (89.9%)</option>
				
				<option value="file29">github.com/jamesainslie/terraform-provider-dotfiles/internal/template/engine.go (64.6%)</option>
				
				<option value="file30">github.com/jamesainslie/terraform-provider-dotfiles/internal/template/enhanced_engines.go (57.4%)</option>
				
				<option value="file31">github.com/jamesainslie/terraform-provider-dotfiles/internal/utils/testing.go (88.1%)</option>
				
				<option value="file32">github.com/jamesainslie/terraform-provider-dotfiles/internal/validators/filemode.go (19.8%)</option>
				
				<option value="file33">github.com/jamesainslie/terraform-provider-dotfiles/internal/validators/path.go (0.0%)</option>
				
				<option value="file34">github.com/jamesainslie/terraform-provider-dotfiles/internal/validators/template.go (0.0%)</option>
				
				<option value="file35">github.com/jamesainslie/terraform-provider-dotfiles/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/migration"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">switch os.Args[1] </span>{
        case "migrate":<span class="cov0" title="0">
                if len(os.Args) &lt; 4 </span><span class="cov0" title="0">{
                        printUsage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">inputFile := os.Args[2]
                outputFile := os.Args[3]

                if err := migration.MigrateConfigFile(inputFile, outputFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Migration failed: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Configuration migrated successfully!\n")
                fmt.Printf("Input:  %s\n", inputFile)
                fmt.Printf("Output: %s\n", outputFile)
                fmt.Printf("\nPlease review the output file and test the configuration before applying.\n")</span>

        case "validate":<span class="cov0" title="0">
                if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                        printUsage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">inputFile := os.Args[2]

                issues, err := migration.ValidateConfigFile(inputFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Validation failed: %v", err)
                }</span>

                <span class="cov0" title="0">if len(issues) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("✅ Configuration %s is compatible with the new architecture.\n", inputFile)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("⚠️  Found %d compatibility issue(s) in %s:\n\n", len(issues), inputFile)
                        for i, issue := range issues </span><span class="cov0" title="0">{
                                fmt.Printf("%d. %s\n", i+1, issue.Description)
                                if issue.Suggestion != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   Suggestion: %s\n", issue.Suggestion)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("\n")</span>
                        }
                }

        default:<span class="cov0" title="0">
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Printf(`terraform-provider-dotfiles Migration Tool

This tool helps migrate Terraform configurations to the new explicit resource architecture
where the strategy field has been removed from dotfiles_file resource.

Usage:
  %s migrate &lt;input.tf&gt; &lt;output.tf&gt;     Migrate configuration file
  %s validate &lt;input.tf&gt;                Check for compatibility issues

Examples:
  %s migrate main.tf main-migrated.tf
  %s validate main.tf

Migration Details:
- dotfiles_file resources with strategy="symlink" → dotfiles_symlink resources
- dotfiles_file resources with strategy="copy" → dotfiles_file resources (strategy field removed)
- dotfiles_file resources with strategy="template" → dotfiles_file resources (converted to is_template=true)
- Complex patterns with multiple strategies → dotfiles_application resources

`, os.Args[0], os.Args[0], os.Args[0], os.Args[0])
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package errors

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// ErrorType represents different categories of errors for better handling.
type ErrorType int

const (
        // ErrorTypeUnknown represents an unclassified error.
        ErrorTypeUnknown ErrorType = iota
        // ErrorTypeValidation represents validation errors.
        ErrorTypeValidation
        // ErrorTypePermission represents permission/access errors.
        ErrorTypePermission
        // ErrorTypeNetwork represents network-related errors.
        ErrorTypeNetwork
        // ErrorTypeIO represents I/O operation errors.
        ErrorTypeIO
        // ErrorTypeGit represents Git operation errors.
        ErrorTypeGit
        // ErrorTypeTemplate represents template processing errors.
        ErrorTypeTemplate
        // ErrorTypeConfiguration represents configuration errors.
        ErrorTypeConfiguration
)

// String returns a string representation of the error type.
func (et ErrorType) String() string <span class="cov9" title="16">{
        switch et </span>{
        case ErrorTypeValidation:<span class="cov5" title="4">
                return "validation"</span>
        case ErrorTypePermission:<span class="cov3" title="2">
                return "permission"</span>
        case ErrorTypeNetwork:<span class="cov3" title="2">
                return "network"</span>
        case ErrorTypeIO:<span class="cov3" title="2">
                return "io"</span>
        case ErrorTypeGit:<span class="cov3" title="2">
                return "git"</span>
        case ErrorTypeTemplate:<span class="cov3" title="2">
                return "template"</span>
        case ErrorTypeConfiguration:<span class="cov3" title="2">
                return "configuration"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// ProviderError represents an enhanced error with context and type information.
type ProviderError struct {
        Type      ErrorType
        Operation string
        Resource  string
        Path      string
        Message   string
        Cause     error
        Context   map[string]interface{}
        Retryable bool
}

// Error implements the error interface.
func (pe *ProviderError) Error() string <span class="cov8" title="13">{
        var parts []string

        if pe.Operation != "" </span><span class="cov8" title="11">{
                parts = append(parts, fmt.Sprintf("operation=%s", pe.Operation))
        }</span>
        <span class="cov8" title="13">if pe.Resource != "" </span><span class="cov8" title="11">{
                parts = append(parts, fmt.Sprintf("resource=%s", pe.Resource))
        }</span>
        <span class="cov8" title="13">if pe.Path != "" </span><span class="cov3" title="2">{
                parts = append(parts, fmt.Sprintf("path=%s", pe.Path))
        }</span>

        <span class="cov8" title="13">contextStr := ""
        if len(parts) &gt; 0 </span><span class="cov8" title="11">{
                contextStr = fmt.Sprintf(" (%s)", strings.Join(parts, ", "))
        }</span>

        <span class="cov8" title="13">if pe.Cause != nil </span><span class="cov4" title="3">{
                return fmt.Sprintf("%s%s: %v", pe.Message, contextStr, pe.Cause)
        }</span>
        <span class="cov8" title="10">return fmt.Sprintf("%s%s", pe.Message, contextStr)</span>
}

// Unwrap returns the underlying cause error.
func (pe *ProviderError) Unwrap() error <span class="cov6" title="5">{
        return pe.Cause
}</span>

// IsRetryable returns whether this error might succeed on retry.
func (pe *ProviderError) IsRetryable() bool <span class="cov7" title="7">{
        return pe.Retryable
}</span>

// NewProviderError creates a new provider error with context.
func NewProviderError(errType ErrorType, operation, resource, message string, cause error) *ProviderError <span class="cov10" title="18">{
        return &amp;ProviderError{
                Type:      errType,
                Operation: operation,
                Resource:  resource,
                Message:   message,
                Cause:     cause,
                Context:   make(map[string]interface{}),
                Retryable: isRetryableError(errType, cause),
        }
}</span>

// WithPath adds path context to the error.
func (pe *ProviderError) WithPath(path string) *ProviderError <span class="cov1" title="1">{
        pe.Path = path
        return pe
}</span>

// WithContext adds additional context to the error.
func (pe *ProviderError) WithContext(key string, value interface{}) *ProviderError <span class="cov0" title="0">{
        pe.Context[key] = value
        return pe
}</span>

// WithRetryable sets whether this error is retryable.
func (pe *ProviderError) WithRetryable(retryable bool) *ProviderError <span class="cov6" title="6">{
        pe.Retryable = retryable
        return pe
}</span>

// isRetryableError determines if an error type/cause combination might succeed on retry.
func isRetryableError(errType ErrorType, cause error) bool <span class="cov10" title="18">{
        switch errType </span>{
        case ErrorTypeNetwork, ErrorTypeGit:<span class="cov3" title="2">
                return true</span> // Network and Git operations often benefit from retry
        case ErrorTypeIO:<span class="cov7" title="8">
                // Some I/O errors are retryable (temporary file locks, etc.)
                if cause != nil </span><span class="cov1" title="1">{
                        errStr := cause.Error()
                        return strings.Contains(errStr, "resource temporarily unavailable") ||
                                strings.Contains(errStr, "device or resource busy") ||
                                strings.Contains(errStr, "interrupted system call")
                }</span>
                <span class="cov7" title="7">return false</span>
        default:<span class="cov7" title="8">
                return false</span>
        }
}

// AddErrorToDiagnostics adds a ProviderError to Terraform diagnostics with enhanced context.
func AddErrorToDiagnostics(ctx context.Context, diags *diag.Diagnostics, err error, summary string) <span class="cov1" title="1">{
        var providerErr *ProviderError
        if errors.As(err, &amp;providerErr) </span><span class="cov1" title="1">{
                // Enhanced error with context
                detail := providerErr.Error()

                // Add context information to the detail
                if len(providerErr.Context) &gt; 0 </span><span class="cov0" title="0">{
                        var contextParts []string
                        for k, v := range providerErr.Context </span><span class="cov0" title="0">{
                                contextParts = append(contextParts, fmt.Sprintf("%s: %v", k, v))
                        }</span>
                        <span class="cov0" title="0">detail += fmt.Sprintf("\nContext: %s", strings.Join(contextParts, ", "))</span>
                }

                // Log the error with structured context
                <span class="cov1" title="1">tflog.Error(ctx, "Provider error occurred", map[string]interface{}{
                        "error_type": providerErr.Type.String(),
                        "operation":  providerErr.Operation,
                        "resource":   providerErr.Resource,
                        "path":       providerErr.Path,
                        "retryable":  providerErr.Retryable,
                        "message":    providerErr.Message,
                        "context":    providerErr.Context,
                })

                diags.AddError(summary, detail)</span>
        } else<span class="cov0" title="0"> {
                // Regular error
                tflog.Error(ctx, "Untyped error occurred", map[string]interface{}{
                        "error": err.Error(),
                })
                diags.AddError(summary, err.Error())
        }</span>
}

// AddWarningToDiagnostics adds a warning to Terraform diagnostics with logging.
func AddWarningToDiagnostics(ctx context.Context, diags *diag.Diagnostics, message, detail string) <span class="cov1" title="1">{
        tflog.Warn(ctx, "Provider warning", map[string]interface{}{
                "message": message,
                "detail":  detail,
        })
        diags.AddWarning(message, detail)
}</span>

// RetryConfig defines configuration for retry operations.
type RetryConfig struct {
        MaxAttempts int
        BaseDelay   time.Duration
        MaxDelay    time.Duration
        Multiplier  float64
}

// DefaultRetryConfig returns a sensible default retry configuration.
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxAttempts: 3,
                BaseDelay:   time.Second,
                MaxDelay:    30 * time.Second,
                Multiplier:  2.0,
        }
}</span>

// RetryableOperation represents an operation that can be retried.
type RetryableOperation func() error

// Retry executes a retryable operation with exponential backoff.
func Retry(ctx context.Context, config RetryConfig, operation RetryableOperation) error <span class="cov6" title="5">{
        var lastErr error

        for attempt := 1; attempt &lt;= config.MaxAttempts; attempt++ </span><span class="cov7" title="9">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov7" title="9"></span>
                }

                <span class="cov7" title="9">err := operation()
                if err == nil </span><span class="cov1" title="1">{
                        if attempt &gt; 1 </span><span class="cov1" title="1">{
                                tflog.Info(ctx, "Retry operation succeeded", map[string]interface{}{
                                        "attempt": attempt,
                                })
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                }

                <span class="cov7" title="8">lastErr = err

                // Check if error is retryable
                var providerErr *ProviderError
                if errors.As(err, &amp;providerErr) </span><span class="cov7" title="7">{
                        if !providerErr.IsRetryable() </span><span class="cov1" title="1">{
                                tflog.Debug(ctx, "Error is not retryable, stopping", map[string]interface{}{
                                        "error_type": providerErr.Type.String(),
                                        "attempt":    attempt,
                                })
                                return err
                        }</span>
                } else<span class="cov1" title="1"> {
                        // Standard errors (non-ProviderError) are not retryable
                        tflog.Debug(ctx, "Standard error is not retryable, stopping", map[string]interface{}{
                                "error":   err.Error(),
                                "attempt": attempt,
                        })
                        return err
                }</span>

                <span class="cov6" title="6">if attempt &lt; config.MaxAttempts </span><span class="cov6" title="5">{
                        // Calculate delay with exponential backoff
                        delay := time.Duration(float64(config.BaseDelay) * (config.Multiplier * float64(attempt-1)))
                        if delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                                delay = config.MaxDelay
                        }</span>

                        <span class="cov6" title="5">tflog.Info(ctx, "Retrying operation after delay", map[string]interface{}{
                                "attempt":      attempt,
                                "max_attempts": config.MaxAttempts,
                                "delay_ms":     delay.Milliseconds(),
                                "error":        err.Error(),
                        })

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov5" title="4"></span>
                        }
                }
        }

        <span class="cov1" title="1">tflog.Error(ctx, "All retry attempts exhausted", map[string]interface{}{
                "max_attempts": config.MaxAttempts,
                "final_error":  lastErr.Error(),
        })

        return fmt.Errorf("operation failed after %d attempts: %w", config.MaxAttempts, lastErr)</span>
}

// ValidationError creates a validation error.
func ValidationError(operation, resource, message string, cause error) *ProviderError <span class="cov4" title="3">{
        return NewProviderError(ErrorTypeValidation, operation, resource, message, cause)
}</span>

// PermissionError creates a permission error.
func PermissionError(operation, resource, message string, cause error) *ProviderError <span class="cov1" title="1">{
        return NewProviderError(ErrorTypePermission, operation, resource, message, cause)
}</span>

// NetworkError creates a network error (retryable by default).
func NetworkError(operation, resource, message string, cause error) *ProviderError <span class="cov1" title="1">{
        return NewProviderError(ErrorTypeNetwork, operation, resource, message, cause)
}</span>

// IOError creates an I/O error.
func IOError(operation, resource, message string, cause error) *ProviderError <span class="cov7" title="8">{
        return NewProviderError(ErrorTypeIO, operation, resource, message, cause)
}</span>

// GitError creates a Git operation error (retryable by default).
func GitError(operation, resource, message string, cause error) *ProviderError <span class="cov1" title="1">{
        return NewProviderError(ErrorTypeGit, operation, resource, message, cause)
}</span>

// TemplateError creates a template processing error.
func TemplateError(operation, resource, message string, cause error) *ProviderError <span class="cov1" title="1">{
        return NewProviderError(ErrorTypeTemplate, operation, resource, message, cause)
}</span>

// ConfigurationError creates a configuration error.
func ConfigurationError(operation, resource, message string, cause error) *ProviderError <span class="cov3" title="2">{
        return NewProviderError(ErrorTypeConfiguration, operation, resource, message, cause)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package fileops

import (
        "compress/gzip"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"
)

// EnhancedBackupConfig represents enhanced backup configuration.
type EnhancedBackupConfig struct {
        Enabled         bool
        Directory       string
        RetentionPolicy string
        Compression     bool
        Incremental     bool
        MaxBackups      int64
        BackupFormat    string
        BackupMetadata  bool
        BackupIndex     bool
}

// BackupMetadata represents metadata for a backup file.
type BackupMetadata struct {
        OriginalPath string    `json:"original_path"`
        BackupPath   string    `json:"backup_path"`
        Timestamp    time.Time `json:"timestamp"`
        Checksum     string    `json:"checksum"`
        Compressed   bool      `json:"compressed"`
        OriginalSize int64     `json:"original_size"`
        BackupSize   int64     `json:"backup_size"`
        FileMode     string    `json:"file_mode"`
}

// BackupIndex represents an index of all backups.
type BackupIndex struct {
        LastUpdated time.Time        `json:"last_updated"`
        Backups     []BackupMetadata `json:"backups"`
}

// CreateEnhancedBackup creates a backup with enhanced features.
func (fm *FileManager) CreateEnhancedBackup(filePath string, config *EnhancedBackupConfig) (string, error) <span class="cov9" title="17">{
        if config == nil || !config.Enabled </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov9" title="17">if fm.dryRun </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/enhanced-backup-dry-run", config.Directory), nil
        }</span>

        // Check if incremental backup is needed
        <span class="cov9" title="17">if config.Incremental &amp;&amp; config.BackupIndex </span><span class="cov4" title="3">{
                if shouldSkipBackup, err := fm.shouldSkipIncrementalBackup(filePath, config); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to check incremental backup: %w", err)
                }</span> else<span class="cov4" title="3"> if shouldSkipBackup </span><span class="cov1" title="1">{
                        return "", nil // Skip backup - content hasn't changed
                }</span>
        }

        // Create backup directory
        <span class="cov8" title="16">err := os.MkdirAll(config.Directory, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        // Generate backup filename based on format
        <span class="cov8" title="16">backupPath, err := fm.generateBackupPath(filePath, config)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate backup path: %w", err)
        }</span>

        // Create the backup
        <span class="cov8" title="16">if config.Compression </span><span class="cov1" title="1">{
                err = fm.createCompressedBackup(filePath, backupPath)
        }</span> else<span class="cov8" title="15"> {
                err = fm.platform.CopyFile(filePath, backupPath)
        }</span>
        <span class="cov8" title="16">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create backup: %w", err)
        }</span>

        // Create metadata if requested
        <span class="cov8" title="16">if config.BackupMetadata </span><span class="cov4" title="4">{
                err = fm.createBackupMetadata(filePath, backupPath, config)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create backup metadata: %w", err)
                }</span>
        }

        // Update backup index if requested
        <span class="cov8" title="16">if config.BackupIndex </span><span class="cov6" title="6">{
                err = fm.updateBackupIndex(filePath, backupPath, config)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to update backup index: %w", err)
                }</span>
        }

        // Apply retention policy
        <span class="cov8" title="16">if config.MaxBackups &gt; 0 </span><span class="cov7" title="10">{
                err = fm.applyRetentionPolicy(filePath, config)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to apply retention policy: %w", err)
                }</span>
        }

        <span class="cov8" title="16">return backupPath, nil</span>
}

// generateBackupPath generates backup file path based on format.
func (fm *FileManager) generateBackupPath(filePath string, config *EnhancedBackupConfig) (string, error) <span class="cov8" title="16">{
        fileName := filepath.Base(filePath)
        var backupName string

        switch config.BackupFormat </span>{
        case "timestamped":<span class="cov7" title="9">
                timestamp := time.Now().Format("2006-01-02-150405")
                backupName = fmt.Sprintf("%s.backup.%s", fileName, timestamp)</span>
        case "numbered":<span class="cov6" title="6">
                backupName = fm.generateNumberedBackupName(fileName, config.Directory)</span>
        case "git_style":<span class="cov1" title="1">
                checksum, err := fm.calculateFileChecksum(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to calculate checksum: %w", err)
                }</span>
                <span class="cov1" title="1">backupName = fmt.Sprintf("%s.backup.%s", fileName, checksum[:8])</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported backup format: %s", config.BackupFormat)</span>
        }

        <span class="cov8" title="16">backupPath := filepath.Join(config.Directory, backupName)
        if config.Compression </span><span class="cov1" title="1">{
                backupPath += ".gz"
        }</span>

        <span class="cov8" title="16">return backupPath, nil</span>
}

// generateNumberedBackupName generates a numbered backup name.
func (fm *FileManager) generateNumberedBackupName(fileName, backupDir string) string <span class="cov6" title="6">{
        pattern := filepath.Join(backupDir, fileName+".backup.*")
        existing, _ := filepath.Glob(pattern)

        nextNumber := 1
        if len(existing) &gt; 0 </span><span class="cov5" title="5">{
                maxNumber := 0
                for _, path := range existing </span><span class="cov7" title="10">{
                        base := filepath.Base(path)
                        // Remove .gz extension if present for parsing (safe unconditionally)
                        base = strings.TrimSuffix(base, ".gz")

                        parts := strings.Split(base, ".")
                        if len(parts) &gt;= 3 </span><span class="cov7" title="10">{
                                // The number should be the last part after removing .gz
                                numberPart := parts[len(parts)-1]
                                if num, err := strconv.Atoi(numberPart); err == nil </span><span class="cov7" title="9">{
                                        if num &gt; maxNumber </span><span class="cov7" title="9">{
                                                maxNumber = num
                                        }</span>
                                }
                        }
                }
                <span class="cov5" title="5">nextNumber = maxNumber + 1</span>
        }

        <span class="cov6" title="6">return fmt.Sprintf("%s.backup.%03d", fileName, nextNumber)</span>
}

// createCompressedBackup creates a compressed backup using gzip.
func (fm *FileManager) createCompressedBackup(sourcePath, backupPath string) error <span class="cov1" title="1">{
        sourceFile, err := os.Open(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation - this is cleanup
                        _ = err
                }</span>
        }()

        <span class="cov1" title="1">backupFile, err := os.Create(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup file: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := backupFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation - this is cleanup
                        _ = err
                }</span>
        }()

        <span class="cov1" title="1">gzWriter := gzip.NewWriter(backupFile)
        defer func() </span><span class="cov1" title="1">{
                if err := gzWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation - this is cleanup
                        _ = err
                }</span>
        }()

        <span class="cov1" title="1">_, err = io.Copy(gzWriter, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// createBackupMetadata creates metadata for a backup.
func (fm *FileManager) createBackupMetadata(originalPath, backupPath string, config *EnhancedBackupConfig) error <span class="cov4" title="4">{
        // Get file info
        originalInfo, err := os.Stat(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat original file: %w", err)
        }</span>

        <span class="cov4" title="4">backupInfo, err := os.Stat(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat backup file: %w", err)
        }</span>

        // Calculate checksum
        <span class="cov4" title="4">checksum, err := fm.calculateFileChecksum(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>

        // Create metadata
        <span class="cov4" title="4">metadata := BackupMetadata{
                OriginalPath: originalPath,
                BackupPath:   backupPath,
                Timestamp:    time.Now(),
                Checksum:     checksum,
                Compressed:   config.Compression,
                OriginalSize: originalInfo.Size(),
                BackupSize:   backupInfo.Size(),
                FileMode:     originalInfo.Mode().String(),
        }

        // Write metadata to file
        metadataPath := backupPath + ".meta"
        metadataFile, err := os.Create(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create metadata file: %w", err)
        }</span>
        <span class="cov4" title="4">defer func() </span><span class="cov4" title="4">{
                if err := metadataFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close metadata file: %v\n", err)
                }</span>
        }()

        <span class="cov4" title="4">encoder := json.NewEncoder(metadataFile)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode metadata: %w", err)
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// updateBackupIndex updates the backup index.
func (fm *FileManager) updateBackupIndex(originalPath, backupPath string, config *EnhancedBackupConfig) error <span class="cov6" title="6">{
        indexPath := filepath.Join(config.Directory, ".backup_index.json")

        // Load existing index or create new one
        index := &amp;BackupIndex{
                LastUpdated: time.Now(),
                Backups:     make([]BackupMetadata, 0),
        }

        if _, err := os.Stat(indexPath); err == nil </span><span class="cov4" title="4">{
                if loadedIndex, loadErr := LoadBackupIndex(indexPath); loadErr == nil </span><span class="cov4" title="4">{
                        index = loadedIndex
                }</span>
        }

        // Calculate checksum for new backup
        <span class="cov6" title="6">checksum, err := fm.calculateFileChecksum(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>

        // Add new backup to index
        <span class="cov6" title="6">originalInfo, _ := os.Stat(originalPath)
        backupInfo, _ := os.Stat(backupPath)

        newBackup := BackupMetadata{
                OriginalPath: originalPath,
                BackupPath:   backupPath,
                Timestamp:    time.Now(),
                Checksum:     checksum,
                Compressed:   config.Compression,
                OriginalSize: originalInfo.Size(),
                BackupSize:   backupInfo.Size(),
                FileMode:     originalInfo.Mode().String(),
        }

        index.Backups = append(index.Backups, newBackup)
        index.LastUpdated = time.Now()

        // Write updated index
        return fm.saveBackupIndex(index, indexPath)</span>
}

// shouldSkipIncrementalBackup checks if incremental backup should be skipped.
func (fm *FileManager) shouldSkipIncrementalBackup(filePath string, config *EnhancedBackupConfig) (bool, error) <span class="cov4" title="3">{
        indexPath := filepath.Join(config.Directory, ".backup_index.json")
        if _, err := os.Stat(indexPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return false, nil // No index exists, create first backup
        }</span>

        // Load index
        <span class="cov2" title="2">index, loadErr := LoadBackupIndex(indexPath)
        if loadErr != nil </span><span class="cov0" title="0">{
                // Treat as empty index and proceed to create a backup.
                index = &amp;BackupIndex{LastUpdated: time.Now(), Backups: nil}
        }</span>

        // Calculate current file checksum
        <span class="cov2" title="2">currentChecksum, err := fm.calculateFileChecksum(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if we already have a backup with this checksum
        <span class="cov2" title="2">for _, backup := range index.Backups </span><span class="cov2" title="2">{
                if backup.OriginalPath == filePath &amp;&amp; backup.Checksum == currentChecksum </span><span class="cov1" title="1">{
                        return true, nil // Skip backup - content hasn't changed
                }</span>
        }

        <span class="cov1" title="1">return false, nil</span> // Content has changed, create backup
}

// applyRetentionPolicy removes old backups based on retention policy.
func (fm *FileManager) applyRetentionPolicy(originalPath string, config *EnhancedBackupConfig) error <span class="cov7" title="10">{
        fileName := filepath.Base(originalPath)
        pattern := filepath.Join(config.Directory, fileName+".backup.*")
        backupFiles, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list backup files: %w", err)
        }</span>

        // Filter to get only actual backup files (not metadata files)
        <span class="cov7" title="10">actualBackups := make([]string, 0)
        for _, path := range backupFiles </span><span class="cov10" title="23">{
                // Skip metadata files
                if strings.HasSuffix(path, ".meta") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Include both compressed and uncompressed backup files
                <span class="cov10" title="23">baseName := filepath.Base(path)
                if strings.Contains(baseName, ".backup.") </span><span class="cov10" title="23">{
                        actualBackups = append(actualBackups, path)
                }</span>
        }

        <span class="cov7" title="10">if len(actualBackups) &lt;= int(config.MaxBackups) </span><span class="cov6" title="8">{
                return nil // Within retention limit
        }</span>

        // Sort backups by modification time (oldest first)
        <span class="cov2" title="2">sort.Slice(actualBackups, func(i, j int) bool </span><span class="cov6" title="6">{
                infoI, errI := os.Stat(actualBackups[i])
                infoJ, errJ := os.Stat(actualBackups[j])
                if errI != nil || errJ != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="6">return infoI.ModTime().Before(infoJ.ModTime())</span>
        })

        // Remove oldest backups beyond retention limit
        <span class="cov2" title="2">toRemove := len(actualBackups) - int(config.MaxBackups)
        for i := 0; i &lt; toRemove; i++ </span><span class="cov2" title="2">{
                backupPath := actualBackups[i]

                // Remove backup file
                if err := os.Remove(backupPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove old backup %s: %w", backupPath, err)
                }</span>

                // Remove associated metadata file if it exists
                <span class="cov2" title="2">metadataPath := backupPath + ".meta"
                if _, err := os.Stat(metadataPath); err == nil </span><span class="cov0" title="0">{
                        _ = os.Remove(metadataPath)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// calculateFileChecksum calculates SHA256 checksum of a file.
func (fm *FileManager) calculateFileChecksum(filePath string) (string, error) <span class="cov8" title="13">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="13">defer func() </span><span class="cov8" title="13">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close file: %v\n", err)
                }</span>
        }()

        <span class="cov8" title="13">hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to calculate hash: %w", err)
        }</span>

        <span class="cov8" title="13">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// saveBackupIndex saves backup index to file.
func (fm *FileManager) saveBackupIndex(index *BackupIndex, indexPath string) error <span class="cov6" title="6">{
        indexFile, err := os.Create(indexPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create index file: %w", err)
        }</span>
        <span class="cov6" title="6">defer func() </span><span class="cov6" title="6">{
                if err := indexFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close index file: %v\n", err)
                }</span>
        }()

        <span class="cov6" title="6">encoder := json.NewEncoder(indexFile)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(index); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode index: %w", err)
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// LoadBackupMetadata loads backup metadata from file.
func LoadBackupMetadata(metadataPath string) (*BackupMetadata, error) <span class="cov1" title="1">{
        file, err := os.Open(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open metadata file: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close metadata file: %v\n", err)
                }</span>
        }()

        <span class="cov1" title="1">var metadata BackupMetadata
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode metadata: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;metadata, nil</span>
}

// LoadBackupIndex loads backup index from file.
func LoadBackupIndex(indexPath string) (*BackupIndex, error) <span class="cov6" title="7">{
        file, err := os.Open(indexPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open index file: %w", err)
        }</span>
        <span class="cov6" title="7">defer func() </span><span class="cov6" title="7">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close metadata file: %v\n", err)
                }</span>
        }()

        <span class="cov6" title="7">var index BackupIndex
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;index); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode index: %w", err)
        }</span>

        <span class="cov6" title="7">return &amp;index, nil</span>
}

// ValidateEnhancedBackupConfig validates enhanced backup configuration.
func ValidateEnhancedBackupConfig(config *EnhancedBackupConfig) error <span class="cov4" title="4">{
        if config == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Validate retention policy format
        <span class="cov4" title="3">if config.RetentionPolicy != "" </span><span class="cov4" title="3">{
                if !isValidRetentionPolicy(config.RetentionPolicy) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid retention policy format: %s", config.RetentionPolicy)
                }</span>
        }

        // Validate backup format
        <span class="cov2" title="2">validFormats := []string{"timestamped", "numbered", "git_style"}
        if config.BackupFormat != "" </span><span class="cov2" title="2">{
                valid := false
                for _, format := range validFormats </span><span class="cov4" title="4">{
                        if config.BackupFormat == format </span><span class="cov1" title="1">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov2" title="2">if !valid </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid backup format: %s (must be one of: %v)", config.BackupFormat, validFormats)
                }</span>
        }

        // Validate max backups
        <span class="cov1" title="1">if config.MaxBackups &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_backups cannot be negative: %d", config.MaxBackups)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// isValidRetentionPolicy checks if retention policy is valid.
func isValidRetentionPolicy(policy string) bool <span class="cov4" title="3">{
        if len(policy) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="3">unit := policy[len(policy)-1]
        value := policy[:len(policy)-1]

        // Check if value is numeric
        if _, err := strconv.Atoi(value); err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if unit is valid
        <span class="cov2" title="2">validUnits := []byte{'d', 'w', 'm', 'y'}
        for _, validUnit := range validUnits </span><span class="cov2" title="2">{
                if unit == validUnit </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package fileops

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/template"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

// FileManager handles file operations for dotfiles management.
type FileManager struct {
        platform platform.PlatformProvider
        dryRun   bool
}

// ConflictResolution represents the result of conflict resolution.
type ConflictResolution struct {
        Action        string // "backup", "overwrite", "skip"
        BackupPath    string // Path where backup was created (if any)
        ShouldProceed bool   // Whether to proceed with the operation
}

// NewFileManager creates a new file manager.
func NewFileManager(platformProvider platform.PlatformProvider, dryRun bool) *FileManager <span class="cov10" title="13">{
        return &amp;FileManager{
                platform: platformProvider,
                dryRun:   dryRun,
        }
}</span>

// CopyFile copies a file from source to target with specified permissions.
func (fm *FileManager) CopyFile(sourcePath, targetPath, fileMode string) error <span class="cov7" title="6">{
        if fm.dryRun </span><span class="cov1" title="1">{
                fmt.Printf("DRY RUN: Would copy %s to %s with mode %s\n", sourcePath, targetPath, fileMode)
                return nil
        }</span>

        // Parse file mode
        <span class="cov6" title="5">mode, err := utils.ParseFileMode(fileMode)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid file mode %s: %w", fileMode, err)
        }</span>

        // Use platform provider to copy file
        <span class="cov5" title="4">err = fm.platform.CopyFile(sourcePath, targetPath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        // Set permissions
        <span class="cov4" title="3">err = fm.platform.SetPermissions(targetPath, mode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set permissions: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// CopyFileWithBackup copies a file and creates a backup if target exists.
func (fm *FileManager) CopyFileWithBackup(sourcePath, targetPath, fileMode, backupDir string) error <span class="cov1" title="1">{
        // Check if target exists
        if utils.PathExists(targetPath) </span><span class="cov1" title="1">{
                // Create backup first
                _, err := fm.CreateBackup(targetPath, backupDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create backup: %w", err)
                }</span>
        }

        // Copy the file
        <span class="cov1" title="1">return fm.CopyFile(sourcePath, targetPath, fileMode)</span>
}

// CreateSymlink creates a symbolic link from source to target.
func (fm *FileManager) CreateSymlink(sourcePath, targetPath string) error <span class="cov3" title="2">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would create symlink %s -&gt; %s\n", targetPath, sourcePath)
                return nil
        }</span>

        <span class="cov3" title="2">return fm.platform.CreateSymlink(sourcePath, targetPath)</span>
}

// CreateSymlinkWithParents creates a symbolic link and creates parent directories.
func (fm *FileManager) CreateSymlinkWithParents(sourcePath, targetPath string) error <span class="cov1" title="1">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would create symlink %s -&gt; %s (with parents)\n", targetPath, sourcePath)
                return nil
        }</span>

        // Create parent directories
        <span class="cov1" title="1">parentDir := filepath.Dir(targetPath)
        err := os.MkdirAll(parentDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        <span class="cov1" title="1">return fm.platform.CreateSymlink(sourcePath, targetPath)</span>
}

// CreateBackup creates a backup of an existing file or directory.
func (fm *FileManager) CreateBackup(filePath, backupDir string) (string, error) <span class="cov5" title="4">{
        fmt.Printf("[DEBUG] CreateBackup: Starting backup operation for %s\n", filePath)

        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] CreateBackup: Dry run mode, skipping actual backup\n")
                return fmt.Sprintf("%s/backup-dry-run", backupDir), nil
        }</span>

        // Create backup directory
        <span class="cov5" title="4">fmt.Printf("[DEBUG] CreateBackup: Creating backup directory %s\n", backupDir)
        err := os.MkdirAll(backupDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] CreateBackup: Failed to create backup directory: %v\n", err)
                return "", fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        // Generate backup filename with timestamp
        <span class="cov5" title="4">fileName := filepath.Base(filePath)
        timestamp := time.Now().Format("2006-01-02-150405")
        backupFileName := fmt.Sprintf("%s.backup.%s", fileName, timestamp)
        backupPath := filepath.Join(backupDir, backupFileName)
        fmt.Printf("[DEBUG] CreateBackup: Generated backup path %s\n", backupPath)

        // Check if source is a directory
        fmt.Printf("[DEBUG] CreateBackup: Checking if source is directory\n")
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] CreateBackup: Failed to stat source: %v\n", err)
                return "", fmt.Errorf("failed to stat source: %w", err)
        }</span>

        <span class="cov5" title="4">isDir := info.IsDir()
        fmt.Printf("[DEBUG] CreateBackup: Source is directory: %v, mode: %s, size: %d\n", isDir, info.Mode().String(), info.Size())

        if isDir </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] CreateBackup: Copying directory recursively\n")
                // Copy directory recursively
                err = fm.copyDirectoryRecursive(filePath, backupPath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[ERROR] CreateBackup: Failed to copy directory recursively: %v\n", err)
                        return "", fmt.Errorf("failed to copy directory to backup: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("[DEBUG] CreateBackup: Directory copied successfully\n")</span>
        } else<span class="cov5" title="4"> {
                fmt.Printf("[DEBUG] CreateBackup: Copying file using platform provider\n")
                // Copy file to backup location
                err = fm.platform.CopyFile(filePath, backupPath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[ERROR] CreateBackup: Failed to copy file: %v\n", err)
                        return "", fmt.Errorf("failed to copy file to backup: %w", err)
                }</span>
                <span class="cov5" title="4">fmt.Printf("[DEBUG] CreateBackup: File copied successfully\n")</span>
        }

        <span class="cov5" title="4">fmt.Printf("[DEBUG] CreateBackup: Backup completed successfully at %s\n", backupPath)
        return backupPath, nil</span>
}

// copyDirectoryRecursive copies a directory and all its contents recursively.
func (fm *FileManager) copyDirectoryRecursive(src, dst string) error <span class="cov0" title="0">{
        fmt.Printf("[DEBUG] copyDirectoryRecursive: Starting recursive copy from %s to %s\n", src, dst)

        // Get source directory info
        srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] copyDirectoryRecursive: Failed to stat source directory: %v\n", err)
                return fmt.Errorf("failed to stat source directory: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("[DEBUG] copyDirectoryRecursive: Source dir mode: %s\n", srcInfo.Mode().String())

        // Create destination directory with same permissions
        fmt.Printf("[DEBUG] copyDirectoryRecursive: Creating destination directory with mode %s\n", srcInfo.Mode().String())
        err = os.MkdirAll(dst, srcInfo.Mode())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] copyDirectoryRecursive: Failed to create destination directory: %v\n", err)
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Read source directory entries
        <span class="cov0" title="0">fmt.Printf("[DEBUG] copyDirectoryRecursive: Reading source directory entries\n")
        entries, err := os.ReadDir(src)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] copyDirectoryRecursive: Failed to read source directory: %v\n", err)
                return fmt.Errorf("failed to read source directory: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("[DEBUG] copyDirectoryRecursive: Found %d entries to copy\n", len(entries))

        // Copy each entry
        for i, entry := range entries </span><span class="cov0" title="0">{
                srcPath := filepath.Join(src, entry.Name())
                dstPath := filepath.Join(dst, entry.Name())
                fmt.Printf("[DEBUG] copyDirectoryRecursive: Processing entry %d/%d: %s (isDir: %v)\n", i+1, len(entries), entry.Name(), entry.IsDir())

                if entry.IsDir() </span><span class="cov0" title="0">{
                        // Recursively copy subdirectory
                        fmt.Printf("[DEBUG] copyDirectoryRecursive: Recursively copying subdirectory %s\n", entry.Name())
                        err = fm.copyDirectoryRecursive(srcPath, dstPath)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[ERROR] copyDirectoryRecursive: Failed to copy subdirectory %s: %v\n", entry.Name(), err)
                                return fmt.Errorf("failed to copy subdirectory %s: %w", entry.Name(), err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file using platform provider
                        fmt.Printf("[DEBUG] copyDirectoryRecursive: Copying file %s\n", entry.Name())
                        err = fm.platform.CopyFile(srcPath, dstPath)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[ERROR] copyDirectoryRecursive: Failed to copy file %s: %v\n", entry.Name(), err)
                                return fmt.Errorf("failed to copy file %s: %w", entry.Name(), err)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("[DEBUG] copyDirectoryRecursive: Completed recursive copy successfully\n")
        return nil</span>
}

// ResolveConflict resolves conflicts based on the specified strategy.
func (fm *FileManager) ResolveConflict(existingPath, backupDir, strategy string) (*ConflictResolution, error) <span class="cov7" title="6">{
        result := &amp;ConflictResolution{
                Action: strategy,
        }

        switch strategy </span>{
        case "backup":<span class="cov3" title="2">
                if utils.PathExists(existingPath) </span><span class="cov3" title="2">{
                        backupPath, err := fm.CreateBackup(existingPath, backupDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create backup: %w", err)
                        }</span>
                        <span class="cov3" title="2">result.BackupPath = backupPath</span>
                }
                <span class="cov3" title="2">result.ShouldProceed = true</span>

        case "overwrite":<span class="cov3" title="2">
                result.ShouldProceed = true</span>

        case "skip":<span class="cov3" title="2">
                result.ShouldProceed = false</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown conflict resolution strategy: %s", strategy)</span>
        }

        <span class="cov7" title="6">return result, nil</span>
}

// ProcessTemplate processes a template file and writes the result to target.
func (fm *FileManager) ProcessTemplate(templatePath, targetPath string, variables map[string]interface{}, fileMode string) error <span class="cov4" title="3">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would process template %s to %s\n", templatePath, targetPath)
                return nil
        }</span>

        // Create template engine
        <span class="cov4" title="3">engine, err := template.NewGoTemplateEngine()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create template engine: %w", err)
        }</span>

        // Process template file
        <span class="cov4" title="3">err = engine.ProcessTemplateFile(templatePath, targetPath, variables, fileMode)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to process template: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package fileops

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

// PermissionConfig represents permission configuration for operations.
type PermissionConfig struct {
        DirectoryMode string
        FileMode      string
        Recursive     bool
        Rules         map[string]string // pattern -&gt; permission mapping
}

// ApplyPermissions applies permission configuration to a path.
func (fm *FileManager) ApplyPermissions(targetPath string, config *PermissionConfig) error <span class="cov6" title="6">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="6">if fm.dryRun </span><span class="cov1" title="1">{
                fmt.Printf("DRY RUN: Would apply permissions to %s (dir: %s, file: %s, recursive: %v)\n",
                        targetPath, config.DirectoryMode, config.FileMode, config.Recursive)
                return nil
        }</span>

        // Apply permissions based on whether target is directory or file
        <span class="cov5" title="5">info, err := os.Stat(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat target path: %w", err)
        }</span>

        <span class="cov5" title="5">if info.IsDir() </span><span class="cov1" title="1">{
                return fm.applyDirectoryPermissions(targetPath, config)
        }</span>

        <span class="cov4" title="4">return fm.applyFilePermissions(targetPath, config)</span>
}

// applyDirectoryPermissions applies permissions to a directory.
func (fm *FileManager) applyDirectoryPermissions(dirPath string, config *PermissionConfig) error <span class="cov1" title="1">{
        // Apply directory permission to the directory itself
        if config.DirectoryMode != "" </span><span class="cov1" title="1">{
                mode, err := parsePermissionString(config.DirectoryMode)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory permission %s: %w", config.DirectoryMode, err)
                }</span>

                <span class="cov1" title="1">err = fm.platform.SetPermissions(dirPath, mode)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set directory permissions: %w", err)
                }</span>
        }

        <span class="cov1" title="1">if config.Recursive </span><span class="cov0" title="0">{
                return fm.applyPermissionsRecursively(dirPath, config)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// applyFilePermissions applies permissions to a single file.
func (fm *FileManager) applyFilePermissions(filePath string, config *PermissionConfig) error <span class="cov4" title="4">{
        fileName := filepath.Base(filePath)

        // Check for specific rules first - find the most specific match
        permission := config.FileMode // default
        if config.Rules != nil </span><span class="cov4" title="3">{
                bestMatch := ""
                bestPerm := ""

                // Find the most specific pattern match
                for pattern, perm := range config.Rules </span><span class="cov6" title="6">{
                        if matched := matchPattern(pattern, fileName); matched </span><span class="cov4" title="3">{
                                // Prefer more specific patterns (patterns with more characters are generally more specific)
                                if bestMatch == "" || len(pattern) &gt; len(bestMatch) || isMoreSpecific(pattern, bestMatch) </span><span class="cov2" title="2">{
                                        bestMatch = pattern
                                        bestPerm = perm
                                }</span>
                        }
                }

                <span class="cov4" title="3">if bestMatch != "" </span><span class="cov2" title="2">{
                        permission = bestPerm
                }</span>
        }

        <span class="cov4" title="4">if permission == "" </span><span class="cov0" title="0">{
                return nil // No permission to apply
        }</span>

        <span class="cov4" title="4">mode, err := parsePermissionString(permission)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file permission %s: %w", permission, err)
        }</span>

        <span class="cov4" title="4">return fm.platform.SetPermissions(filePath, mode)</span>
}

// applyPermissionsRecursively applies permissions recursively to directory contents.
func (fm *FileManager) applyPermissionsRecursively(dirPath string, config *PermissionConfig) error <span class="cov0" title="0">{
        return filepath.WalkDir(dirPath, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip the root directory as it's handled separately
                <span class="cov0" title="0">if path == dirPath </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        if config.DirectoryMode != "" </span><span class="cov0" title="0">{
                                mode, parseErr := parsePermissionString(config.DirectoryMode)
                                if parseErr != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid directory permission %s: %w", config.DirectoryMode, parseErr)
                                }</span>

                                <span class="cov0" title="0">if setErr := fm.platform.SetPermissions(path, mode); setErr != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to set directory permissions for %s: %w", path, setErr)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Apply file permissions
                        if applyErr := fm.applyFilePermissions(path, config); applyErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply file permissions for %s: %w", path, applyErr)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// CreateSymlinkWithPermissions creates a symlink and applies permissions to the source.
func (fm *FileManager) CreateSymlinkWithPermissions(sourcePath, targetPath string, config *PermissionConfig) error <span class="cov0" title="0">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would create symlink %s -&gt; %s with permissions\n", targetPath, sourcePath)
                return nil
        }</span>

        // Create the symlink first
        <span class="cov0" title="0">err := fm.CreateSymlink(sourcePath, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Apply permissions to the source (since symlinks typically inherit permissions)
        <span class="cov0" title="0">if config != nil &amp;&amp; utils.PathExists(sourcePath) </span><span class="cov0" title="0">{
                return fm.ApplyPermissions(sourcePath, config)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateSymlinkWithParentsAndPermissions creates a symlink with parent directories and permissions.
func (fm *FileManager) CreateSymlinkWithParentsAndPermissions(sourcePath, targetPath string, config *PermissionConfig) error <span class="cov0" title="0">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would create symlink %s -&gt; %s (with parents and permissions)\n", targetPath, sourcePath)
                return nil
        }</span>

        // Create parent directories with appropriate permissions
        <span class="cov0" title="0">parentDir := filepath.Dir(targetPath)
        if config != nil &amp;&amp; config.DirectoryMode != "" </span><span class="cov0" title="0">{
                mode, err := parsePermissionString(config.DirectoryMode)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory permission: %w", err)
                }</span>
                <span class="cov0" title="0">err = os.MkdirAll(parentDir, mode)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create parent directories: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                err := os.MkdirAll(parentDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create parent directories: %w", err)
                }</span>
        }

        // Create symlink and apply permissions
        <span class="cov0" title="0">return fm.CreateSymlinkWithPermissions(sourcePath, targetPath, config)</span>
}

// CopyFileWithPermissions copies a file and applies comprehensive permission configuration.
func (fm *FileManager) CopyFileWithPermissions(sourcePath, targetPath string, config *PermissionConfig) error <span class="cov0" title="0">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN: Would copy %s to %s with permissions\n", sourcePath, targetPath)
                return nil
        }</span>

        // Use platform provider to copy file
        <span class="cov0" title="0">err := fm.platform.CopyFile(sourcePath, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        // Apply permissions
        <span class="cov0" title="0">if config != nil </span><span class="cov0" title="0">{
                err = fm.ApplyPermissions(targetPath, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply permissions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parsePermissionString parses a permission string to os.FileMode.
func parsePermissionString(perm string) (os.FileMode, error) <span class="cov10" title="24">{
        if perm == "" </span><span class="cov1" title="1">{
                return 0644, nil
        }</span>

        // Remove leading zeros for parsing
        <span class="cov9" title="23">trimmed := strings.TrimLeft(perm, "0")
        if trimmed == "" </span><span class="cov0" title="0">{
                trimmed = "0"
        }</span>

        // Parse as octal
        <span class="cov9" title="23">parsed, err := strconv.ParseUint(trimmed, 8, 32)
        if err != nil </span><span class="cov5" title="5">{
                return 0, fmt.Errorf("invalid permission format %q: %w", perm, err)
        }</span>

        // Validate permission range
        <span class="cov9" title="18">if parsed &gt; 0777 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("permission %q is out of valid range (0-777)", perm)
        }</span>

        <span class="cov9" title="18">return os.FileMode(parsed), nil</span>
}

// matchPattern matches a filename against a pattern (simple glob support).
func matchPattern(pattern, filename string) bool <span class="cov7" title="11">{
        matched, err := filepath.Match(pattern, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="11">return matched</span>
}

// isMoreSpecific determines if pattern1 is more specific than pattern2.
func isMoreSpecific(pattern1, pattern2 string) bool <span class="cov1" title="1">{
        // Count wildcards - fewer wildcards means more specific
        wildcards1 := strings.Count(pattern1, "*") + strings.Count(pattern1, "?")
        wildcards2 := strings.Count(pattern2, "*") + strings.Count(pattern2, "?")

        if wildcards1 != wildcards2 </span><span class="cov0" title="0">{
                return wildcards1 &lt; wildcards2
        }</span>

        // If same number of wildcards, prefer exact character matches
        <span class="cov1" title="1">exactChars1 := len(pattern1) - wildcards1
        exactChars2 := len(pattern2) - wildcards2

        return exactChars1 &gt; exactChars2</span>
}

// ValidatePermissionConfig validates a permission configuration.
func ValidatePermissionConfig(config *PermissionConfig) error <span class="cov5" title="5">{
        if config == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Validate directory mode
        <span class="cov4" title="4">if config.DirectoryMode != "" </span><span class="cov4" title="4">{
                _, err := parsePermissionString(config.DirectoryMode)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid directory permission: %w", err)
                }</span>
        }

        // Validate file mode
        <span class="cov4" title="3">if config.FileMode != "" </span><span class="cov4" title="3">{
                _, err := parsePermissionString(config.FileMode)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid file permission: %w", err)
                }</span>
        }

        // Validate rules
        <span class="cov2" title="2">for pattern, perm := range config.Rules </span><span class="cov4" title="3">{
                if _, err := parsePermissionString(perm); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid permission %s for pattern %s: %w", perm, pattern, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package git

import (
        "context"
        "errors"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/go-git/go-git/v5"
        "github.com/go-git/go-git/v5/config"
        "github.com/go-git/go-git/v5/plumbing"
        "github.com/go-git/go-git/v5/plumbing/transport"
        "github.com/go-git/go-git/v5/plumbing/transport/http"
        "github.com/go-git/go-git/v5/plumbing/transport/ssh"
        "github.com/go-git/go-git/v5/storage/memory"
)

// GitManager handles Git operations for dotfiles repositories.
type GitManager struct {
        auth   transport.AuthMethod
        config *AuthConfig
}

// RepositoryInfo contains information about a Git repository.
type RepositoryInfo struct {
        URL        string
        LocalPath  string
        Branch     string
        LastCommit string
        LastUpdate time.Time
}

// AuthConfig contains authentication configuration.
type AuthConfig struct {
        // Personal Access Token for HTTPS authentication
        PersonalAccessToken string
        // Username for HTTPS authentication (optional, defaults to token)
        Username string
        // SSH Private Key path for SSH authentication
        SSHPrivateKeyPath string
        // SSH Private Key passphrase
        SSHPassphrase string
        // SSH Known Hosts file path
        SSHKnownHostsPath string
        // Skip SSH host key verification (insecure)
        SSHSkipHostKeyVerification bool
        // Authentication method preference
        AuthMethod string
}

// NewGitManager creates a new Git manager with authentication.
func NewGitManager(authConfig *AuthConfig) (*GitManager, error) <span class="cov5" title="10">{
        manager := &amp;GitManager{
                config: authConfig,
        }

        if authConfig != nil </span><span class="cov5" title="8">{
                auth, err := buildAuthMethod(authConfig)
                if err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("failed to build authentication: %w", err)
                }</span>
                <span class="cov4" title="6">manager.auth = auth</span>
        }

        <span class="cov5" title="8">return manager, nil</span>
}

// IsGitURL checks if the given string is a valid Git URL.
func IsGitURL(sourceURL string) bool <span class="cov8" title="32">{
        // Match GitHub URLs
        githubPatterns := []string{
                `^https://github\.com/[\w\-\.]+/[\w\-\.]+(?:\.git)?/?$`,
                `^git@github\.com:[\w\-\.]+/[\w\-\.]+(?:\.git)?$`,
                `^github\.com[:/][\w\-\.]+/[\w\-\.]+(?:\.git)?/?$`,
        }

        for _, pattern := range githubPatterns </span><span class="cov10" title="84">{
                matched, _ := regexp.MatchString(pattern, sourceURL)
                if matched </span><span class="cov6" title="12">{
                        return true
                }</span>
        }

        // Match general Git URLs
        <span class="cov7" title="20">generalPatterns := []string{
                `^https?://.*\.git$`,
                `^git@.*:.*\.git$`,
                `^ssh://.*\.git$`,
        }

        for _, pattern := range generalPatterns </span><span class="cov8" title="51">{
                matched, _ := regexp.MatchString(pattern, sourceURL)
                if matched </span><span class="cov5" title="8">{
                        return true
                }</span>
        }

        <span class="cov6" title="12">return false</span>
}

// NormalizeGitURL converts various Git URL formats to standard format.
func NormalizeGitURL(sourceURL string) (string, error) <span class="cov6" title="13">{
        // Handle GitHub shorthand formats
        if matched, _ := regexp.MatchString(`^github\.com[:/][\w\-\.]+/[\w\-\.]+`, sourceURL); matched </span><span class="cov4" title="5">{
                // Convert github.com/user/repo to https://github.com/user/repo.git
                url := strings.TrimPrefix(sourceURL, "github.com/")
                url = strings.TrimPrefix(url, "github.com:")
                if !strings.HasSuffix(url, ".git") </span><span class="cov3" title="4">{
                        url = url + ".git"
                }</span>
                <span class="cov4" title="5">return "https://github.com/" + url, nil</span>
        }

        // Ensure .git suffix for GitHub HTTPS URLs
        <span class="cov5" title="8">if matched, _ := regexp.MatchString(`^https://github\.com/[\w\-\.]+/[\w\-\.]+$`, sourceURL); matched </span><span class="cov3" title="4">{
                if !strings.HasSuffix(sourceURL, ".git") </span><span class="cov2" title="2">{
                        return sourceURL + ".git", nil
                }</span>
        }

        <span class="cov4" title="6">return sourceURL, nil</span>
}

// CloneRepository clones a Git repository to the specified local path.
func (g *GitManager) CloneRepository(ctx context.Context, repoURL, localPath, branch string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        // Normalize the URL
        normalizedURL, err := NormalizeGitURL(repoURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to normalize URL: %w", err)
        }</span>

        // Ensure local path directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(localPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Clone options
        <span class="cov0" title="0">cloneOptions := &amp;git.CloneOptions{
                URL:          normalizedURL,
                Auth:         g.auth,
                RemoteName:   "origin",
                SingleBranch: true,
                Tags:         git.NoTags,
        }

        if branch != "" </span><span class="cov0" title="0">{
                cloneOptions.ReferenceName = plumbing.ReferenceName("refs/heads/" + branch)
        }</span> else<span class="cov0" title="0"> {
                // Let Git determine the default branch
                cloneOptions.SingleBranch = false
        }</span>

        // Perform clone
        <span class="cov0" title="0">repo, err := git.PlainCloneContext(ctx, localPath, false, cloneOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        // Get repository info
        <span class="cov0" title="0">info, err := g.getRepositoryInfo(repo, normalizedURL, localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get repository info: %w", err)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// UpdateRepository pulls the latest changes from the remote repository.
func (g *GitManager) UpdateRepository(ctx context.Context, localPath string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        // Open existing repository
        repo, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open repository: %w", err)
        }</span>

        // Get working tree
        <span class="cov0" title="0">worktree, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get worktree: %w", err)
        }</span>

        // Pull latest changes
        <span class="cov0" title="0">pullOptions := &amp;git.PullOptions{
                RemoteName: "origin",
                Auth:       g.auth,
        }

        err = worktree.PullContext(ctx, pullOptions)
        if err != nil &amp;&amp; !errors.Is(err, git.NoErrAlreadyUpToDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to pull updates: %w", err)
        }</span>

        // Get remote URL
        <span class="cov0" title="0">remote, err := repo.Remote("origin")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get remote: %w", err)
        }</span>

        <span class="cov0" title="0">var remoteURL string
        if len(remote.Config().URLs) &gt; 0 </span><span class="cov0" title="0">{
                remoteURL = remote.Config().URLs[0]
        }</span>

        // Get repository info
        <span class="cov0" title="0">info, err := g.getRepositoryInfo(repo, remoteURL, localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get repository info: %w", err)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// GetRepositoryInfo returns information about a local Git repository.
func (g *GitManager) GetRepositoryInfo(localPath string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        repo, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open repository: %w", err)
        }</span>

        // Get remote URL
        <span class="cov0" title="0">remote, err := repo.Remote("origin")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get remote: %w", err)
        }</span>

        <span class="cov0" title="0">var remoteURL string
        if len(remote.Config().URLs) &gt; 0 </span><span class="cov0" title="0">{
                remoteURL = remote.Config().URLs[0]
        }</span>

        <span class="cov0" title="0">return g.getRepositoryInfo(repo, remoteURL, localPath)</span>
}

// ValidateRepository checks if a local path contains a valid Git repository.
func (g *GitManager) ValidateRepository(localPath string) error <span class="cov2" title="2">{
        _, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid Git repository at %s: %w", localPath, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// getRepositoryInfo extracts information from a Git repository.
func (g *GitManager) getRepositoryInfo(repo *git.Repository, url, localPath string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        // Get HEAD reference
        head, err := repo.Head()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Get current branch
        <span class="cov0" title="0">var branch string
        if head.Name().IsBranch() </span><span class="cov0" title="0">{
                branch = head.Name().Short()
        }</span>

        // Get last commit
        <span class="cov0" title="0">commit, err := repo.CommitObject(head.Hash())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RepositoryInfo{
                URL:        url,
                LocalPath:  localPath,
                Branch:     branch,
                LastCommit: commit.Hash.String(),
                LastUpdate: time.Now(),
        }, nil</span>
}

// buildAuthMethod creates appropriate authentication method.
func buildAuthMethod(authConfig *AuthConfig) (transport.AuthMethod, error) <span class="cov6" title="12">{
        // SSH authentication
        if authConfig.SSHPrivateKeyPath != "" </span><span class="cov3" title="3">{
                sshAuth, err := ssh.NewPublicKeysFromFile("git", authConfig.SSHPrivateKeyPath, authConfig.SSHPassphrase)
                if err != nil </span><span class="cov3" title="3">{
                        return nil, fmt.Errorf("failed to create SSH auth: %w", err)
                }</span>
                <span class="cov0" title="0">return sshAuth, nil</span>
        }

        // HTTPS authentication with PAT
        <span class="cov5" title="9">if authConfig.PersonalAccessToken != "" </span><span class="cov4" title="6">{
                username := authConfig.Username
                if username == "" </span><span class="cov3" title="3">{
                        username = authConfig.PersonalAccessToken // GitHub allows token as username
                }</span>

                <span class="cov4" title="6">return &amp;http.BasicAuth{
                        Username: username,
                        Password: authConfig.PersonalAccessToken,
                }, nil</span>
        }

        // No authentication
        <span class="cov3" title="3">return nil, nil</span>
}

// GetLocalCachePath returns the local cache path for a Git repository.
func GetLocalCachePath(cacheRoot, repoURL string) (string, error) <span class="cov5" title="9">{
        // Parse the URL to create a safe directory name
        parsedURL, err := url.Parse(repoURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        // Create safe directory name from URL
        <span class="cov5" title="9">host := parsedURL.Host
        path := strings.TrimPrefix(parsedURL.Path, "/")
        path = strings.TrimSuffix(path, ".git")

        safePath := filepath.Join(host, path)
        // Replace any unsafe characters
        safePath = strings.ReplaceAll(safePath, ":", "_")
        safePath = strings.ReplaceAll(safePath, "?", "_")
        safePath = strings.ReplaceAll(safePath, "*", "_")

        return filepath.Join(cacheRoot, safePath), nil</span>
}

// CloneOptions contains options for cloning repositories.
type CloneOptions struct {
        // URL is the repository URL to clone
        URL string
        // LocalPath is where to clone the repository
        LocalPath string
        // Branch is the specific branch to clone (optional)
        Branch string
        // Depth limits the clone depth (0 for full clone)
        Depth int
        // RecurseSubmodules indicates whether to clone submodules
        RecurseSubmodules bool
        // SingleBranch indicates whether to clone only the specified branch
        SingleBranch bool
        // Progress callback for clone progress
        Progress func(message string)
}

// CloneRepositoryWithOptions clones a repository with enhanced options.
func (gm *GitManager) CloneRepositoryWithOptions(ctx context.Context, options CloneOptions) (*RepositoryInfo, error) <span class="cov0" title="0">{
        cloneOptions := &amp;git.CloneOptions{
                URL:      options.URL,
                Auth:     gm.auth,
                Progress: nil, // We'll handle progress separately
        }

        // Set branch if specified
        if options.Branch != "" </span><span class="cov0" title="0">{
                cloneOptions.ReferenceName = plumbing.ReferenceName("refs/heads/" + options.Branch)
                cloneOptions.SingleBranch = options.SingleBranch
        }</span>

        // Set depth if specified
        <span class="cov0" title="0">if options.Depth &gt; 0 </span><span class="cov0" title="0">{
                cloneOptions.Depth = options.Depth
        }</span>

        // Set submodule recursion
        <span class="cov0" title="0">if options.RecurseSubmodules </span><span class="cov0" title="0">{
                cloneOptions.RecurseSubmodules = git.DefaultSubmoduleRecursionDepth
        }</span>

        // Clone the repository
        <span class="cov0" title="0">repo, err := git.PlainCloneContext(ctx, options.LocalPath, false, cloneOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        // Get repository information
        <span class="cov0" title="0">return gm.getRepositoryInfoFromRepo(repo, options.URL, options.LocalPath)</span>
}

// UpdateSubmodules updates all submodules in a repository.
func (gm *GitManager) UpdateSubmodules(ctx context.Context, localPath string) error <span class="cov0" title="0">{
        repo, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open repository: %w", err)
        }</span>

        <span class="cov0" title="0">worktree, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get worktree: %w", err)
        }</span>

        // Get submodules and update them individually
        <span class="cov0" title="0">submodules, err := worktree.Submodules()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get submodules: %w", err)
        }</span>

        // Update each submodule
        <span class="cov0" title="0">for _, submodule := range submodules </span><span class="cov0" title="0">{
                err = submodule.Update(&amp;git.SubmoduleUpdateOptions{
                        Init: true,
                        Auth: gm.auth,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update submodule %s: %w", submodule.Config().Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ListSubmodules lists all submodules in a repository.
func (gm *GitManager) ListSubmodules(localPath string) ([]*SubmoduleInfo, error) <span class="cov0" title="0">{
        repo, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open repository: %w", err)
        }</span>

        <span class="cov0" title="0">worktree, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get worktree: %w", err)
        }</span>

        <span class="cov0" title="0">submodules, err := worktree.Submodules()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get submodules: %w", err)
        }</span>

        <span class="cov0" title="0">var submoduleInfos []*SubmoduleInfo
        for _, submodule := range submodules </span><span class="cov0" title="0">{
                config := submodule.Config()
                status, err := submodule.Status()
                if err != nil </span><span class="cov0" title="0">{
                        // Continue with other submodules if one fails
                        continue</span>
                }

                <span class="cov0" title="0">info := &amp;SubmoduleInfo{
                        Name:   config.Name,
                        Path:   config.Path,
                        URL:    config.URL,
                        Branch: config.Branch,
                        Status: status.Current.String(),
                }
                submoduleInfos = append(submoduleInfos, info)</span>
        }

        <span class="cov0" title="0">return submoduleInfos, nil</span>
}

// SubmoduleInfo contains information about a Git submodule.
type SubmoduleInfo struct {
        Name   string
        Path   string
        URL    string
        Branch string
        Status string
}

// ValidateRepositoryDetailed validates that a repository is properly configured and returns detailed results.
func (gm *GitManager) ValidateRepositoryDetailed(localPath string) (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                Valid:    true,
                Warnings: []string{},
                Errors:   []string{},
        }

        // Check if directory exists
        if _, err := os.Stat(localPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                result.Valid = false
                result.Errors = append(result.Errors, "Repository directory does not exist")
                return result, nil
        }</span>

        // Check if it's a Git repository
        <span class="cov0" title="0">repo, err := git.PlainOpen(localPath)
        if err != nil </span><span class="cov0" title="0">{
                result.Valid = false
                result.Errors = append(result.Errors, "Not a valid Git repository: "+err.Error())
                return result, err
        }</span>

        // Check for uncommitted changes
        <span class="cov0" title="0">worktree, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "Could not check worktree status: "+err.Error())
                return result, err
        }</span> else<span class="cov0" title="0"> {
                status, err := worktree.Status()
                if err != nil </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "Could not get repository status: "+err.Error())
                }</span> else<span class="cov0" title="0"> if !status.IsClean() </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "Repository has uncommitted changes")
                }</span>
        }

        // Check for submodules and their status
        <span class="cov0" title="0">if worktree != nil </span><span class="cov0" title="0">{
                submodules, err := worktree.Submodules()
                if err == nil &amp;&amp; len(submodules) &gt; 0 </span><span class="cov0" title="0">{
                        for _, submodule := range submodules </span><span class="cov0" title="0">{
                                status, err := submodule.Status()
                                if err != nil </span><span class="cov0" title="0">{
                                        result.Warnings = append(result.Warnings,
                                                fmt.Sprintf("Could not check submodule %s status: %s",
                                                        submodule.Config().Name, err.Error()))
                                }</span> else<span class="cov0" title="0"> if !status.IsClean() </span><span class="cov0" title="0">{
                                        result.Warnings = append(result.Warnings,
                                                fmt.Sprintf("Submodule %s has uncommitted changes",
                                                        submodule.Config().Name))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ValidationResult contains the result of repository validation.
type ValidationResult struct {
        Valid    bool
        Warnings []string
        Errors   []string
}

// GetRemoteInfo gets information about the remote repository.
func (gm *GitManager) GetRemoteInfo(ctx context.Context, repoURL string) (*RemoteInfo, error) <span class="cov0" title="0">{
        // Create a memory storage for remote operations
        storage := memory.NewStorage()

        // Create remote
        remote := git.NewRemote(storage, &amp;config.RemoteConfig{
                Name: "origin",
                URLs: []string{repoURL},
        })

        // List references
        refs, err := remote.List(&amp;git.ListOptions{
                Auth: gm.auth,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list remote references: %w", err)
        }</span>

        <span class="cov0" title="0">info := &amp;RemoteInfo{
                URL:      repoURL,
                Branches: []string{},
                Tags:     []string{},
        }

        // Parse references
        for _, ref := range refs </span><span class="cov0" title="0">{
                name := ref.Name()
                if name.IsBranch() </span><span class="cov0" title="0">{
                        branchName := name.Short()
                        info.Branches = append(info.Branches, branchName)
                        if branchName == "main" || branchName == "master" </span><span class="cov0" title="0">{
                                info.DefaultBranch = branchName
                        }</span>
                } else<span class="cov0" title="0"> if name.IsTag() </span><span class="cov0" title="0">{
                        info.Tags = append(info.Tags, name.Short())
                }</span>
        }

        // Set default branch if not found
        <span class="cov0" title="0">if info.DefaultBranch == "" &amp;&amp; len(info.Branches) &gt; 0 </span><span class="cov0" title="0">{
                info.DefaultBranch = info.Branches[0]
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// RemoteInfo contains information about a remote repository.
type RemoteInfo struct {
        URL           string
        DefaultBranch string
        Branches      []string
        Tags          []string
}

// Helper method to get repository info from a git.Repository.
func (gm *GitManager) getRepositoryInfoFromRepo(repo *git.Repository, url, localPath string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        // Get HEAD reference
        head, err := repo.Head()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Get branch name
        <span class="cov0" title="0">var branchName string
        if head.Name().IsBranch() </span><span class="cov0" title="0">{
                branchName = head.Name().Short()
        }</span> else<span class="cov0" title="0"> {
                branchName = "detached"
        }</span>

        // Get last commit
        <span class="cov0" title="0">commit, err := repo.CommitObject(head.Hash())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RepositoryInfo{
                URL:        url,
                LocalPath:  localPath,
                Branch:     branchName,
                LastCommit: commit.Hash.String(),
                LastUpdate: time.Now(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package idempotency

import (
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// OperationState represents the current state of an operation.
type OperationState int

const (
        // StateUnknown indicates the operation state cannot be determined.
        StateUnknown OperationState = iota
        // StateNotStarted indicates the operation has not been performed.
        StateNotStarted
        // StateInProgress indicates the operation is currently in progress.
        StateInProgress
        // StateCompleted indicates the operation completed successfully.
        StateCompleted
        // StateFailed indicates the operation failed.
        StateFailed
)

// String returns a string representation of the operation state.
func (os OperationState) String() string <span class="cov0" title="0">{
        switch os </span>{
        case StateNotStarted:<span class="cov0" title="0">
                return "not_started"</span>
        case StateInProgress:<span class="cov0" title="0">
                return "in_progress"</span>
        case StateCompleted:<span class="cov0" title="0">
                return "completed"</span>
        case StateFailed:<span class="cov0" title="0">
                return "failed"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// FileState represents the current state of a file for idempotency checking.
type FileState struct {
        Path          string
        Exists        bool
        Size          int64
        ModTime       time.Time
        ContentHash   string
        IsSymlink     bool
        SymlinkTarget string
        Mode          os.FileMode
}

// GetFileState captures the current state of a file for idempotency checking.
func GetFileState(path string) (*FileState, error) <span class="cov10" title="136">{
        state := &amp;FileState{
                Path: path,
        }

        // Check if file exists using Lstat (doesn't follow symlinks)
        info, err := os.Lstat(path)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                state.Exists = false
                return nil, fmt.Errorf("file does not exist: %s", path)
        }</span>
        <span class="cov9" title="135">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat file %s: %w", path, err)
        }</span>

        <span class="cov9" title="135">state.Exists = true
        // For directories, set size to 0 for consistency
        if info.IsDir() </span><span class="cov2" title="2">{
                state.Size = 0
        }</span> else<span class="cov9" title="133"> {
                state.Size = info.Size()
        }</span>
        <span class="cov9" title="135">state.ModTime = info.ModTime()
        state.Mode = info.Mode()

        // Check if it's a symlink
        if info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov1" title="1">{
                state.IsSymlink = true
                target, err := os.Readlink(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read symlink target for %s: %w", path, err)
                }</span>
                <span class="cov1" title="1">state.SymlinkTarget = target</span>
        } else<span class="cov9" title="134"> {
                // Calculate content hash for regular files
                if info.Mode().IsRegular() </span><span class="cov9" title="132">{
                        hash, err := calculateFileHash(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to calculate hash for %s: %w", path, err)
                        }</span>
                        <span class="cov9" title="132">state.ContentHash = hash</span>
                }
        }

        <span class="cov9" title="135">return state, nil</span>
}

// calculateFileHash calculates the SHA256 hash of a file's content.
func calculateFileHash(path string) (string, error) <span class="cov9" title="132">{
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="132">hash := sha256.Sum256(content)
        return fmt.Sprintf("%x", hash), nil</span>
}

// CompareFileStates compares two file states to determine if they're equivalent.
func CompareFileStates(before, after *FileState) bool <span class="cov4" title="7">{
        if before == nil &amp;&amp; after == nil </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov4" title="6">if before == nil || after == nil </span><span class="cov2" title="2">{
                return false
        }</span>

        // Basic existence check
        <span class="cov3" title="4">if before.Exists != after.Exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="4">if !before.Exists &amp;&amp; !after.Exists </span><span class="cov0" title="0">{
                return true // Both don't exist
        }</span>

        // Compare file properties
        <span class="cov3" title="4">if before.IsSymlink != after.IsSymlink </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="4">if before.IsSymlink </span><span class="cov0" title="0">{
                // For symlinks, compare the target
                return before.SymlinkTarget == after.SymlinkTarget
        }</span>

        // For regular files, compare size and content hash
        <span class="cov3" title="4">if before.Size != after.Size </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="3">if before.ContentHash != "" &amp;&amp; after.ContentHash != "" </span><span class="cov3" title="3">{
                return before.ContentHash == after.ContentHash
        }</span>

        // If we can't compare hashes, compare mod time and size
        <span class="cov0" title="0">return before.Size == after.Size &amp;&amp; before.ModTime.Equal(after.ModTime)</span>
}

// DirectoryState represents the current state of a directory for idempotency checking.
type DirectoryState struct {
        Path      string
        Exists    bool
        FileCount int64
        Files     map[string]*FileState
        ModTime   time.Time
}

// GetDirectoryState captures the current state of a directory and its contents.
func GetDirectoryState(ctx context.Context, path string, recursive bool) (*DirectoryState, error) <span class="cov5" title="9">{
        state := &amp;DirectoryState{
                Path:  path,
                Files: make(map[string]*FileState),
        }

        // Check if directory exists
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                state.Exists = false
                return nil, fmt.Errorf("directory does not exist: %s", path)
        }</span>
        <span class="cov4" title="8">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat directory %s: %w", path, err)
        }</span>

        <span class="cov4" title="8">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path %s is not a directory", path)
        }</span>

        <span class="cov4" title="8">state.Exists = true
        state.ModTime = info.ModTime()

        // Walk the directory to get file states
        walkFunc := func(filePath string, info os.FileInfo, err error) error </span><span class="cov9" title="121">{
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Error walking directory", map[string]interface{}{
                                "path":  filePath,
                                "error": err.Error(),
                        })
                        return err // Return the error to stop walking on serious issues
                }</span>

                // Skip the root directory itself
                <span class="cov9" title="121">if filePath == path </span><span class="cov4" title="7">{
                        return nil
                }</span>

                // For non-recursive mode, skip subdirectories but don't include them in the state
                <span class="cov9" title="114">if !recursive &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                        return filepath.SkipDir
                }</span>

                // Get relative path for consistent keys
                <span class="cov9" title="114">relPath, err := filepath.Rel(path, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to get relative path", map[string]interface{}{
                                "base":  path,
                                "file":  filePath,
                                "error": err.Error(),
                        })
                        return err
                }</span>

                // Get file state
                <span class="cov9" title="114">fileState, err := GetFileState(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to get file state", map[string]interface{}{
                                "path":  filePath,
                                "error": err.Error(),
                        })
                        return err
                }</span>

                // Only include files in the state, not directories
                <span class="cov9" title="114">if !info.IsDir() </span><span class="cov9" title="113">{
                        state.Files[relPath] = fileState
                        state.FileCount++
                }</span>

                <span class="cov9" title="114">return nil</span>
        }

        <span class="cov4" title="8">if recursive </span><span class="cov4" title="7">{
                err = filepath.Walk(path, walkFunc)
        }</span> else<span class="cov1" title="1"> {
                // For non-recursive, just read the immediate directory
                entries, err := os.ReadDir(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read directory %s: %w", path, err)
                }</span>

                <span class="cov1" title="1">for _, entry := range entries </span><span class="cov2" title="2">{
                        entryPath := filepath.Join(path, entry.Name())
                        info, err := entry.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                tflog.Warn(ctx, "Failed to get entry info", map[string]interface{}{
                                        "path":  entryPath,
                                        "error": err.Error(),
                                })
                                continue</span>
                        }

                        // Skip directories in non-recursive mode
                        <span class="cov2" title="2">if info.IsDir() </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov1" title="1">err = walkFunc(entryPath, info, nil)
                        if err != nil &amp;&amp; err != filepath.SkipDir </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov4" title="8">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk directory %s: %w", path, err)
        }</span>

        <span class="cov4" title="8">return state, nil</span>
}

// CompareDirectoryStates compares two directory states to determine if they're equivalent.
func CompareDirectoryStates(before, after *DirectoryState) bool <span class="cov2" title="2">{
        if before == nil &amp;&amp; after == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov2" title="2">if before == nil || after == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Basic existence check
        <span class="cov2" title="2">if before.Exists != after.Exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="2">if !before.Exists &amp;&amp; !after.Exists </span><span class="cov0" title="0">{
                return true // Both don't exist
        }</span>

        // Compare file counts
        <span class="cov2" title="2">if before.FileCount != after.FileCount </span><span class="cov1" title="1">{
                return false
        }</span>

        // Compare individual files
        <span class="cov1" title="1">if len(before.Files) != len(after.Files) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">for relPath, beforeFile := range before.Files </span><span class="cov2" title="2">{
                afterFile, exists := after.Files[relPath]
                if !exists </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov2" title="2">if !CompareFileStates(beforeFile, afterFile) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov1" title="1">return true</span>
}

// EnsureIdempotentFileOperation ensures a file operation is idempotent by checking current state.
func EnsureIdempotentFileOperation(ctx context.Context, targetPath string, operation func() error) error <span class="cov0" title="0">{
        // Get initial state
        beforeState, err := GetFileState(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Could not get initial file state", map[string]interface{}{
                        "path":  targetPath,
                        "error": err.Error(),
                })
                // Continue with operation even if we can't get initial state
        }</span>

        // Perform the operation
        <span class="cov0" title="0">err = operation()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get final state
        <span class="cov0" title="0">afterState, err := GetFileState(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Could not get final file state", map[string]interface{}{
                        "path":  targetPath,
                        "error": err.Error(),
                })
                // Operation succeeded, state check is just informational
                // nolint:nilerr // Intentionally ignoring error as this is post-operation state checking
                return nil
        }</span>

        // Log the state change
        <span class="cov0" title="0">if beforeState != nil </span><span class="cov0" title="0">{
                statesEqual := CompareFileStates(beforeState, afterState)
                tflog.Debug(ctx, "File operation completed", map[string]interface{}{
                        "path":           targetPath,
                        "states_equal":   statesEqual,
                        "before_exists":  beforeState.Exists,
                        "after_exists":   afterState.Exists,
                        "before_size":    beforeState.Size,
                        "after_size":     afterState.Size,
                        "before_symlink": beforeState.IsSymlink,
                        "after_symlink":  afterState.IsSymlink,
                })

                if statesEqual </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "File operation was idempotent - no changes made", map[string]interface{}{
                                "path": targetPath,
                        })
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// EnsureIdempotentDirectoryOperation ensures a directory operation is idempotent.
func EnsureIdempotentDirectoryOperation(ctx context.Context, targetPath string, recursive bool, operation func() error) error <span class="cov0" title="0">{
        // Get initial state
        beforeState, err := GetDirectoryState(ctx, targetPath, recursive)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Could not get initial directory state", map[string]interface{}{
                        "path":  targetPath,
                        "error": err.Error(),
                })
                // Continue with operation even if we can't get initial state
        }</span>

        // Perform the operation
        <span class="cov0" title="0">err = operation()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get final state
        <span class="cov0" title="0">afterState, err := GetDirectoryState(ctx, targetPath, recursive)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Could not get final directory state", map[string]interface{}{
                        "path":  targetPath,
                        "error": err.Error(),
                })
                // Operation succeeded, state check is just informational
                // nolint:nilerr // Intentionally ignoring error as this is post-operation state checking
                return nil
        }</span>

        // Log the state change
        <span class="cov0" title="0">if beforeState != nil </span><span class="cov0" title="0">{
                statesEqual := CompareDirectoryStates(beforeState, afterState)
                tflog.Debug(ctx, "Directory operation completed", map[string]interface{}{
                        "path":              targetPath,
                        "states_equal":      statesEqual,
                        "before_exists":     beforeState.Exists,
                        "after_exists":      afterState.Exists,
                        "before_file_count": beforeState.FileCount,
                        "after_file_count":  afterState.FileCount,
                })

                if statesEqual </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Directory operation was idempotent - no changes made", map[string]interface{}{
                                "path": targetPath,
                        })
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// IsDryRunMode checks if the operation should be performed in dry-run mode.
func IsDryRunMode(ctx context.Context, dryRun bool) bool <span class="cov0" title="0">{
        if dryRun </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Operating in dry-run mode - no actual changes will be made")
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// LogDryRunOperation logs what would be done in dry-run mode.
func LogDryRunOperation(ctx context.Context, operation, path string, details map[string]interface{}) <span class="cov0" title="0">{
        logDetails := map[string]interface{}{
                "operation": operation,
                "path":      path,
                "dry_run":   true,
        }

        for k, v := range details </span><span class="cov0" title="0">{
                logDetails[k] = v
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "DRY RUN: Would perform operation", logDetails)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package migration

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "regexp"
        "strings"
)

// ValidationIssue represents a compatibility issue found in a configuration.
type ValidationIssue struct {
        LineNumber  int
        Description string
        Suggestion  string
}

// MigrateConfigFile migrates a Terraform configuration file from the old format to the new format.
func MigrateConfigFile(inputFile, outputFile string) error <span class="cov0" title="0">{
        input, err := os.Open(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := input.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = cerr
                }</span>
        }()

        <span class="cov0" title="0">output, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := output.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = cerr
                }</span>
        }()

        <span class="cov0" title="0">return migrateConfig(input, output)</span>
}

// ValidateConfigFile checks a Terraform configuration file for compatibility issues.
func ValidateConfigFile(inputFile string) ([]ValidationIssue, error) <span class="cov0" title="0">{
        input, err := os.Open(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = input.Close() // Best effort close, errors are not critical for validation
        }</span>()

        <span class="cov0" title="0">return validateConfig(input)</span>
}

// migrateConfig performs the actual migration from input to output.
func migrateConfig(input io.Reader, output io.Writer) error <span class="cov5" title="5">{
        scanner := bufio.NewScanner(input)
        writer := bufio.NewWriter(output)
        defer func() </span><span class="cov5" title="5">{
                _ = writer.Flush() // Best effort flush, errors handled elsewhere
        }</span>()

        <span class="cov5" title="5">var currentResource *ResourceContext
        lineNumber := 0

        for scanner.Scan() </span><span class="cov10" title="37">{
                line := scanner.Text()
                lineNumber++

                // Check if we're starting a new dotfiles_file resource
                if match := fileResourceRegex.FindStringSubmatch(line); match != nil </span><span class="cov4" title="4">{
                        currentResource = &amp;ResourceContext{
                                ResourceType: "dotfiles_file",
                                ResourceName: match[1],
                                StartLine:    lineNumber,
                                Lines:        []string{line},
                        }
                        continue</span>
                }

                // If we're inside a resource, collect lines
                <span class="cov9" title="33">if currentResource != nil </span><span class="cov9" title="27">{
                        currentResource.Lines = append(currentResource.Lines, line)

                        // Check for strategy field
                        if match := strategyFieldRegex.FindStringSubmatch(line); match != nil </span><span class="cov3" title="3">{
                                currentResource.Strategy = strings.Trim(match[1], `"`)
                        }</span>

                        // Check if we've reached the end of the resource
                        <span class="cov9" title="27">if strings.TrimSpace(line) == "}" &amp;&amp; isResourceEnd(currentResource.Lines) </span><span class="cov4" title="4">{
                                // Process the resource
                                migratedLines, err := migrateResource(currentResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to migrate resource %s at line %d: %w",
                                                currentResource.ResourceName, currentResource.StartLine, err)
                                }</span>

                                // Write migrated resource
                                <span class="cov4" title="4">for _, migratedLine := range migratedLines </span><span class="cov9" title="31">{
                                        if _, err := writer.WriteString(migratedLine + "\n"); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                                <span class="cov4" title="4">currentResource = nil
                                continue</span>
                        }
                }

                // If not inside a resource or resource doesn't need migration, write as-is
                <span class="cov9" title="29">if currentResource == nil </span><span class="cov5" title="6">{
                        if _, err := writer.WriteString(line + "\n"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov5" title="5">return scanner.Err()</span>
}

// validateConfig checks for compatibility issues without modifying the config.
func validateConfig(input io.Reader) ([]ValidationIssue, error) <span class="cov5" title="5">{
        scanner := bufio.NewScanner(input)
        var issues []ValidationIssue
        lineNumber := 0

        for scanner.Scan() </span><span class="cov5" title="7">{
                line := scanner.Text()
                lineNumber++

                // Check for dotfiles_file resources with strategy field
                if fileResourceRegex.MatchString(line) </span><span class="cov4" title="4">{
                        resourceName := fileResourceRegex.FindStringSubmatch(line)[1]

                        // Look ahead to find strategy field in this resource
                        resourceLines := []string{line}
                        braceCount := strings.Count(line, "{") - strings.Count(line, "}")

                        for braceCount &gt; 0 &amp;&amp; scanner.Scan() </span><span class="cov6" title="8">{
                                lineNumber++
                                nextLine := scanner.Text()
                                resourceLines = append(resourceLines, nextLine)
                                braceCount += strings.Count(nextLine, "{") - strings.Count(nextLine, "}")

                                // Check for strategy field
                                if match := strategyFieldRegex.FindStringSubmatch(nextLine); match != nil </span><span class="cov3" title="3">{
                                        strategy := strings.Trim(match[1], `"`)
                                        issue := ValidationIssue{
                                                LineNumber:  lineNumber,
                                                Description: fmt.Sprintf("Resource '%s' uses deprecated strategy field with value '%s'", resourceName, strategy),
                                        }

                                        switch strategy </span>{
                                        case "symlink":<span class="cov1" title="1">
                                                issue.Suggestion = "Convert to dotfiles_symlink resource"</span>
                                        case "copy":<span class="cov1" title="1">
                                                issue.Suggestion = "Remove strategy field (dotfiles_file defaults to copy)"</span>
                                        case "template":<span class="cov1" title="1">
                                                issue.Suggestion = "Remove strategy field and set is_template = true"</span>
                                        default:<span class="cov0" title="0">
                                                issue.Suggestion = "Consider using dotfiles_application for complex strategies"</span>
                                        }

                                        <span class="cov3" title="3">issues = append(issues, issue)</span>
                                }
                        }
                }
        }

        <span class="cov5" title="5">return issues, scanner.Err()</span>
}

// ResourceContext holds information about a resource being processed.
type ResourceContext struct {
        ResourceType string
        ResourceName string
        Strategy     string
        StartLine    int
        Lines        []string
}

// migrateResource converts a dotfiles_file resource to the appropriate new format.
func migrateResource(ctx *ResourceContext) ([]string, error) <span class="cov4" title="4">{
        if ctx.Strategy == "" </span><span class="cov1" title="1">{
                // No strategy field, just remove any strategy references and keep as dotfiles_file
                return removeStrategyField(ctx.Lines), nil
        }</span>

        <span class="cov3" title="3">switch ctx.Strategy </span>{
        case "symlink":<span class="cov1" title="1">
                return convertToSymlinkResource(ctx)</span>
        case "copy":<span class="cov1" title="1">
                // Convert to dotfiles_file without strategy field
                return removeStrategyField(ctx.Lines), nil</span>
        case "template":<span class="cov1" title="1">
                return convertToTemplateFile(ctx)</span>
        default:<span class="cov0" title="0">
                // Unknown strategy, add comment and keep as dotfiles_file
                lines := removeStrategyField(ctx.Lines)
                lines[0] = "# MIGRATION NOTE: Unknown strategy '" + ctx.Strategy + "' converted to copy operation\n" + lines[0]
                return lines, nil</span>
        }
}

// removeStrategyField removes strategy field lines from the resource.
func removeStrategyField(lines []string) []string <span class="cov3" title="3">{
        var result []string
        for _, line := range lines </span><span class="cov8" title="20">{
                if !strategyFieldRegex.MatchString(line) </span><span class="cov8" title="18">{
                        result = append(result, line)
                }</span>
        }
        <span class="cov3" title="3">return result</span>
}

// convertToSymlinkResource converts dotfiles_file with strategy=symlink to dotfiles_symlink.
func convertToSymlinkResource(ctx *ResourceContext) ([]string, error) <span class="cov2" title="2">{
        var result []string

        // Add migration comment
        result = append(result, "# MIGRATED: dotfiles_file with strategy=symlink → dotfiles_symlink")

        for i, line := range ctx.Lines </span><span class="cov7" title="12">{
                if i == 0 </span><span class="cov2" title="2">{
                        // Replace resource type
                        line = strings.Replace(line, "dotfiles_file", "dotfiles_symlink", 1)
                }</span> else<span class="cov6" title="10"> if strategyFieldRegex.MatchString(line) </span><span class="cov2" title="2">{
                        // Skip strategy field
                        continue</span>
                }
                <span class="cov6" title="10">result = append(result, line)</span>
        }

        <span class="cov2" title="2">return result, nil</span>
}

// convertToTemplateFile converts dotfiles_file with strategy=template to dotfiles_file with is_template=true.
func convertToTemplateFile(ctx *ResourceContext) ([]string, error) <span class="cov1" title="1">{
        var result []string
        var hasIsTemplate bool

        // Add migration comment
        result = append(result, "# MIGRATED: strategy=template → is_template=true")

        for _, line := range ctx.Lines </span><span class="cov6" title="8">{
                if strategyFieldRegex.MatchString(line) </span><span class="cov1" title="1">{
                        // Replace strategy field with is_template
                        indentation := getIndentation(line)
                        result = append(result, indentation+"is_template = true")
                        continue</span>
                }

                <span class="cov5" title="7">if strings.Contains(line, "is_template") </span><span class="cov0" title="0">{
                        hasIsTemplate = true
                }</span>

                <span class="cov5" title="7">result = append(result, line)</span>
        }

        // If is_template wasn't already set, we've added it above
        <span class="cov1" title="1">if hasIsTemplate </span><span class="cov0" title="0">{
                // Add note that there might be a conflict
                result[1] = result[1] + " # NOTE: Check for is_template conflicts"
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// isResourceEnd checks if we've reached the end of a resource block.
func isResourceEnd(lines []string) bool <span class="cov4" title="4">{
        braceCount := 0
        for _, line := range lines </span><span class="cov9" title="31">{
                braceCount += strings.Count(line, "{") - strings.Count(line, "}")
        }</span>
        <span class="cov4" title="4">return braceCount == 0</span>
}

// getIndentation returns the indentation (whitespace) from the beginning of a line.
func getIndentation(line string) string <span class="cov1" title="1">{
        for i, char := range line </span><span class="cov3" title="3">{
                if char != ' ' &amp;&amp; char != '\t' </span><span class="cov1" title="1">{
                        return line[:i]
                }</span>
        }
        <span class="cov0" title="0">return line</span>
}

// Regular expressions for parsing Terraform configuration.
var (
        fileResourceRegex  = regexp.MustCompile(`resource\s+"dotfiles_file"\s+"([^"]+)"`)
        strategyFieldRegex = regexp.MustCompile(`\s*strategy\s*=\s*"([^"]*)"`)
)
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package platform

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

// DarwinProvider implements PlatformProvider for macOS.
type DarwinProvider struct {
        BasePlatform
}

// GetHomeDir returns the user's home directory.
func (p *DarwinProvider) GetHomeDir() (string, error) <span class="cov10" title="33">{
        return os.UserHomeDir()
}</span>

// GetConfigDir returns the user's config directory.
func (p *DarwinProvider) GetConfigDir() (string, error) <span class="cov6" title="8">{
        home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="8">return filepath.Join(home, ".config"), nil</span>
}

// GetAppSupportDir returns the user's Application Support directory.
func (p *DarwinProvider) GetAppSupportDir() (string, error) <span class="cov6" title="9">{
        home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="9">return filepath.Join(home, "Library", "Application Support"), nil</span>
}

// ResolvePath resolves a path to its absolute form.
func (p *DarwinProvider) ResolvePath(path string) (string, error) <span class="cov5" title="5">{
        return p.ExpandPath(path)
}</span>

// ExpandPath expands ~ and environment variables in the path.
func (p *DarwinProvider) ExpandPath(path string) (string, error) <span class="cov9" title="28">{
        if path == "" </span><span class="cov4" title="4">{
                return "", fmt.Errorf("empty path")
        }</span>

        // Handle ~ expansion
        <span class="cov9" title="24">if strings.HasPrefix(path, "~/") </span><span class="cov4" title="4">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov4" title="4">path = filepath.Join(home, path[2:])</span>
        } else<span class="cov8" title="20"> if path == "~" </span><span class="cov4" title="4">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov4" title="4">path = home</span>
        }

        // Expand environment variables
        <span class="cov9" title="24">path = os.ExpandEnv(path)

        // Convert to absolute path
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to convert to absolute path: %w", err)
        }</span>

        <span class="cov9" title="24">return absPath, nil</span>
}

// CreateSymlink creates a symbolic link.
func (p *DarwinProvider) CreateSymlink(source, target string) error <span class="cov2" title="2">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov2" title="2">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Check if source exists
        <span class="cov2" title="2">if _, err := os.Stat(expandedSource); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return fmt.Errorf("source file does not exist: %s", expandedSource)
        }</span>

        // Create parent directories for target
        <span class="cov1" title="1">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Remove existing target if it exists
        <span class="cov1" title="1">if _, err := os.Lstat(expandedTarget); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(expandedTarget); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove existing target: %w", err)
                }</span>
        }

        // Create the symlink
        <span class="cov1" title="1">if err := os.Symlink(expandedSource, expandedTarget); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create symlink: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CopyFile copies a file from source to target.
func (p *DarwinProvider) CopyFile(source, target string) error <span class="cov2" title="2">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov2" title="2">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Open source file
        <span class="cov2" title="2">sourceFile, err := os.Open(expandedSource)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("unable to open source file: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close source file: %v\n", err)
                }</span>
        }()

        // Get source file info
        <span class="cov1" title="1">sourceInfo, err := sourceFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get source file info: %w", err)
        }</span>

        // Create parent directories for target
        <span class="cov1" title="1">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Create target file
        <span class="cov1" title="1">targetFile, err := os.Create(expandedTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target file: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := targetFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close target file: %v\n", err)
                }</span>
        }()

        // Copy file contents
        <span class="cov1" title="1">if _, err := io.Copy(targetFile, sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to copy file contents: %w", err)
        }</span>

        // Copy permissions
        <span class="cov1" title="1">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to copy file permissions: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SetPermissions sets file permissions.
func (p *DarwinProvider) SetPermissions(path string, mode os.FileMode) error <span class="cov1" title="1">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand path: %w", err)
        }</span>

        <span class="cov1" title="1">if err := os.Chmod(expandedPath, mode); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("unable to set permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo returns file information.
func (p *DarwinProvider) GetFileInfo(path string) (os.FileInfo, error) <span class="cov1" title="1">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to expand path: %w", err)
        }</span>

        <span class="cov1" title="1">return os.Stat(expandedPath)</span>
}

// DetectApplication detects if an application is installed.
func (p *DarwinProvider) DetectApplication(name string) (*ApplicationInfo, error) <span class="cov4" title="4">{
        info := &amp;ApplicationInfo{
                Name:      name,
                Installed: false,
        }

        // Check common application locations
        var titleName string
        if len(name) &gt; 0 </span><span class="cov4" title="4">{
                titleName = strings.ToUpper(name[:1]) + name[1:]
        }</span>

        <span class="cov4" title="4">appPaths := []string{
                fmt.Sprintf("/Applications/%s.app", name),
                fmt.Sprintf("/Applications/%s.app", titleName),
                fmt.Sprintf("/System/Applications/%s.app", name),
                fmt.Sprintf("/System/Applications/%s.app", titleName),
        }

        for _, appPath := range appPaths </span><span class="cov8" title="16">{
                if _, err := os.Stat(appPath); err == nil </span><span class="cov0" title="0">{
                        info.Installed = true
                        info.InstallationPath = appPath
                        break</span>
                }
        }

        // Check if command exists in PATH
        <span class="cov4" title="4">if !info.Installed </span><span class="cov4" title="4">{
                if execPath, err := exec.LookPath(name); err == nil </span><span class="cov3" title="3">{
                        info.Installed = true
                        info.ExecutablePath = execPath
                }</span>
        }

        // Get application configuration paths if installed
        <span class="cov4" title="4">if info.Installed </span><span class="cov3" title="3">{
                configPaths, err := p.GetApplicationPaths(name)
                if err == nil </span><span class="cov3" title="3">{
                        if configPath, exists := configPaths["config"]; exists </span><span class="cov3" title="3">{
                                info.ConfigPaths = append(info.ConfigPaths, configPath)
                        }</span>
                        <span class="cov3" title="3">if dataPath, exists := configPaths["data"]; exists </span><span class="cov3" title="3">{
                                info.DataPaths = append(info.DataPaths, dataPath)
                        }</span>
                }
        }

        <span class="cov4" title="4">return info, nil</span>
}

// GetApplicationPaths returns application-specific paths.
func (p *DarwinProvider) GetApplicationPaths(name string) (map[string]string, error) <span class="cov5" title="6">{
        paths := make(map[string]string)

        home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">appSupport, err := p.GetAppSupportDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">config, err := p.GetConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Common application path patterns
        <span class="cov5" title="6">paths["config"] = filepath.Join(config, name)
        paths["data"] = filepath.Join(appSupport, name)
        paths["cache"] = filepath.Join(home, "Library", "Caches", name)
        paths["preferences"] = filepath.Join(home, "Library", "Preferences", fmt.Sprintf("com.%s.plist", name))

        // Special cases for known applications
        switch strings.ToLower(name) </span>{
        case "cursor":<span class="cov0" title="0">
                paths["config"] = filepath.Join(appSupport, "Cursor", "User")
                paths["data"] = filepath.Join(appSupport, "Cursor")</span>
        case "vscode":<span class="cov0" title="0">
                paths["config"] = filepath.Join(appSupport, "Code", "User")
                paths["data"] = filepath.Join(appSupport, "Code")</span>
        case "git":<span class="cov1" title="1">
                paths["config"] = filepath.Join(home, ".gitconfig")</span>
        case "ssh":<span class="cov1" title="1">
                paths["config"] = filepath.Join(home, ".ssh")</span>
        case "gpg":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".gnupg")</span>
        }

        <span class="cov5" title="6">return paths, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package platform

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

// LinuxProvider implements PlatformProvider for Linux.
type LinuxProvider struct {
        BasePlatform
}

// GetHomeDir returns the user's home directory.
func (p *LinuxProvider) GetHomeDir() (string, error) <span class="cov8" title="7">{
        return os.UserHomeDir()
}</span>

// GetConfigDir returns the user's config directory.
func (p *LinuxProvider) GetConfigDir() (string, error) <span class="cov1" title="1">{
        // Follow XDG Base Directory specification
        if configHome := os.Getenv("XDG_CONFIG_HOME"); configHome != "" </span><span class="cov0" title="0">{
                return configHome, nil
        }</span>

        <span class="cov1" title="1">home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(home, ".config"), nil</span>
}

// GetAppSupportDir returns the user's data directory.
func (p *LinuxProvider) GetAppSupportDir() (string, error) <span class="cov1" title="1">{
        // Follow XDG Base Directory specification
        if dataHome := os.Getenv("XDG_DATA_HOME"); dataHome != "" </span><span class="cov0" title="0">{
                return dataHome, nil
        }</span>

        <span class="cov1" title="1">home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(home, ".local", "share"), nil</span>
}

// ResolvePath resolves a path to its absolute form.
func (p *LinuxProvider) ResolvePath(path string) (string, error) <span class="cov7" title="5">{
        return p.ExpandPath(path)
}</span>

// ExpandPath expands ~ and environment variables in the path.
func (p *LinuxProvider) ExpandPath(path string) (string, error) <span class="cov10" title="10">{
        if path == "" </span><span class="cov3" title="2">{
                return "", fmt.Errorf("empty path")
        }</span>

        // Handle ~ expansion
        <span class="cov9" title="8">if strings.HasPrefix(path, "~/") </span><span class="cov3" title="2">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov3" title="2">path = filepath.Join(home, path[2:])</span>
        } else<span class="cov8" title="6"> if path == "~" </span><span class="cov3" title="2">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov3" title="2">path = home</span>
        }

        // Expand environment variables
        <span class="cov9" title="8">path = os.ExpandEnv(path)

        // Convert to absolute path
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to convert to absolute path: %w", err)
        }</span>

        <span class="cov9" title="8">return absPath, nil</span>
}

// CreateSymlink creates a symbolic link.
func (p *LinuxProvider) CreateSymlink(source, target string) error <span class="cov0" title="0">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov0" title="0">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Check if source exists
        <span class="cov0" title="0">if _, err := os.Stat(expandedSource); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("source file does not exist: %s", expandedSource)
        }</span>

        // Create parent directories for target
        <span class="cov0" title="0">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Remove existing target if it exists
        <span class="cov0" title="0">if _, err := os.Lstat(expandedTarget); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(expandedTarget); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove existing target: %w", err)
                }</span>
        }

        // Create the symlink
        <span class="cov0" title="0">if err := os.Symlink(expandedSource, expandedTarget); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create symlink: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file from source to target.
func (p *LinuxProvider) CopyFile(source, target string) error <span class="cov0" title="0">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov0" title="0">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Open source file
        <span class="cov0" title="0">sourceFile, err := os.Open(expandedSource)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close source file: %v\n", err)
                }</span>
        }()

        // Get source file info
        <span class="cov0" title="0">sourceInfo, err := sourceFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get source file info: %w", err)
        }</span>

        // Create parent directories for target
        <span class="cov0" title="0">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Create target file
        <span class="cov0" title="0">targetFile, err := os.Create(expandedTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := targetFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close target file: %v\n", err)
                }</span>
        }()

        // Copy file contents
        <span class="cov0" title="0">if _, err := io.Copy(targetFile, sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to copy file contents: %w", err)
        }</span>

        // Copy permissions
        <span class="cov0" title="0">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to copy file permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetPermissions sets file permissions.
func (p *LinuxProvider) SetPermissions(path string, mode os.FileMode) error <span class="cov0" title="0">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand path: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.Chmod(expandedPath, mode); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo returns file information.
func (p *LinuxProvider) GetFileInfo(path string) (os.FileInfo, error) <span class="cov0" title="0">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to expand path: %w", err)
        }</span>

        <span class="cov0" title="0">return os.Stat(expandedPath)</span>
}

// DetectApplication detects if an application is installed.
func (p *LinuxProvider) DetectApplication(name string) (*ApplicationInfo, error) <span class="cov0" title="0">{
        info := &amp;ApplicationInfo{
                Name:      name,
                Installed: false,
        }

        // Check if command exists in PATH
        if execPath, err := exec.LookPath(name); err == nil </span><span class="cov0" title="0">{
                info.Installed = true
                info.ExecutablePath = execPath
        }</span>

        // Check common application installation directories
        <span class="cov0" title="0">if !info.Installed </span><span class="cov0" title="0">{
                appPaths := []string{
                        fmt.Sprintf("/usr/bin/%s", name),
                        fmt.Sprintf("/usr/local/bin/%s", name),
                        fmt.Sprintf("/bin/%s", name),
                        fmt.Sprintf("/sbin/%s", name),
                        fmt.Sprintf("/snap/bin/%s", name),
                        fmt.Sprintf("/var/lib/flatpak/exports/bin/%s", name),
                }

                for _, appPath := range appPaths </span><span class="cov0" title="0">{
                        if _, err := os.Stat(appPath); err == nil </span><span class="cov0" title="0">{
                                info.Installed = true
                                info.ExecutablePath = appPath
                                break</span>
                        }
                }
        }

        // Get application configuration paths if installed
        <span class="cov0" title="0">if info.Installed </span><span class="cov0" title="0">{
                configPaths, err := p.GetApplicationPaths(name)
                if err == nil </span><span class="cov0" title="0">{
                        if configPath, exists := configPaths["config"]; exists </span><span class="cov0" title="0">{
                                info.ConfigPaths = append(info.ConfigPaths, configPath)
                        }</span>
                        <span class="cov0" title="0">if dataPath, exists := configPaths["data"]; exists </span><span class="cov0" title="0">{
                                info.DataPaths = append(info.DataPaths, dataPath)
                        }</span>
                }
        }

        <span class="cov0" title="0">return info, nil</span>
}

// GetApplicationPaths returns application-specific paths.
func (p *LinuxProvider) GetApplicationPaths(name string) (map[string]string, error) <span class="cov0" title="0">{
        paths := make(map[string]string)

        home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config, err := p.GetConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data, err := p.GetAppSupportDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // XDG Cache directory
        <span class="cov0" title="0">cacheDir := os.Getenv("XDG_CACHE_HOME")
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = filepath.Join(home, ".cache")
        }</span>

        // Common application path patterns
        <span class="cov0" title="0">paths["config"] = filepath.Join(config, name)
        paths["data"] = filepath.Join(data, name)
        paths["cache"] = filepath.Join(cacheDir, name)

        // Special cases for known applications
        switch strings.ToLower(name) </span>{
        case "cursor":<span class="cov0" title="0">
                paths["config"] = filepath.Join(config, "Cursor", "User")
                paths["data"] = filepath.Join(data, "Cursor")</span>
        case "code", "vscode":<span class="cov0" title="0">
                paths["config"] = filepath.Join(config, "Code", "User")
                paths["data"] = filepath.Join(data, "Code")</span>
        case "git":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".gitconfig")</span>
        case "ssh":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".ssh")</span>
        case "gpg":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".gnupg")</span>
        case "fish":<span class="cov0" title="0">
                paths["config"] = filepath.Join(config, "fish")</span>
        case "zsh":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".zshrc")</span>
        case "bash":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".bashrc")</span>
        case "vim":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".vimrc")</span>
        case "nvim", "neovim":<span class="cov0" title="0">
                paths["config"] = filepath.Join(config, "nvim")</span>
        }

        <span class="cov0" title="0">return paths, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package platform

import (
        "os"
        "runtime"
)

// PlatformProvider defines the interface for platform-specific operations.
type PlatformProvider interface {
        // Platform information
        GetPlatform() string
        GetArchitecture() string

        // Directory operations
        GetHomeDir() (string, error)
        GetConfigDir() (string, error)
        GetAppSupportDir() (string, error)

        // Path operations
        ResolvePath(path string) (string, error)
        ExpandPath(path string) (string, error)
        GetPathSeparator() string

        // File operations
        CreateSymlink(source, target string) error
        CopyFile(source, target string) error
        SetPermissions(path string, mode os.FileMode) error
        GetFileInfo(path string) (os.FileInfo, error)

        // Application detection
        DetectApplication(name string) (*ApplicationInfo, error)
        GetApplicationPaths(name string) (map[string]string, error)
}

// ApplicationInfo represents information about an installed application.
type ApplicationInfo struct {
        Name             string
        Installed        bool
        Version          string
        InstallationPath string
        ExecutablePath   string
        ConfigPaths      []string
        DataPaths        []string
}

// BasePlatform provides common functionality for all platforms.
type BasePlatform struct {
        platform     string
        architecture string
}

// GetPlatform returns the platform name.
func (p *BasePlatform) GetPlatform() string <span class="cov10" title="16">{
        return p.platform
}</span>

// GetArchitecture returns the architecture.
func (p *BasePlatform) GetArchitecture() string <span class="cov5" title="4">{
        return p.architecture
}</span>

// GetPathSeparator returns the path separator for the platform.
func (p *BasePlatform) GetPathSeparator() string <span class="cov5" title="4">{
        if p.platform == "windows" </span><span class="cov1" title="1">{
                return ";"
        }</span>
        <span class="cov4" title="3">return ":"</span>
}

// DetectPlatform detects and returns the appropriate platform provider.
func DetectPlatform() PlatformProvider <span class="cov7" title="8">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov7" title="8">
                return &amp;DarwinProvider{BasePlatform{platform: "macos", architecture: runtime.GOARCH}}</span>
        case "linux":<span class="cov0" title="0">
                return &amp;LinuxProvider{BasePlatform{platform: "linux", architecture: runtime.GOARCH}}</span>
        case "windows":<span class="cov0" title="0">
                return &amp;WindowsProvider{BasePlatform{platform: "windows", architecture: runtime.GOARCH}}</span>
        default:<span class="cov0" title="0">
                // Fallback to Linux provider for unknown platforms
                return &amp;LinuxProvider{BasePlatform{platform: runtime.GOOS, architecture: runtime.GOARCH}}</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package platform

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

// WindowsProvider implements PlatformProvider for Windows.
type WindowsProvider struct {
        BasePlatform
}

// GetHomeDir returns the user's home directory.
func (p *WindowsProvider) GetHomeDir() (string, error) <span class="cov9" title="8">{
        return os.UserHomeDir()
}</span>

// GetConfigDir returns the user's config directory.
func (p *WindowsProvider) GetConfigDir() (string, error) <span class="cov5" title="3">{
        appData := os.Getenv("APPDATA")
        if appData != "" </span><span class="cov0" title="0">{
                return appData, nil
        }</span>

        <span class="cov5" title="3">home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">return filepath.Join(home, "AppData", "Roaming"), nil</span>
}

// GetAppSupportDir returns the user's application data directory.
func (p *WindowsProvider) GetAppSupportDir() (string, error) <span class="cov1" title="1">{
        return p.GetConfigDir() // Same as config on Windows
}</span>

// ResolvePath resolves a path to its absolute form.
func (p *WindowsProvider) ResolvePath(path string) (string, error) <span class="cov7" title="5">{
        return p.ExpandPath(path)
}</span>

// ExpandPath expands ~ and environment variables in the path.
func (p *WindowsProvider) ExpandPath(path string) (string, error) <span class="cov10" title="10">{
        if path == "" </span><span class="cov3" title="2">{
                return "", fmt.Errorf("empty path")
        }</span>

        // Handle ~ expansion
        <span class="cov9" title="8">if strings.HasPrefix(path, "~/") || strings.HasPrefix(path, "~\\") </span><span class="cov3" title="2">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov3" title="2">path = filepath.Join(home, path[2:])</span>
        } else<span class="cov8" title="6"> if path == "~" </span><span class="cov3" title="2">{
                home, err := p.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov3" title="2">path = home</span>
        }

        // Expand environment variables
        <span class="cov9" title="8">path = os.ExpandEnv(path)

        // Convert to absolute path and normalize separators
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to convert to absolute path: %w", err)
        }</span>

        <span class="cov9" title="8">return filepath.FromSlash(absPath), nil</span>
}

// CreateSymlink creates a symbolic link (requires elevated privileges on Windows).
func (p *WindowsProvider) CreateSymlink(source, target string) error <span class="cov0" title="0">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov0" title="0">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Check if source exists
        <span class="cov0" title="0">sourceInfo, err := os.Stat(expandedSource)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("source file does not exist: %s", expandedSource)
        }</span>

        // Create parent directories for target
        <span class="cov0" title="0">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Remove existing target if it exists
        <span class="cov0" title="0">if _, err := os.Lstat(expandedTarget); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(expandedTarget); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove existing target: %w", err)
                }</span>
        }

        // Create the symlink
        // Note: This requires developer mode or elevated privileges on Windows
        <span class="cov0" title="0">if err := os.Symlink(expandedSource, expandedTarget); err != nil </span><span class="cov0" title="0">{
                // If symlink fails, fall back to copying (for Windows compatibility)
                fmt.Printf("Warning: Symlink creation failed, falling back to copy: %v\n", err)
                return p.CopyFile(source, target)
        }</span>

        // For directories, we may need to handle differently on Windows
        <span class="cov0" title="0">if sourceInfo.IsDir() </span><span class="cov0" title="0">{
                // Directory symlinks work differently on Windows
                // For now, we use the same approach as files
                // TODO: Implement directory-specific symlink handling for Windows
                return nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file from source to target.
func (p *WindowsProvider) CopyFile(source, target string) error <span class="cov0" title="0">{
        // Expand paths
        expandedSource, err := p.ExpandPath(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand source path: %w", err)
        }</span>

        <span class="cov0" title="0">expandedTarget, err := p.ExpandPath(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand target path: %w", err)
        }</span>

        // Open source file
        <span class="cov0" title="0">sourceFile, err := os.Open(expandedSource)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close source file: %v\n", err)
                }</span>
        }()

        // Get source file info
        <span class="cov0" title="0">sourceInfo, err := sourceFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get source file info: %w", err)
        }</span>

        // Create parent directories for target
        <span class="cov0" title="0">targetDir := filepath.Dir(expandedTarget)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target directory: %w", err)
        }</span>

        // Create target file
        <span class="cov0" title="0">targetFile, err := os.Create(expandedTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create target file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := targetFile.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Warning: failed to close target file: %v\n", err)
                }</span>
        }()

        // Copy file contents
        <span class="cov0" title="0">if _, err := io.Copy(targetFile, sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to copy file contents: %w", err)
        }</span>

        // Copy permissions (simplified for Windows)
        <span class="cov0" title="0">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                // Windows permission handling is different, so we'll log but not fail
                fmt.Printf("Warning: Unable to copy file permissions on Windows: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetPermissions sets file permissions (simplified for Windows).
func (p *WindowsProvider) SetPermissions(path string, mode os.FileMode) error <span class="cov0" title="0">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to expand path: %w", err)
        }</span>

        // Windows doesn't have the same permission model as Unix
        // This is a simplified implementation
        <span class="cov0" title="0">if err := os.Chmod(expandedPath, mode); err != nil </span><span class="cov0" title="0">{
                // Don't fail on Windows permission errors, just warn
                fmt.Printf("Warning: Unable to set permissions on Windows: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo returns file information.
func (p *WindowsProvider) GetFileInfo(path string) (os.FileInfo, error) <span class="cov0" title="0">{
        expandedPath, err := p.ExpandPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to expand path: %w", err)
        }</span>

        <span class="cov0" title="0">return os.Stat(expandedPath)</span>
}

// DetectApplication detects if an application is installed.
func (p *WindowsProvider) DetectApplication(name string) (*ApplicationInfo, error) <span class="cov0" title="0">{
        info := &amp;ApplicationInfo{
                Name:      name,
                Installed: false,
        }

        // Check if command exists in PATH
        if execPath, err := exec.LookPath(name + ".exe"); err == nil </span><span class="cov0" title="0">{
                info.Installed = true
                info.ExecutablePath = execPath
        }</span> else<span class="cov0" title="0"> if execPath, err := exec.LookPath(name); err == nil </span><span class="cov0" title="0">{
                info.Installed = true
                info.ExecutablePath = execPath
        }</span>

        // Check common Windows application directories
        <span class="cov0" title="0">if !info.Installed </span><span class="cov0" title="0">{
                programFiles := os.Getenv("PROGRAMFILES")
                programFilesX86 := os.Getenv("PROGRAMFILES(X86)")

                var titleName string
                if len(name) &gt; 0 </span><span class="cov0" title="0">{
                        titleName = strings.ToUpper(name[:1]) + name[1:]
                }</span>

                <span class="cov0" title="0">checkPaths := []string{}
                if programFiles != "" </span><span class="cov0" title="0">{
                        checkPaths = append(checkPaths,
                                filepath.Join(programFiles, name),
                                filepath.Join(programFiles, titleName),
                        )
                }</span>
                <span class="cov0" title="0">if programFilesX86 != "" </span><span class="cov0" title="0">{
                        checkPaths = append(checkPaths,
                                filepath.Join(programFilesX86, name),
                                filepath.Join(programFilesX86, titleName),
                        )
                }</span>

                <span class="cov0" title="0">for _, appPath := range checkPaths </span><span class="cov0" title="0">{
                        if _, err := os.Stat(appPath); err == nil </span><span class="cov0" title="0">{
                                info.Installed = true
                                info.InstallationPath = appPath
                                break</span>
                        }
                }
        }

        // Get application configuration paths if installed
        <span class="cov0" title="0">if info.Installed </span><span class="cov0" title="0">{
                configPaths, err := p.GetApplicationPaths(name)
                if err == nil </span><span class="cov0" title="0">{
                        if configPath, exists := configPaths["config"]; exists </span><span class="cov0" title="0">{
                                info.ConfigPaths = append(info.ConfigPaths, configPath)
                        }</span>
                        <span class="cov0" title="0">if dataPath, exists := configPaths["data"]; exists </span><span class="cov0" title="0">{
                                info.DataPaths = append(info.DataPaths, dataPath)
                        }</span>
                }
        }

        <span class="cov0" title="0">return info, nil</span>
}

// GetApplicationPaths returns application-specific paths.
func (p *WindowsProvider) GetApplicationPaths(name string) (map[string]string, error) <span class="cov0" title="0">{
        paths := make(map[string]string)

        home, err := p.GetHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">appData, err := p.GetConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">localAppData := os.Getenv("LOCALAPPDATA")
        if localAppData == "" </span><span class="cov0" title="0">{
                localAppData = filepath.Join(home, "AppData", "Local")
        }</span>

        // Common application path patterns
        <span class="cov0" title="0">paths["config"] = filepath.Join(appData, name)
        paths["data"] = filepath.Join(localAppData, name)
        paths["cache"] = filepath.Join(localAppData, name, "Cache")

        // Special cases for known applications
        switch strings.ToLower(name) </span>{
        case "cursor":<span class="cov0" title="0">
                paths["config"] = filepath.Join(appData, "Cursor", "User")
                paths["data"] = filepath.Join(localAppData, "Cursor")</span>
        case "code", "vscode":<span class="cov0" title="0">
                paths["config"] = filepath.Join(appData, "Code", "User")
                paths["data"] = filepath.Join(localAppData, "Code")</span>
        case "git":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".gitconfig")</span>
        case "ssh":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, ".ssh")</span>
        case "gpg":<span class="cov0" title="0">
                paths["config"] = filepath.Join(appData, "gnupg")</span>
        case "powershell":<span class="cov0" title="0">
                paths["config"] = filepath.Join(home, "Documents", "PowerShell")</span>
        }

        <span class="cov0" title="0">return paths, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;ApplicationResource{}

// NewApplicationResource creates a new application resource.
func NewApplicationResource() resource.Resource <span class="cov5" title="4">{
        return &amp;ApplicationResource{}
}</span>

// ApplicationResource defines the application resource implementation.
// This resource manages configuration files for applications, NOT application installation.
// Application installation should be handled by the terraform-provider-package.
type ApplicationResource struct {
        client *DotfilesClient
}

// ApplicationResourceModel describes the application resource data model.
type ApplicationResourceModel struct {
        ID              types.String `tfsdk:"id"`
        ApplicationName types.String `tfsdk:"application_name"`
        ConfigMappings  types.Map    `tfsdk:"config_mappings"`

        // Computed attributes
        ConfiguredFiles types.List   `tfsdk:"configured_files"`
        LastUpdated     types.String `tfsdk:"last_updated"`
}

// ConfigMappingValue represents a single configuration mapping.
type ConfigMappingValue struct {
        TargetPath types.String `tfsdk:"target_path"`
        Strategy   types.String `tfsdk:"strategy"`
}

// Metadata sets the resource type name.
func (r *ApplicationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_application"
}</span>

// Schema defines the resource schema.
func (r *ApplicationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages application-specific configuration files. This resource focuses solely on configuration file management - application installation should be handled by terraform-provider-package.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Application configuration resource identifier",
                        },
                        "application_name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Name of the application (used for organization and templating)",
                        },
                        "config_mappings": schema.MapNestedAttribute{
                                Optional:            true,
                                Computed:            true,
                                MarkdownDescription: "Map of source files to target configuration mappings",
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "target_path": schema.StringAttribute{
                                                        Required:            true,
                                                        MarkdownDescription: "Target path where the configuration file should be placed",
                                                },
                                                "strategy": schema.StringAttribute{
                                                        Optional:            true,
                                                        Computed:            true,
                                                        Default:             stringdefault.StaticString("symlink"),
                                                        MarkdownDescription: "Deployment strategy: 'symlink' or 'copy'",
                                                },
                                        },
                                },
                        },
                        "configured_files": schema.ListAttribute{
                                ElementType:         types.StringType,
                                Computed:            true,
                                MarkdownDescription: "List of configuration files that were successfully configured",
                        },
                        "last_updated": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Timestamp when the configuration was last updated",
                        },
                },
        }
}</span>

// Configure sets up the resource with the provider client.
func (r *ApplicationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov3" title="2">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *DotfilesClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>

        <span class="cov1" title="1">r.client = client</span>
}

// Create handles resource creation.
func (r *ApplicationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Generate resource ID
        <span class="cov0" title="0">data.ID = types.StringValue(fmt.Sprintf("app-%s-%d", data.ApplicationName.ValueString(), time.Now().Unix()))

        tflog.Info(ctx, "Creating application configuration", map[string]interface{}{
                "application": data.ApplicationName.ValueString(),
                "id":          data.ID.ValueString(),
        })

        // Deploy configuration files
        configuredFiles, err := r.deployApplicationConfig(ctx, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Configuration Deployment Failed",
                        fmt.Sprintf("Failed to deploy configuration for application %s: %s", data.ApplicationName.ValueString(), err.Error()),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">data.ConfiguredFiles = configuredFiles
        data.LastUpdated = types.StringValue(time.Now().Format(time.RFC3339))

        tflog.Info(ctx, "Application configuration created successfully", map[string]interface{}{
                "application":      data.ApplicationName.ValueString(),
                "configured_files": len(configuredFiles.Elements()),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

// Read handles resource reading.
func (r *ApplicationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading application configuration", map[string]interface{}{
                "application": data.ApplicationName.ValueString(),
                "id":          data.ID.ValueString(),
        })

        // Verify configuration files still exist and are properly configured
        err := r.verifyConfigurationFiles(ctx, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Warn(ctx, "Configuration verification failed", map[string]interface{}{
                        "application": data.ApplicationName.ValueString(),
                        "error":       err.Error(),
                })
                // Don't fail the read, just log the warning
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

// Update handles resource updates.
func (r *ApplicationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Updating application configuration", map[string]interface{}{
                "application": data.ApplicationName.ValueString(),
                "id":          data.ID.ValueString(),
        })

        // Redeploy configuration files
        configuredFiles, err := r.deployApplicationConfig(ctx, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Configuration Update Failed",
                        fmt.Sprintf("Failed to update configuration for application %s: %s", data.ApplicationName.ValueString(), err.Error()),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">data.ConfiguredFiles = configuredFiles
        data.LastUpdated = types.StringValue(time.Now().Format(time.RFC3339))

        tflog.Info(ctx, "Application configuration updated successfully", map[string]interface{}{
                "application":      data.ApplicationName.ValueString(),
                "configured_files": len(configuredFiles.Elements()),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

// Delete handles resource deletion.
func (r *ApplicationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Deleting application configuration", map[string]interface{}{
                "application": data.ApplicationName.ValueString(),
                "id":          data.ID.ValueString(),
        })

        // Remove configured files (symlinks/copies)
        err := r.removeApplicationConfig(ctx, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Configuration Removal Failed",
                        fmt.Sprintf("Failed to remove configuration for application %s: %s", data.ApplicationName.ValueString(), err.Error()),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Application configuration deleted successfully", map[string]interface{}{
                "application": data.ApplicationName.ValueString(),
        })</span>
}

// deployApplicationConfig deploys configuration files according to the mappings.
func (r *ApplicationResource) deployApplicationConfig(ctx context.Context, data *ApplicationResourceModel) (types.List, error) <span class="cov0" title="0">{
        var configuredFiles []string

        configMappings := data.ConfigMappings.Elements()
        for sourceFile, mappingValue := range configMappings </span><span class="cov0" title="0">{
                // Extract the mapping configuration
                mappingObj := mappingValue.(types.Object)
                mappingAttrs := mappingObj.Attributes()

                targetPath := mappingAttrs["target_path"].(types.String).ValueString()
                strategy := mappingAttrs["strategy"].(types.String).ValueString()

                // Expand target path template variables
                expandedTargetPath, err := r.expandTargetPathTemplate(targetPath, data.ApplicationName.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        return types.ListNull(types.StringType), fmt.Errorf("failed to expand target path template for %s: %w", sourceFile, err)
                }</span>

                // Get source path from dotfiles root
                <span class="cov0" title="0">sourcePath := filepath.Join(r.client.Config.DotfilesRoot, sourceFile)

                // Check if source file exists
                if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Source configuration file does not exist", map[string]interface{}{
                                "source_file": sourcePath,
                                "application": data.ApplicationName.ValueString(),
                        })
                        continue</span>
                }

                // Deploy based on strategy
                <span class="cov0" title="0">switch strategy </span>{
                case "symlink":<span class="cov0" title="0">
                        err = r.createSymlinkForConfig(ctx, sourcePath, expandedTargetPath)</span>
                case "copy":<span class="cov0" title="0">
                        err = r.copyConfigFile(ctx, sourcePath, expandedTargetPath)</span>
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("unsupported strategy: %s", strategy)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return types.ListNull(types.StringType), fmt.Errorf("failed to deploy %s using %s strategy: %w", sourceFile, strategy, err)
                }</span>

                <span class="cov0" title="0">configuredFiles = append(configuredFiles, expandedTargetPath)
                tflog.Debug(ctx, "Configuration file deployed", map[string]interface{}{
                        "source":   sourcePath,
                        "target":   expandedTargetPath,
                        "strategy": strategy,
                })</span>
        }

        // Convert to Terraform list type
        <span class="cov0" title="0">configuredFilesList, _ := types.ListValueFrom(ctx, types.StringType, configuredFiles)
        return configuredFilesList, nil</span>
}

// expandTargetPathTemplate expands template variables in target paths.
func (r *ApplicationResource) expandTargetPathTemplate(targetPath, applicationName string) (string, error) <span class="cov5" title="4">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        // Template variables
        <span class="cov5" title="4">replacements := map[string]string{
                "{{.home_dir}}":        homeDir,
                "{{.config_dir}}":      filepath.Join(homeDir, ".config"),
                "{{.app_support_dir}}": filepath.Join(homeDir, "Library", "Application Support"),
                "{{.application}}":     applicationName,
        }

        expandedPath := targetPath
        for template, replacement := range replacements </span><span class="cov10" title="16">{
                expandedPath = strings.ReplaceAll(expandedPath, template, replacement)
        }</span>

        // Handle tilde expansion
        <span class="cov5" title="4">if strings.HasPrefix(expandedPath, "~/") </span><span class="cov1" title="1">{
                expandedPath = filepath.Join(homeDir, expandedPath[2:])
        }</span>

        <span class="cov5" title="4">return expandedPath, nil</span>
}

// createSymlinkForConfig creates a symlink for a configuration file.
func (r *ApplicationResource) createSymlinkForConfig(ctx context.Context, sourcePath, targetPath string) error <span class="cov1" title="1">{
        // Create target directory if it doesn't exist
        targetDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory %s: %w", targetDir, err)
        }</span>

        // Remove existing file/symlink if it exists
        <span class="cov1" title="1">if _, err := os.Lstat(targetPath); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(targetPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing file %s: %w", targetPath, err)
                }</span>
        }

        // Create symlink
        <span class="cov1" title="1">if err := os.Symlink(sourcePath, targetPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create symlink from %s to %s: %w", sourcePath, targetPath, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// copyConfigFile copies a configuration file to the target location.
func (r *ApplicationResource) copyConfigFile(ctx context.Context, sourcePath, targetPath string) error <span class="cov1" title="1">{
        // Create target directory if it doesn't exist
        targetDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory %s: %w", targetDir, err)
        }</span>

        // Open source file
        <span class="cov1" title="1">sourceFile, err := os.Open(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", sourcePath, err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to close source file", map[string]interface{}{
                                "file":  sourcePath,
                                "error": err.Error(),
                        })
                }</span>
        }()

        // Create target file
        <span class="cov1" title="1">targetFile, err := os.Create(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target file %s: %w", targetPath, err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := targetFile.Close(); err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to close target file", map[string]interface{}{
                                "file":  targetPath,
                                "error": err.Error(),
                        })
                }</span>
        }()

        // Copy file contents
        <span class="cov1" title="1">if _, err := sourceFile.WriteTo(targetFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file contents from %s to %s: %w", sourcePath, targetPath, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// verifyConfigurationFiles verifies that configuration files are still properly configured.
func (r *ApplicationResource) verifyConfigurationFiles(ctx context.Context, data *ApplicationResourceModel) error <span class="cov0" title="0">{
        configuredFiles := data.ConfiguredFiles.Elements()

        for _, fileValue := range configuredFiles </span><span class="cov0" title="0">{
                filePath := fileValue.(types.String).ValueString()

                // Check if file still exists
                if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("configuration file %s no longer exists", filePath)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// removeApplicationConfig removes all configured files for the application.
func (r *ApplicationResource) removeApplicationConfig(ctx context.Context, data *ApplicationResourceModel) error <span class="cov0" title="0">{
        configuredFiles := data.ConfiguredFiles.Elements()

        for _, fileValue := range configuredFiles </span><span class="cov0" title="0">{
                filePath := fileValue.(types.String).ValueString()

                // Check if file exists before trying to remove
                if _, err := os.Lstat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span> // File doesn't exist, skip
                }

                // Remove file/symlink
                <span class="cov0" title="0">if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to remove configuration file", map[string]interface{}{
                                "file":  filePath,
                                "error": err.Error(),
                        })
                        // Continue with other files even if one fails
                }</span> else<span class="cov0" title="0"> {
                        tflog.Debug(ctx, "Removed configuration file", map[string]interface{}{
                                "file": filePath,
                        })
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/services"
)

// DotfilesClient provides the client interface for dotfiles operations.
type DotfilesClient struct {
        Config       *DotfilesConfig
        Platform     string
        Architecture string
        HomeDir      string
        ConfigDir    string

        // Services
        Services *services.ServiceRegistry

        // Concurrency management
        ConcurrencyManager *services.ConcurrencyManager
}

// NewDotfilesClient creates a new dotfiles client with the provided configuration.
func NewDotfilesClient(config *DotfilesConfig) (*DotfilesClient, error) <span class="cov8" title="7">{
        client := &amp;DotfilesClient{
                Config:       config,
                Architecture: runtime.GOARCH,
        }

        // Determine platform
        if config.AutoDetectPlatform || config.TargetPlatform == "auto" </span><span class="cov7" title="6">{
                client.Platform = detectPlatform()
        }</span> else<span class="cov1" title="1"> {
                client.Platform = config.TargetPlatform
        }</span>

        // Get home directory
        <span class="cov8" title="7">homeDir, err := getHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to determine home directory: %w", err)
        }</span>
        <span class="cov8" title="7">client.HomeDir = homeDir

        // Get config directory
        client.ConfigDir = getConfigDir(client.Platform, homeDir)

        // Initialize concurrency manager
        client.ConcurrencyManager = services.NewConcurrencyManager(DefaultMaxConcurrency)

        // Initialize services
        serviceConfig := services.ServiceConfig{
                DryRun: config.DryRun,
                PlatformProvider: &amp;ClientPlatformProvider{
                        client: client,
                },
        }
        client.Services = services.NewServiceRegistry(serviceConfig)

        return client, nil</span>
}

// detectPlatform detects the current platform.
func detectPlatform() string <span class="cov8" title="8">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="8">
                return "macos"</span>
        case "linux":<span class="cov0" title="0">
                return "linux"</span>
        case "windows":<span class="cov0" title="0">
                return "windows"</span>
        default:<span class="cov0" title="0">
                return runtime.GOOS</span>
        }
}

// getHomeDir returns the user's home directory.
func getHomeDir() (string, error) <span class="cov8" title="8">{
        // This is a placeholder - will be replaced with platform-specific implementation
        // For now, use the OS package
        return os.UserHomeDir()
}</span>

// getConfigDir returns the user's config directory based on platform.
func getConfigDir(platform, homeDir string) string <span class="cov10" title="11">{
        switch platform </span>{
        case "macos", "linux":<span class="cov9" title="9">
                return filepath.Join(homeDir, ".config")</span>
        case "windows":<span class="cov3" title="2">
                appData := os.Getenv("APPDATA")
                if appData != "" </span><span class="cov1" title="1">{
                        return appData
                }</span>
                <span class="cov1" title="1">return filepath.Join(homeDir, "AppData", "Roaming")</span>
        default:<span class="cov0" title="0">
                return filepath.Join(homeDir, ".config")</span>
        }
}

// GetPlatformInfo returns platform information.
func (c *DotfilesClient) GetPlatformInfo() map[string]interface{} <span class="cov5" title="3">{
        return map[string]interface{}{
                "platform":     c.Platform,
                "architecture": c.Architecture,
                "home_dir":     c.HomeDir,
                "config_dir":   c.ConfigDir,
        }
}</span>

// ClientPlatformProvider implements the platform provider interfaces for services.
type ClientPlatformProvider struct {
        client *DotfilesClient
}

// CopyFile implements services.PlatformProvider.CopyFile.
func (p *ClientPlatformProvider) CopyFile(src, dst string, mode os.FileMode) error <span class="cov0" title="0">{
        // Implementation would use platform-specific file operations
        return nil
}</span>

// CreateDirectory implements services.PlatformProvider.CreateDirectory.
func (p *ClientPlatformProvider) CreateDirectory(path string, mode os.FileMode) error <span class="cov0" title="0">{
        return os.MkdirAll(path, mode)
}</span>

// GetFileInfo implements services.PlatformProvider.GetFileInfo.
func (p *ClientPlatformProvider) GetFileInfo(path string) (os.FileInfo, error) <span class="cov0" title="0">{
        return os.Stat(path)
}</span>

// CalculateChecksum implements services.PlatformProvider.CalculateChecksum.
func (p *ClientPlatformProvider) CalculateChecksum(path string) (string, error) <span class="cov0" title="0">{
        // Implementation would calculate file checksum
        return "", nil
}</span>

// ReadFile implements services.TemplatePlatformProvider.ReadFile.
func (p *ClientPlatformProvider) ReadFile(path string) ([]byte, error) <span class="cov0" title="0">{
        return os.ReadFile(path)
}</span>

// WriteFile implements services.TemplatePlatformProvider.WriteFile.
func (p *ClientPlatformProvider) WriteFile(path string, content []byte, mode uint32) error <span class="cov0" title="0">{
        return os.WriteFile(path, content, os.FileMode(mode))
}</span>

// GetPlatformInfo implements services.TemplatePlatformProvider.GetPlatformInfo.
func (p *ClientPlatformProvider) GetPlatformInfo() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "platform":     p.client.Platform,
                "architecture": p.client.Architecture,
                "home_dir":     p.client.HomeDir,
                "config_dir":   p.client.ConfigDir,
        }
}</span>

// ExpandPath implements services.TemplatePlatformProvider.ExpandPath.
func (p *ClientPlatformProvider) ExpandPath(path string) (string, error) <span class="cov0" title="0">{
        if filepath.IsAbs(path) </span><span class="cov0" title="0">{
                return path, nil
        }</span>

        // Handle tilde expansion
        <span class="cov0" title="0">if len(path) &gt; 0 &amp;&amp; path[0] == '~' </span><span class="cov0" title="0">{
                return filepath.Join(p.client.HomeDir, path[1:]), nil
        }</span>

        <span class="cov0" title="0">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// DotfilesConfig holds the provider configuration.
type DotfilesConfig struct {
        DotfilesRoot       string
        BackupEnabled      bool
        BackupDirectory    string
        Strategy           string
        ConflictResolution string
        DryRun             bool
        AutoDetectPlatform bool
        TargetPlatform     string
        TemplateEngine     string
        LogLevel           string
}

// SetDefaults sets default values for the provider configuration.
func (c *DotfilesConfig) SetDefaults() error <span class="cov5" title="17">{
        // Set default dotfiles root
        if c.DotfilesRoot == "" </span><span class="cov2" title="3">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get user home directory for dotfiles_root: %w", err)
                }</span>
                <span class="cov2" title="3">c.DotfilesRoot = filepath.Join(homeDir, "dotfiles")</span>
        }

        // Set default backup directory
        <span class="cov5" title="17">if c.BackupDirectory == "" </span><span class="cov4" title="14">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get user home directory for backup_directory: %w", err)
                }</span>
                <span class="cov4" title="14">c.BackupDirectory = filepath.Join(homeDir, ".dotfiles-backups")</span>
        }

        // Set other defaults
        <span class="cov5" title="17">if c.Strategy == "" </span><span class="cov5" title="15">{
                c.Strategy = DefaultStrategy
        }</span>
        <span class="cov5" title="17">if c.ConflictResolution == "" </span><span class="cov5" title="16">{
                c.ConflictResolution = DefaultConflictResolution
        }</span>
        <span class="cov5" title="17">if c.TargetPlatform == "" </span><span class="cov5" title="17">{
                c.TargetPlatform = DefaultTargetPlatform
        }</span>
        <span class="cov5" title="17">if c.TemplateEngine == "" </span><span class="cov5" title="17">{
                c.TemplateEngine = DefaultTemplateEngine
        }</span>
        <span class="cov5" title="17">if c.LogLevel == "" </span><span class="cov5" title="17">{
                c.LogLevel = DefaultLogLevel
        }</span>

        <span class="cov5" title="17">return nil</span>
}

// Validate validates the provider configuration and expands paths.
// Call SetDefaults() before calling this method.
func (c *DotfilesConfig) Validate() error <span class="cov6" title="35">{
        var errs []string

        // Validate dotfiles root
        if c.DotfilesRoot == "" </span><span class="cov2" title="3">{
                errs = append(errs, "dotfiles_root cannot be empty")
        }</span> else<span class="cov6" title="32"> {
                // Expand path
                if strings.HasPrefix(c.DotfilesRoot, "~") </span><span class="cov1" title="1">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("unable to expand dotfiles_root path: %v", err))
                        }</span> else<span class="cov1" title="1"> {
                                c.DotfilesRoot = filepath.Join(homeDir, c.DotfilesRoot[1:])
                        }</span>
                }

                // Convert to absolute path
                <span class="cov6" title="32">absPath, err := filepath.Abs(c.DotfilesRoot)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid dotfiles_root path: %v", err))
                }</span> else<span class="cov6" title="32"> {
                        c.DotfilesRoot = absPath

                        // Validate that DotfilesRoot is writable
                        if err := c.validateWritablePath(c.DotfilesRoot, "dotfiles_root"); err != nil </span><span class="cov4" title="9">{
                                errs = append(errs, err.Error())
                        }</span>
                }
        }

        // Validate backup directory if backups are enabled
        <span class="cov6" title="35">if c.BackupEnabled &amp;&amp; c.BackupDirectory != "" </span><span class="cov3" title="5">{
                if strings.HasPrefix(c.BackupDirectory, "~") </span><span class="cov1" title="1">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("unable to expand backup_directory path: %v", err))
                        }</span> else<span class="cov1" title="1"> {
                                c.BackupDirectory = filepath.Join(homeDir, c.BackupDirectory[1:])
                        }</span>
                }

                <span class="cov3" title="5">absPath, err := filepath.Abs(c.BackupDirectory)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid backup_directory path: %v", err))
                }</span> else<span class="cov3" title="5"> {
                        c.BackupDirectory = absPath

                        // Validate that BackupDirectory is writable
                        if err := c.validateWritablePath(c.BackupDirectory, "backup_directory"); err != nil </span><span class="cov1" title="1">{
                                errs = append(errs, err.Error())
                        }</span>
                }
        }

        // Validate strategy
        <span class="cov6" title="35">if !contains(ValidStrategies, c.Strategy) </span><span class="cov4" title="14">{
                errs = append(errs, fmt.Sprintf("invalid strategy '%s', must be one of: %v", c.Strategy, ValidStrategies))
        }</span>

        // Validate conflict resolution
        <span class="cov6" title="35">if !contains(ValidConflictResolutions, c.ConflictResolution) </span><span class="cov4" title="12">{
                errs = append(errs, fmt.Sprintf("invalid conflict_resolution '%s', must be one of: %v", c.ConflictResolution, ValidConflictResolutions))
        }</span>

        // Validate target platform
        <span class="cov6" title="35">if !contains(ValidPlatforms, c.TargetPlatform) </span><span class="cov4" title="12">{
                errs = append(errs, fmt.Sprintf("invalid target_platform '%s', must be one of: %v", c.TargetPlatform, ValidPlatforms))
        }</span>

        // Validate template engine
        <span class="cov6" title="35">if !contains(ValidTemplateEngines, c.TemplateEngine) </span><span class="cov4" title="12">{
                errs = append(errs, fmt.Sprintf("invalid template_engine '%s', must be one of: %v", c.TemplateEngine, ValidTemplateEngines))
        }</span>

        // Validate log level
        <span class="cov6" title="35">if !contains(ValidLogLevels, c.LogLevel) </span><span class="cov4" title="12">{
                errs = append(errs, fmt.Sprintf("invalid log_level '%s', must be one of: %v", c.LogLevel, ValidLogLevels))
        }</span>

        <span class="cov6" title="35">if len(errs) &gt; 0 </span><span class="cov5" title="19">{
                return errors.New(strings.Join(errs, "; "))
        }</span>

        <span class="cov5" title="16">return nil</span>
}

// contains checks if a slice contains a string.
func contains(slice []string, item string) bool <span class="cov8" title="182">{
        for _, s := range slice </span><span class="cov10" title="383">{
                if s == item </span><span class="cov8" title="117">{
                        return true
                }</span>
        }
        <span class="cov7" title="65">return false</span>
}

// validateWritablePath checks if a path is writable, or if its parent directory is writable for creation.
func (c *DotfilesConfig) validateWritablePath(path, pathType string) error <span class="cov6" title="37">{
        // Check if path exists
        if info, err := os.Stat(path); err == nil </span><span class="cov6" title="33">{
                // Path exists, check if it's writable
                if info.IsDir() </span><span class="cov6" title="32">{
                        // For directories, try to create a test file
                        testFile := filepath.Join(path, ".terraform-provider-dotfiles-write-test")
                        if file, err := os.Create(testFile); err != nil </span><span class="cov3" title="7">{
                                return fmt.Errorf("%s directory '%s' is not writable: %w", pathType, path, err)
                        }</span> else<span class="cov5" title="25"> {
                                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue - this is just cleanup
                                        fmt.Printf("Warning: failed to close test file: %v\n", err)
                                }</span>
                                <span class="cov5" title="25">if err := os.Remove(testFile); err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue - this is just cleanup
                                        fmt.Printf("Warning: failed to remove test file: %v\n", err)
                                }</span>
                        }
                } else<span class="cov1" title="1"> {
                        return fmt.Errorf("%s path '%s' exists but is not a directory", pathType, path)
                }</span>
        } else<span class="cov3" title="4"> if os.IsNotExist(err) </span><span class="cov2" title="3">{
                // Path doesn't exist, check if parent directory is writable
                parentDir := filepath.Dir(path)
                if parentInfo, err := os.Stat(parentDir); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("%s parent directory '%s' does not exist or is not accessible: %w", pathType, parentDir, err)
                }</span> else<span class="cov2" title="2"> if !parentInfo.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s parent path '%s' is not a directory", pathType, parentDir)
                }</span> else<span class="cov2" title="2"> {
                        // Try to create the directory to test writability
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create %s directory '%s': %w", pathType, path, err)
                        }</span>
                        // Directory created successfully, it's writable
                }
        } else<span class="cov1" title="1"> {
                return fmt.Errorf("cannot access %s path '%s': %w", pathType, path, err)
        }</span>

        <span class="cov5" title="27">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

var _ resource.Resource = &amp;DirectoryResource{}

func NewDirectoryResource() resource.Resource <span class="cov10" title="5">{
        return &amp;DirectoryResource{}
}</span>

type DirectoryResource struct {
        client *DotfilesClient
}

type DirectoryResourceModel struct {
        ID                  types.String `tfsdk:"id"`
        Repository          types.String `tfsdk:"repository"`
        Name                types.String `tfsdk:"name"`
        SourcePath          types.String `tfsdk:"source_path"`
        TargetPath          types.String `tfsdk:"target_path"`
        Recursive           types.Bool   `tfsdk:"recursive"`
        PreservePermissions types.Bool   `tfsdk:"preserve_permissions"`

        // Computed attributes
        DirectoryExists types.Bool   `tfsdk:"directory_exists"`
        FileCount       types.Int64  `tfsdk:"file_count"`
        LastSynced      types.String `tfsdk:"last_synced"`
}

func (r *DirectoryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_directory"
}</span>

func (r *DirectoryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages directory structures and their contents",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Directory identifier",
                        },
                        "repository": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Repository ID this directory belongs to",
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Directory name/identifier",
                        },
                        "source_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to source directory in repository",
                                Validators: []validator.String{
                                        validators.ValidPath(),
                                        validators.EnvironmentVariableExpansion(),
                                },
                        },
                        "target_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Target directory path",
                                Validators: []validator.String{
                                        validators.ValidPath(),
                                        validators.EnvironmentVariableExpansion(),
                                },
                        },
                        "recursive": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Process directory recursively. Defaults to true",
                        },
                        "preserve_permissions": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Preserve file permissions. Defaults to true",
                        },
                        "directory_exists": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the target directory exists",
                        },
                        "file_count": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Number of files in the directory",
                        },
                        "last_synced": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Timestamp when the directory was last synced",
                        },
                },
        }
}</span>

func (r *DirectoryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov7" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError("Unexpected Resource Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov1" title="1">r.client = client</span>
}

func (r *DirectoryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
                "recursive":   data.Recursive.ValueBool(),
        })

        // Resolve source and target paths
        sourcePath, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Create or sync the directory
        <span class="cov0" title="0">err = r.syncDirectory(ctx, sourcePath, targetPath, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to sync directory",
                        fmt.Sprintf("Error syncing directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Directory resource created successfully", map[string]interface{}{
                "name":       data.Name.ValueString(),
                "file_count": data.FileCount.ValueInt64(),
        })</span>
}

func (r *DirectoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Resolve target path to check current state
        <span class="cov0" title="0">_, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes with current state
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DirectoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Resolve source and target paths
        sourcePath, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Re-sync the directory with updated configuration
        <span class="cov0" title="0">err = r.syncDirectory(ctx, sourcePath, targetPath, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to sync directory",
                        fmt.Sprintf("Error syncing directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Directory resource updated successfully", map[string]interface{}{
                "name":       data.Name.ValueString(),
                "file_count": data.FileCount.ValueInt64(),
        })</span>
}

func (r *DirectoryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Resolve target path
        _, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Check if target exists before attempting deletion
        <span class="cov0" title="0">if !utils.PathExists(targetPath) </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Target directory does not exist, nothing to delete", map[string]interface{}{
                        "target_path": targetPath,
                })
                return
        }</span>

        // Safety check: Don't delete system directories or directories outside expected paths
        <span class="cov0" title="0">if err := r.validateDeletionSafety(targetPath); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unsafe directory deletion",
                        fmt.Sprintf("Cannot delete directory %s: %v", targetPath, err),
                )
                return
        }</span>

        // Perform recursive deletion if configured
        <span class="cov0" title="0">if data.Recursive.ValueBool() </span><span class="cov0" title="0">{
                err = os.RemoveAll(targetPath)
        }</span> else<span class="cov0" title="0"> {
                err = os.Remove(targetPath)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to delete directory",
                        fmt.Sprintf("Error deleting directory %s: %v", targetPath, err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Directory resource deleted successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": targetPath,
        })</span>
}

// resolvePaths resolves the source and target paths for the directory.
func (r *DirectoryResource) resolvePaths(data *DirectoryResourceModel) (string, string, error) <span class="cov0" title="0">{
        // Get repository local path
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())
        sourcePath := data.SourcePath.ValueString()

        // Resolve full source path
        var fullSourcePath string
        if strings.HasPrefix(sourcePath, "/") </span><span class="cov0" title="0">{
                fullSourcePath = sourcePath
        }</span> else<span class="cov0" title="0"> {
                fullSourcePath = filepath.Join(repositoryLocalPath, sourcePath)
        }</span>

        // Resolve target path
        <span class="cov0" title="0">targetPath := data.TargetPath.ValueString()
        if strings.HasPrefix(targetPath, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">targetPath = strings.Replace(targetPath, "~", homeDir, 1)</span>
        }

        // Convert to absolute paths
        <span class="cov0" title="0">fullSourcePath, err := filepath.Abs(fullSourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get absolute source path: %w", err)
        }</span>

        <span class="cov0" title="0">targetPath, err = filepath.Abs(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get absolute target path: %w", err)
        }</span>

        <span class="cov0" title="0">return fullSourcePath, targetPath, nil</span>
}

// syncDirectory synchronizes the source directory to the target location.
func (r *DirectoryResource) syncDirectory(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        // Check if source exists
        if !utils.PathExists(sourcePath) </span><span class="cov0" title="0">{
                return fmt.Errorf("source directory does not exist: %s", sourcePath)
        }</span>

        // Create target directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(targetPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory: %w", err)
        }</span>

        <span class="cov0" title="0">if data.Recursive.ValueBool() </span><span class="cov0" title="0">{
                return r.syncDirectoryRecursive(ctx, sourcePath, targetPath, data)
        }</span> else<span class="cov0" title="0"> {
                return r.syncDirectoryShallow(ctx, sourcePath, targetPath, data)
        }</span>
}

// syncDirectoryRecursive recursively syncs directories.
func (r *DirectoryResource) syncDirectoryRecursive(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        return filepath.Walk(sourcePath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourcePath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get relative path: %w", err)
                }</span>

                <span class="cov0" title="0">targetFile := filepath.Join(targetPath, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        // Create directory
                        if err := os.MkdirAll(targetFile, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", targetFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        if err := r.copyFile(ctx, path, targetFile, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", path, err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// syncDirectoryShallow syncs only the top-level directory contents.
func (r *DirectoryResource) syncDirectoryShallow(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        entries, err := os.ReadDir(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                sourceFile := filepath.Join(sourcePath, entry.Name())
                targetFile := filepath.Join(targetPath, entry.Name())

                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get file info for %s: %w", entry.Name(), err)
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        // Create directory
                        if err := os.MkdirAll(targetFile, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", targetFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        if err := r.copyFile(ctx, sourceFile, targetFile, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", sourceFile, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a single file with optional permission preservation.
func (r *DirectoryResource) copyFile(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := sourceFile.Close(); err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to close source file", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }()

        // Create target directory if needed
        <span class="cov0" title="0">targetDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory: %w", err)
        }</span>

        <span class="cov0" title="0">targetFile, err := os.Create(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := targetFile.Close(); err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to close target file", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }()

        // Copy content
        <span class="cov0" title="0">if _, err := targetFile.ReadFrom(sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file content: %w", err)
        }</span>

        // Preserve permissions if requested
        <span class="cov0" title="0">if data.PreservePermissions.ValueBool() </span><span class="cov0" title="0">{
                sourceInfo, err := sourceFile.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get source file permissions: %w", err)
                }</span>

                <span class="cov0" title="0">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set target file permissions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateComputedAttributes updates computed attributes based on current directory state.
func (r *DirectoryResource) updateComputedAttributes(ctx context.Context, data *DirectoryResourceModel, targetPath string) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        // Check if directory exists
        exists := utils.PathExists(targetPath)
        data.DirectoryExists = types.BoolValue(exists)

        if exists </span><span class="cov0" title="0">{
                // Count files
                fileCount, err := r.countFiles(targetPath, data.Recursive.ValueBool())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to count files: %w", err)
                }</span>
                <span class="cov0" title="0">data.FileCount = types.Int64Value(fileCount)</span>
        } else<span class="cov0" title="0"> {
                data.FileCount = types.Int64Value(0)
        }</span>

        // Set last synced timestamp
        <span class="cov0" title="0">data.LastSynced = types.StringValue(time.Now().Format(time.RFC3339))

        return nil</span>
}

// countFiles counts the number of files in a directory.
func (r *DirectoryResource) countFiles(dirPath string, recursive bool) (int64, error) <span class="cov0" title="0">{
        var count int64

        if recursive </span><span class="cov0" title="0">{
                err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                                count++
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">return count, err</span>
        } else<span class="cov0" title="0"> {
                entries, err := os.ReadDir(dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
                <span class="cov0" title="0">return count, nil</span>
        }
}

// validateDeletionSafety performs safety checks before deleting a directory.
func (r *DirectoryResource) validateDeletionSafety(targetPath string) error <span class="cov0" title="0">{
        // Get absolute path
        absPath, err := filepath.Abs(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        // List of paths that should never be deleted
        <span class="cov0" title="0">dangerousPaths := []string{
                "/",
                "/bin",
                "/boot",
                "/dev",
                "/etc",
                "/lib",
                "/proc",
                "/root",
                "/sbin",
                "/sys",
                "/tmp",
                "/usr",
                "/var",
        }

        for _, dangerous := range dangerousPaths </span><span class="cov0" title="0">{
                if absPath == dangerous || strings.HasPrefix(absPath+"/", dangerous+"/") </span><span class="cov0" title="0">{
                        return fmt.Errorf("refusing to delete system directory: %s", absPath)
                }</span>
        }

        // Don't delete if outside of home directory or known safe paths
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err == nil </span><span class="cov0" title="0">{
                if !strings.HasPrefix(absPath, homeDir) &amp;&amp; !strings.HasPrefix(absPath, "/tmp") </span><span class="cov0" title="0">{
                        return fmt.Errorf("refusing to delete directory outside home directory: %s", absPath)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *DirectoryResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// BackupStrategyModel defines the backup strategy configuration block.
type BackupStrategyModel struct {
        Enabled         types.Bool   `tfsdk:"enabled"`
        Directory       types.String `tfsdk:"directory"`
        RetentionPolicy types.String `tfsdk:"retention_policy"`
        Compression     types.Bool   `tfsdk:"compression"`
        Incremental     types.Bool   `tfsdk:"incremental"`
        MaxBackups      types.Int64  `tfsdk:"max_backups"`
}

// RecoveryModel defines the recovery configuration block.
type RecoveryModel struct {
        CreateRestoreScripts types.Bool `tfsdk:"create_restore_scripts"`
        ValidateBackups      types.Bool `tfsdk:"validate_backups"`
        TestRecovery         types.Bool `tfsdk:"test_recovery"`
        BackupIndex          types.Bool `tfsdk:"backup_index"`
}

// BackupPolicyModel defines file-specific backup policy.
type BackupPolicyModel struct {
        AlwaysBackup    types.Bool   `tfsdk:"always_backup"`
        VersionedBackup types.Bool   `tfsdk:"versioned_backup"`
        BackupFormat    types.String `tfsdk:"backup_format"`
        RetentionCount  types.Int64  `tfsdk:"retention_count"`
        BackupMetadata  types.Bool   `tfsdk:"backup_metadata"`
        Compression     types.Bool   `tfsdk:"compression"`
}

// RecoveryTestModel defines recovery testing configuration.
type RecoveryTestModel struct {
        Enabled types.Bool   `tfsdk:"enabled"`
        Command types.String `tfsdk:"command"`
        Timeout types.String `tfsdk:"timeout"`
}

// EnhancedProviderModel extends DotfilesProviderModel with enhanced backup features.
// Since DotfilesProviderModel now includes backup_strategy and recovery fields,
// this is now just an alias for backward compatibility.
type EnhancedProviderModel = DotfilesProviderModel

// EnhancedFileResourceModelWithBackup extends EnhancedFileResourceModel with backup features.
type EnhancedFileResourceModelWithBackup struct {
        EnhancedFileResourceModel
        BackupPolicy *BackupPolicyModel `tfsdk:"backup_policy"`
        RecoveryTest *RecoveryTestModel `tfsdk:"recovery_test"`
}

// EnhancedSymlinkResourceModelWithBackup extends EnhancedSymlinkResourceModel with backup features.
type EnhancedSymlinkResourceModelWithBackup struct {
        EnhancedSymlinkResourceModel
        BackupPolicy *BackupPolicyModel `tfsdk:"backup_policy"`
        RecoveryTest *RecoveryTestModel `tfsdk:"recovery_test"`
}

// GetBackupStrategySchemaBlock returns the schema block for backup strategy.
func GetBackupStrategySchemaBlock() schema.SingleNestedBlock <span class="cov8" title="3">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Enhanced backup strategy configuration",
                Attributes: map[string]schema.Attribute{
                        "enabled": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Enable enhanced backup features",
                        },
                        "directory": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("~/.dotfiles-backups"),
                                MarkdownDescription: "Directory to store backup files",
                        },
                        "retention_policy": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("30d"),
                                MarkdownDescription: "Backup retention policy (e.g., '30d', '7d', '1y')",
                        },
                        "compression": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Enable backup compression (gzip)",
                        },
                        "incremental": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Only backup when content changes",
                        },
                        "max_backups": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             int64default.StaticInt64(50),
                                MarkdownDescription: "Maximum number of backups to keep per file",
                        },
                },
        }
}</span>

// GetRecoverySchemaBlock returns the schema block for recovery configuration.
func GetRecoverySchemaBlock() schema.SingleNestedBlock <span class="cov8" title="3">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Recovery and validation configuration",
                Attributes: map[string]schema.Attribute{
                        "create_restore_scripts": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Generate restore scripts for backups",
                        },
                        "validate_backups": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Validate backup integrity with checksums",
                        },
                        "test_recovery": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Test backup recovery functionality",
                        },
                        "backup_index": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Create searchable backup index",
                        },
                },
        }
}</span>

// GetBackupPolicySchemaBlock returns the schema block for file-specific backup policy.
func GetBackupPolicySchemaBlock() schema.SingleNestedBlock <span class="cov10" title="4">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "File-specific backup policy configuration",
                Attributes: map[string]schema.Attribute{
                        "always_backup": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Force backup even if globally disabled",
                        },
                        "versioned_backup": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Keep multiple backup versions",
                        },
                        "backup_format": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("timestamped"),
                                MarkdownDescription: "Backup naming format: timestamped, numbered, or git_style",
                        },
                        "retention_count": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             int64default.StaticInt64(5),
                                MarkdownDescription: "Number of backup versions to retain",
                        },
                        "backup_metadata": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Store backup metadata (checksums, timestamps)",
                        },
                        "compression": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Compress this file's backups",
                        },
                },
        }
}</span>

// GetRecoveryTestSchemaBlock returns the schema block for recovery testing.
func GetRecoveryTestSchemaBlock() schema.SingleNestedBlock <span class="cov10" title="4">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Recovery testing configuration",
                Attributes: map[string]schema.Attribute{
                        "enabled": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Enable recovery testing for this file",
                        },
                        "command": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Command to validate backup ({{.backup_path}} template available)",
                        },
                        "timeout": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("30s"),
                                MarkdownDescription: "Timeout for recovery test commands",
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// EnhancedFileResourceModelWithTemplate extends EnhancedFileResourceModelWithBackup with template features.
type EnhancedFileResourceModelWithTemplate struct {
        EnhancedFileResourceModelWithBackup
        TemplateEngine       types.String `tfsdk:"template_engine"`
        PlatformTemplateVars types.Map    `tfsdk:"platform_template_vars"`
        TemplateFunctions    types.Map    `tfsdk:"template_functions"`
}

// EnhancedSymlinkResourceModelWithTemplate extends EnhancedSymlinkResourceModelWithBackup with template features.
type EnhancedSymlinkResourceModelWithTemplate struct {
        EnhancedSymlinkResourceModelWithBackup
        TemplateEngine       types.String `tfsdk:"template_engine"`
        PlatformTemplateVars types.Map    `tfsdk:"platform_template_vars"`
        TemplateFunctions    types.Map    `tfsdk:"template_functions"`
}

// EnhancedFileResourceModelWithApplicationDetection extends template model with app detection.
type EnhancedFileResourceModelWithApplicationDetection struct {
        EnhancedFileResourceModelWithTemplate
        RequireApplication    types.String `tfsdk:"require_application"`
        ApplicationVersionMin types.String `tfsdk:"application_version_min"`
        ApplicationVersionMax types.String `tfsdk:"application_version_max"`
        SkipIfAppMissing      types.Bool   `tfsdk:"skip_if_app_missing"`
}

// ApplicationDetectionConfig represents application detection configuration.
type ApplicationDetectionConfig struct {
        RequiredApplication string
        MinVersion          string
        MaxVersion          string
        SkipIfMissing       bool
}

// GetEnhancedTemplateAttributes returns template-related schema attributes.
func GetEnhancedTemplateAttributes() map[string]schema.Attribute <span class="cov10" title="4">{
        return map[string]schema.Attribute{
                "template_engine": schema.StringAttribute{
                        Optional:            true,
                        Computed:            true,
                        Default:             stringdefault.StaticString("go"),
                        MarkdownDescription: "Template engine to use: go (default), handlebars, or mustache",
                        Validators: []validator.String{
                                validators.ValidTemplateEngine(),
                        },
                },
                "platform_template_vars": schema.MapAttribute{
                        Optional: true,
                        ElementType: types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "credential_helper": types.StringType,
                                        "diff_tool":         types.StringType,
                                        "homebrew_path":     types.StringType,
                                        "config_dir":        types.StringType,
                                        "shell":             types.StringType,
                                },
                        },
                        MarkdownDescription: "Platform-specific template variables (macos, linux, windows)",
                },
                "template_functions": schema.MapAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Custom template functions (name -&gt; value mappings)",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var _ datasource.DataSource = &amp;FileInfoDataSource{}

func NewFileInfoDataSource() datasource.DataSource <span class="cov10" title="5">{
        return &amp;FileInfoDataSource{}
}</span>

type FileInfoDataSource struct {
        client *DotfilesClient
}

type FileInfoDataSourceModel struct {
        ID          types.String `tfsdk:"id"`
        Path        types.String `tfsdk:"path"`
        Exists      types.Bool   `tfsdk:"exists"`
        IsSymlink   types.Bool   `tfsdk:"is_symlink"`
        Permissions types.String `tfsdk:"permissions"`
        Size        types.Int64  `tfsdk:"size"`
}

func (d *FileInfoDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_file_info"
}</span>

func (d *FileInfoDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "File information data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Data source identifier",
                        },
                        "path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the file to examine",
                        },
                        "exists": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the file exists",
                        },
                        "is_symlink": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the file is a symlink",
                        },
                        "permissions": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "File permissions",
                        },
                        "size": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "File size in bytes",
                        },
                },
        }
}</span>

func (d *FileInfoDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov7" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError("Unexpected Data Source Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov1" title="1">d.client = client</span>
}

func (d *FileInfoDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data FileInfoDataSourceModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // TODO: Implement actual file info reading logic
        <span class="cov0" title="0">data.ID = data.Path
        data.Exists = types.BoolValue(false)
        data.IsSymlink = types.BoolValue(false)
        data.Permissions = types.StringValue("0644")
        data.Size = types.Int64Value(0)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/errors"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/template"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;FileResource{}

func NewFileResource() resource.Resource <span class="cov6" title="8">{
        return &amp;FileResource{}
}</span>

// FileResource defines the resource implementation.
type FileResource struct {
        client *DotfilesClient
}

// FileResourceModel describes the resource data model.
type FileResourceModel struct {
        ID            types.String `tfsdk:"id"`
        Repository    types.String `tfsdk:"repository"`
        Name          types.String `tfsdk:"name"`
        SourcePath    types.String `tfsdk:"source_path"`
        TargetPath    types.String `tfsdk:"target_path"`
        IsTemplate    types.Bool   `tfsdk:"is_template"`
        FileMode      types.String `tfsdk:"file_mode"`
        BackupEnabled types.Bool   `tfsdk:"backup_enabled"`

        // Template variables (for template processing)
        TemplateVars types.Map `tfsdk:"template_vars"`

        // Computed attributes for state tracking
        ContentHash  types.String `tfsdk:"content_hash"`
        LastModified types.String `tfsdk:"last_modified"`
        FileExists   types.Bool   `tfsdk:"file_exists"`
}

func (r *FileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_file"
}</span>

func (r *FileResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov4" title="4">{
        // Get post-hooks attributes and merge with base attributes
        baseAttributes := map[string]schema.Attribute{
                "id": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "File identifier",
                },
                "repository": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Repository ID this file belongs to",
                },
                "name": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "File name/identifier",
                },
                "source_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Path to source file in repository",
                        Validators: []validator.String{
                                validators.ValidPath(),
                                validators.EnvironmentVariableExpansion(),
                        },
                },
                "target_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Target path where file should be placed",
                        Validators: []validator.String{
                                validators.ValidPath(),
                                validators.EnvironmentVariableExpansion(),
                        },
                },
                "is_template": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Whether the file should be processed as a template",
                },
                "file_mode": schema.StringAttribute{
                        Optional:            true,
                        MarkdownDescription: "File permissions (e.g., '0644') - deprecated, use permissions block",
                        Validators: []validator.String{
                                validators.ValidFileMode(),
                        },
                },
                "backup_enabled": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Whether to backup existing files",
                },
                "template_vars": schema.MapAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Variables for template processing",
                },
                "permission_rules": GetPermissionRulesAttribute(),
                "content_hash": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "SHA256 hash of file content",
                },
                "last_modified": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Last modification timestamp",
                },
                "file_exists": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the target file exists",
                },
        }

        // Add post-hooks attributes
        postHooksAttrs := GetPostHooksAttributes()
        for key, attr := range postHooksAttrs </span><span class="cov7" title="12">{
                baseAttributes[key] = attr
        }</span>

        // Add enhanced template attributes
        <span class="cov4" title="4">templateAttrs := GetEnhancedTemplateAttributes()
        for key, attr := range templateAttrs </span><span class="cov7" title="12">{
                baseAttributes[key] = attr
        }</span>

        // Application detection is now handled by terraform-provider-package
        // This resource focuses solely on file management

        <span class="cov4" title="4">resp.Schema = schema.Schema{
                MarkdownDescription: "Manages individual dotfiles via **copy operations only**. For symlinks use `dotfiles_symlink`, for directories use `dotfiles_directory`, for multi-strategy application configs use `dotfiles_application`.",
                Attributes:          baseAttributes,
                Blocks: map[string]schema.Block{
                        "permissions":   GetPermissionsSchemaBlock(),
                        "backup_policy": GetBackupPolicySchemaBlock(),
                        "recovery_test": GetRecoveryTestSchemaBlock(),
                },
        }</span>
}

func (r *FileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov4" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else. Please report this issue to the provider developers.",
                )
                return
        }</span>

        <span class="cov1" title="1">r.client = client</span>
}

func (r *FileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithTemplate

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
                "is_template": data.IsTemplate.ValueBool(),
        })

        // Application requirements are now handled by terraform-provider-package
        // This resource focuses on file management only

        // Get repository information (for local path if it's a Git repository)
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())

        // Build source file path
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()

        // Pre-apply validation: check if source file exists
        if err := r.validateSourceFileExists(ctx, sourcePath); err != nil </span><span class="cov0" title="0">{
                sourceErr := errors.ValidationError("validate_source_file", "file", "Source file validation failed", err).
                        WithPath(sourcePath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("repository", data.Repository.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, sourceErr, "Source file not found")
                return
        }</span>

        // Expand target path
        <span class="cov0" title="0">platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                pathErr := errors.ValidationError("expand_target_path", "file", "Could not expand target path", err).
                        WithPath(targetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, pathErr, "Invalid target path")
                return
        }</span>

        // Create file manager
        <span class="cov0" title="0">fileManager := fileops.NewFileManager(platformProvider, r.client.Config.DryRun)

        // Build permission configuration
        permConfig, err := buildFilePermissionConfig(&amp;data.EnhancedFileResourceModel)
        if err != nil </span><span class="cov0" title="0">{
                configErr := errors.ConfigurationError("build_permission_config", "file", "Failed to build permission configuration", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, configErr, "Invalid permission configuration")
                return
        }</span>

        // Build enhanced backup configuration
        <span class="cov0" title="0">enhancedBackupConfig, err := buildEnhancedBackupConfigFromAppModel(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                backupErr := errors.ConfigurationError("build_backup_config", "file", "Failed to build backup configuration", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, backupErr, "Invalid backup configuration")
                return
        }</span>

        // Handle backup - use enhanced if available, otherwise fall back to legacy
        <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                if enhancedBackupConfig != nil &amp;&amp; enhancedBackupConfig.Enabled </span><span class="cov0" title="0">{
                        // Use enhanced backup with retry
                        enhancedBackupConfig.Directory = r.client.Config.BackupDirectory

                        if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                                backupErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                        _, err := fileManager.CreateEnhancedBackup(expandedTargetPath, enhancedBackupConfig)
                                        return err
                                }</span>)

                                <span class="cov0" title="0">if backupErr != nil </span><span class="cov0" title="0">{
                                        backupWarnErr := errors.IOError("create_enhanced_backup", "file", "Could not create enhanced backup", backupErr).
                                                WithPath(expandedTargetPath).
                                                WithContext("backup_directory", r.client.Config.BackupDirectory)
                                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Enhanced backup failed", backupWarnErr.Error())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "DRY RUN: Skipping enhanced backup operation", map[string]interface{}{
                                        "target_path":      expandedTargetPath,
                                        "backup_directory": r.client.Config.BackupDirectory,
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fall back to legacy backup
                        backupEnabled := r.client.Config.BackupEnabled
                        if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                                backupEnabled = data.BackupEnabled.ValueBool()
                        }</span>

                        <span class="cov0" title="0">if backupEnabled </span><span class="cov0" title="0">{
                                if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                                        backupErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                                return err
                                        }</span>)

                                        <span class="cov0" title="0">if backupErr != nil </span><span class="cov0" title="0">{
                                                backupWarnErr := errors.IOError("create_backup", "file", "Could not create backup", backupErr).
                                                        WithPath(expandedTargetPath).
                                                        WithContext("backup_directory", r.client.Config.BackupDirectory)
                                                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Backup failed", backupWarnErr.Error())
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        tflog.Info(ctx, "DRY RUN: Skipping backup operation", map[string]interface{}{
                                                "target_path":      expandedTargetPath,
                                                "backup_directory": r.client.Config.BackupDirectory,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var finalErr error

        if data.IsTemplate.ValueBool() </span><span class="cov0" title="0">{
                // Build enhanced template configuration
                templateConfig, err := buildEnhancedTemplateConfigFromAppModel(&amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        templateErr := errors.ConfigurationError("build_template_config", "file", "Failed to build template configuration", err).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString()).
                                WithContext("source_path", sourcePath)
                        errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, templateErr, "Invalid template configuration")
                        return
                }</span>

                // Process template with enhanced features and retry
                <span class="cov0" title="0">if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                        finalErr = errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                return r.processEnhancedTemplate(sourcePath, expandedTargetPath, templateConfig, permConfig)
                        }</span>)

                        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                                templateErr := errors.TemplateError("process_template", "file", "Template processing failed", finalErr).
                                        WithPath(expandedTargetPath).
                                        WithContext("file_name", data.Name.ValueString()).
                                        WithContext("source_path", sourcePath).
                                        WithContext("template_engine", templateConfig.Engine)
                                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, templateErr, "Template processing failed")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "DRY RUN: Skipping template processing", map[string]interface{}{
                                "source_path":     sourcePath,
                                "target_path":     expandedTargetPath,
                                "template_engine": templateConfig.Engine,
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                // Regular file copy with enhanced permissions and retry
                if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                        finalErr = errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                return fileManager.CopyFileWithPermissions(sourcePath, expandedTargetPath, permConfig)
                        }</span>)

                        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                                copyErr := errors.IOError("copy_file", "file", "File copy operation failed", finalErr).
                                        WithPath(expandedTargetPath).
                                        WithContext("file_name", data.Name.ValueString()).
                                        WithContext("source_path", sourcePath)
                                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, copyErr, "File operation failed")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "DRY RUN: Skipping file copy operation", map[string]interface{}{
                                "source_path": sourcePath,
                                "target_path": expandedTargetPath,
                        })
                }</span>
        }

        // Execute post-create commands
        <span class="cov0" title="0">if err := executePostCommands(ctx, data.PostCreateCommands, "post-create"); err != nil </span><span class="cov0" title="0">{
                postCmdErr := errors.IOError("execute_post_commands", "file", "Post-create commands failed", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("command_type", "post-create")
                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Post-create commands failed",
                        "File created successfully but post-create commands failed: "+postCmdErr.Error())
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                metadataErr := errors.IOError("update_metadata", "file", "Could not update file metadata", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Could not update file metadata",
                        "File created successfully but could not update metadata: "+metadataErr.Error())
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "File resource created successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
                "is_template": data.IsTemplate.ValueBool(),
        })</span>
}

func (r *FileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithTemplate

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Expand target path to check current state
        targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        pathErr := errors.ValidationError("expand_target_path", "file", "Could not expand target path", err).
                                WithPath(targetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, pathErr, "Invalid target path")
                        return
                }</span>

                // Update computed attributes with current file state
                <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                        metadataErr := errors.IOError("read_metadata", "file", "Could not read file metadata", err).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Could not read file metadata", metadataErr.Error())
                }</span>

                // Check for drift if file doesn't exist
                <span class="cov0" title="0">if !data.FileExists.ValueBool() </span><span class="cov0" title="0">{
                        driftErr := errors.IOError("check_file_existence", "file", "Managed file no longer exists", nil).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Managed file not found", driftErr.Error())
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *FileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithTemplate

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Get repository local path
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())

        // Build paths
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()

        // Pre-apply validation: check if source file exists
        if err := r.validateSourceFileExists(ctx, sourcePath); err != nil </span><span class="cov0" title="0">{
                sourceErr := errors.ValidationError("validate_source_file", "file", "Source file validation failed", err).
                        WithPath(sourcePath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("repository", data.Repository.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, sourceErr, "Source file not found")
                return
        }</span>

        // Expand target path
        <span class="cov0" title="0">platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid target path",
                        fmt.Sprintf("Could not expand target path %s: %s", targetPath, err.Error()),
                )
                return
        }</span>

        // Create file manager
        <span class="cov0" title="0">fileManager := fileops.NewFileManager(platformProvider, r.client.Config.DryRun)

        // Build permission configuration
        permConfig, err := buildFilePermissionConfig(&amp;data.EnhancedFileResourceModel)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid permission configuration",
                        fmt.Sprintf("Failed to build permission config: %s", err.Error()),
                )
                return
        }</span>

        // Build enhanced backup configuration
        <span class="cov0" title="0">enhancedBackupConfig, err := buildEnhancedBackupConfigFromAppModel(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid backup configuration",
                        fmt.Sprintf("Failed to build backup config: %s", err.Error()),
                )
                return
        }</span>

        // Handle backup before update - use enhanced if available, otherwise fall back to legacy
        <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                if enhancedBackupConfig != nil &amp;&amp; enhancedBackupConfig.Enabled </span><span class="cov0" title="0">{
                        // Use enhanced backup
                        enhancedBackupConfig.Directory = r.client.Config.BackupDirectory
                        _, err := fileManager.CreateEnhancedBackup(expandedTargetPath, enhancedBackupConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Enhanced backup failed",
                                        fmt.Sprintf("Could not create enhanced backup before update: %s", err.Error()),
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fall back to legacy backup
                        backupEnabled := r.client.Config.BackupEnabled
                        if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                                backupEnabled = data.BackupEnabled.ValueBool()
                        }</span>

                        <span class="cov0" title="0">if backupEnabled </span><span class="cov0" title="0">{
                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddWarning(
                                                "Backup failed",
                                                fmt.Sprintf("Could not create backup before update: %s", err.Error()),
                                        )
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var finalErr error

        if data.IsTemplate.ValueBool() </span><span class="cov0" title="0">{
                // Build enhanced template configuration
                templateConfig, err := buildEnhancedTemplateConfigFromAppModel(&amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Invalid template configuration",
                                fmt.Sprintf("Failed to build template config: %s", err.Error()),
                        )
                        return
                }</span>

                // Process template with enhanced features
                <span class="cov0" title="0">finalErr = r.processEnhancedTemplate(sourcePath, expandedTargetPath, templateConfig, permConfig)</span>
        } else<span class="cov0" title="0"> {
                // Regular file copy with enhanced permissions
                finalErr = fileManager.CopyFileWithPermissions(sourcePath, expandedTargetPath, permConfig)
        }</span>

        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "File update failed",
                        fmt.Sprintf("Could not update file %s: %s", expandedTargetPath, finalErr.Error()),
                )
                return
        }</span>

        // Execute post-update commands
        <span class="cov0" title="0">if err := executePostCommands(ctx, data.PostUpdateCommands, "post-update"); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Post-update commands failed",
                        fmt.Sprintf("File updated successfully but post-update commands failed: %s", err.Error()),
                )
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Could not update file metadata",
                        fmt.Sprintf("File updated successfully but could not update metadata: %s", err.Error()),
                )
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "File resource updated successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
        })</span>
}

func (r *FileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithTemplate

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Execute pre-destroy commands
        if err := executePostCommands(ctx, data.PreDestroyCommands, "pre-destroy"); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Pre-destroy commands failed",
                        fmt.Sprintf("Pre-destroy commands failed: %s", err.Error()),
                )
        }</span>

        // For file resources, we typically remove the managed file
        // but preserve any backups
        <span class="cov0" title="0">targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                // Expand target path
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Could not expand target path",
                                fmt.Sprintf("Could not expand target path for cleanup: %s", err.Error()),
                        )
                        return
                }</span>

                // Remove the file if it exists
                <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                        err := os.Remove(expandedTargetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Could not remove file",
                                        fmt.Sprintf("Could not remove file %s: %s", expandedTargetPath, err.Error()),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "File resource removed", map[string]interface{}{
                                        "target_path": expandedTargetPath,
                                })
                        }</span>
                }
        }
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *FileResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>

// updateComputedAttributes updates computed attributes for state tracking.
func (r *FileResource) updateComputedAttributes(ctx context.Context, data *FileResourceModel, targetPath string) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        // Check if file exists
        exists := utils.PathExists(targetPath)
        data.FileExists = types.BoolValue(exists)

        if exists </span><span class="cov0" title="0">{
                // Get file info
                info, err := os.Stat(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stat file: %w", err)
                }</span>

                // Set last modified time
                <span class="cov0" title="0">data.LastModified = types.StringValue(info.ModTime().Format(time.RFC3339))

                // Calculate content hash
                content, err := os.ReadFile(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read file for hash: %w", err)
                }</span>

                <span class="cov0" title="0">hash := sha256.Sum256(content)
                data.ContentHash = types.StringValue(fmt.Sprintf("%x", hash))</span>
        } else<span class="cov0" title="0"> {
                data.LastModified = types.StringNull()
                data.ContentHash = types.StringNull()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildEnhancedBackupConfigFromFileModel builds enhanced backup config from file model.
func buildEnhancedBackupConfigFromFileModel(data *EnhancedFileResourceModelWithBackup) (*fileops.EnhancedBackupConfig, error) <span class="cov4" title="3">{
        if data.BackupPolicy == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov2" title="2">config := &amp;fileops.EnhancedBackupConfig{
                Enabled:        data.BackupPolicy.AlwaysBackup.ValueBool() || !data.BackupPolicy.AlwaysBackup.IsNull(),
                BackupFormat:   data.BackupPolicy.BackupFormat.ValueString(),
                MaxBackups:     data.BackupPolicy.RetentionCount.ValueInt64(),
                BackupMetadata: data.BackupPolicy.BackupMetadata.ValueBool(),
                Compression:    data.BackupPolicy.Compression.ValueBool(),
                Incremental:    data.BackupPolicy.VersionedBackup.ValueBool(),
                BackupIndex:    true, // Always enable for file-level policies
        }

        // Set defaults if not specified
        if config.BackupFormat == "" </span><span class="cov0" title="0">{
                config.BackupFormat = "timestamped"
        }</span>
        <span class="cov2" title="2">if config.MaxBackups == 0 </span><span class="cov0" title="0">{
                config.MaxBackups = 5
        }</span>

        <span class="cov2" title="2">return config, fileops.ValidateEnhancedBackupConfig(config)</span>
}

// buildEnhancedBackupConfigFromTemplateModel builds enhanced backup config from template model.
func buildEnhancedBackupConfigFromTemplateModel(data *EnhancedFileResourceModelWithTemplate) (*fileops.EnhancedBackupConfig, error) <span class="cov0" title="0">{
        return buildEnhancedBackupConfigFromFileModel(&amp;data.EnhancedFileResourceModelWithBackup)
}</span>

// buildEnhancedTemplateConfigFromAppModel builds template config from template model.
func buildEnhancedTemplateConfigFromAppModel(data *EnhancedFileResourceModelWithTemplate) (*EnhancedTemplateConfig, error) <span class="cov0" title="0">{
        return buildEnhancedTemplateConfig(data)
}</span>

// buildEnhancedBackupConfigFromAppModel builds backup config from template model.
func buildEnhancedBackupConfigFromAppModel(data *EnhancedFileResourceModelWithTemplate) (*fileops.EnhancedBackupConfig, error) <span class="cov0" title="0">{
        return buildEnhancedBackupConfigFromTemplateModel(data)
}</span>

// buildEnhancedTemplateConfig builds template configuration from template model.
func buildEnhancedTemplateConfig(data *EnhancedFileResourceModelWithTemplate) (*EnhancedTemplateConfig, error) <span class="cov4" title="3">{
        config := &amp;EnhancedTemplateConfig{
                Engine:          "go", // default
                UserVars:        make(map[string]interface{}),
                PlatformVars:    make(map[string]map[string]interface{}),
                CustomFunctions: make(map[string]interface{}),
        }

        // Set template engine
        if !data.TemplateEngine.IsNull() </span><span class="cov2" title="2">{
                config.Engine = data.TemplateEngine.ValueString()
        }</span>

        // Parse template vars
        <span class="cov4" title="3">if !data.TemplateVars.IsNull() </span><span class="cov2" title="2">{
                elements := data.TemplateVars.Elements()
                for key, value := range elements </span><span class="cov5" title="5">{
                        if strValue, ok := value.(types.String); ok </span><span class="cov5" title="5">{
                                // Validate template variable name
                                if key == "" </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("template variable name cannot be empty")
                                }</span>
                                <span class="cov5" title="5">config.UserVars[key] = strValue.ValueString()</span>
                        } else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("template variable '%s' must be a string", key)
                        }</span>
                }
        }

        // Parse platform template vars
        <span class="cov4" title="3">if !data.PlatformTemplateVars.IsNull() </span><span class="cov2" title="2">{
                elements := data.PlatformTemplateVars.Elements()
                for platform, platformVarsValue := range elements </span><span class="cov4" title="3">{
                        if objValue, ok := platformVarsValue.(types.Object); ok </span><span class="cov4" title="3">{
                                platformMap := make(map[string]interface{})
                                objAttrs := objValue.Attributes()
                                for key, attrValue := range objAttrs </span><span class="cov6" title="7">{
                                        if strValue, ok := attrValue.(types.String); ok </span><span class="cov6" title="7">{
                                                platformMap[key] = strValue.ValueString()
                                        }</span>
                                }
                                <span class="cov4" title="3">config.PlatformVars[platform] = platformMap</span>
                        }
                }
        }

        // Parse template functions (simple string mappings for now)
        <span class="cov4" title="3">if !data.TemplateFunctions.IsNull() </span><span class="cov1" title="1">{
                elements := data.TemplateFunctions.Elements()
                for name, funcValue := range elements </span><span class="cov2" title="2">{
                        if strValue, ok := funcValue.(types.String); ok </span><span class="cov2" title="2">{
                                // For now, store as string values - could be enhanced to support actual functions
                                config.CustomFunctions[name] = strValue.ValueString()
                        }</span>
                }
        }

        <span class="cov4" title="3">return config, ValidateEnhancedTemplateConfig(config)</span>
}

// EnhancedTemplateConfig represents enhanced template configuration.
type EnhancedTemplateConfig struct {
        Engine          string
        UserVars        map[string]interface{}
        PlatformVars    map[string]map[string]interface{}
        CustomFunctions map[string]interface{}
}

// ValidateEnhancedTemplateConfig validates enhanced template configuration.
func ValidateEnhancedTemplateConfig(config *EnhancedTemplateConfig) error <span class="cov4" title="3">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate template engine
        <span class="cov4" title="3">validEngines := []string{"go", "handlebars", "mustache"}
        valid := false
        for _, engine := range validEngines </span><span class="cov4" title="4">{
                if config.Engine == engine </span><span class="cov4" title="3">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov4" title="3">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template engine: %s (must be one of: %v)", config.Engine, validEngines)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// buildFilePermissionConfig builds a PermissionConfig from the enhanced model data.
func buildFilePermissionConfig(data *EnhancedFileResourceModel) (*fileops.PermissionConfig, error) <span class="cov0" title="0">{
        config := &amp;fileops.PermissionConfig{}

        // Handle permissions block
        if data.Permissions != nil </span><span class="cov0" title="0">{
                if !data.Permissions.Directory.IsNull() </span><span class="cov0" title="0">{
                        config.DirectoryMode = data.Permissions.Directory.ValueString()
                }</span>
                <span class="cov0" title="0">if !data.Permissions.Files.IsNull() </span><span class="cov0" title="0">{
                        config.FileMode = data.Permissions.Files.ValueString()
                }</span>
                <span class="cov0" title="0">if !data.Permissions.Recursive.IsNull() </span><span class="cov0" title="0">{
                        config.Recursive = data.Permissions.Recursive.ValueBool()
                }</span>
        }

        // Handle permission rules
        <span class="cov0" title="0">if !data.PermissionRules.IsNull() &amp;&amp; !data.PermissionRules.IsUnknown() </span><span class="cov0" title="0">{
                config.Rules = make(map[string]string)
                elements := data.PermissionRules.Elements()
                for pattern, permValue := range elements </span><span class="cov0" title="0">{
                        if strPerm, ok := permValue.(types.String); ok </span><span class="cov0" title="0">{
                                config.Rules[pattern] = strPerm.ValueString()
                        }</span>
                }
        }

        // Fallback to legacy file_mode if no permissions are set
        <span class="cov0" title="0">if config.FileMode == "" &amp;&amp; !data.FileMode.IsNull() </span><span class="cov0" title="0">{
                config.FileMode = data.FileMode.ValueString()
        }</span>

        <span class="cov0" title="0">return config, fileops.ValidatePermissionConfig(config)</span>
}

// executePostCommands executes post-creation/update commands.
func executePostCommands(ctx context.Context, commands types.List, operation string) error <span class="cov7" title="10">{
        if commands.IsNull() || commands.IsUnknown() </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="9">tflog.Debug(ctx, fmt.Sprintf("Executing %s commands", operation))

        elements := commands.Elements()
        for i, cmdValue := range elements </span><span class="cov8" title="13">{
                if strCmd, ok := cmdValue.(types.String); ok </span><span class="cov8" title="13">{
                        cmd := strCmd.ValueString()
                        tflog.Debug(ctx, fmt.Sprintf("Executing %s command %d: %s", operation, i+1, cmd))

                        if err := executeShellCommand(ctx, cmd); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("command %d failed: %w", i+1, err)
                        }</span>
                }
        }

        <span class="cov6" title="8">return nil</span>
}

// processEnhancedTemplate processes a template with enhanced features.
func (r *FileResource) processEnhancedTemplate(sourcePath, targetPath string, config *EnhancedTemplateConfig, permConfig *fileops.PermissionConfig) error <span class="cov0" title="0">{
        // Create template engine based on configuration
        var engine template.TemplateEngine
        var err error

        if len(config.CustomFunctions) &gt; 0 </span><span class="cov0" title="0">{
                engine, err = template.CreateTemplateEngineWithFunctions(config.Engine, config.CustomFunctions)
        }</span> else<span class="cov0" title="0"> {
                engine, err = template.CreateTemplateEngine(config.Engine)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create template engine: %w", err)
        }</span>

        // Build comprehensive template context
        <span class="cov0" title="0">systemInfo := r.client.GetPlatformInfo()
        templateContext := template.BuildPlatformAwareTemplateContext(
                systemInfo,
                config.UserVars,
                config.PlatformVars,
        )

        // Process template file
        err = engine.ProcessTemplateFile(sourcePath, targetPath, templateContext, permConfig.FileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process template file: %w", err)
        }</span>

        // Apply permissions after template processing
        <span class="cov0" title="0">err = r.fileManager().ApplyPermissions(targetPath, permConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply permissions after template processing: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// fileManager creates a file manager instance for this resource.
func (r *FileResource) fileManager() *fileops.FileManager <span class="cov0" title="0">{
        platformProvider := platform.DetectPlatform()
        return fileops.NewFileManager(platformProvider, r.client.Config.DryRun)
}</span>

// Application detection functionality has been removed from the file resource.
// Use terraform-provider-package for application installation management
// and dependency checking.

// Version compatibility checking has been removed as it's now handled by terraform-provider-package

// executeShellCommand executes a shell command safely.
func executeShellCommand(ctx context.Context, cmdStr string) error <span class="cov10" title="27">{
        // Parse command and arguments
        parts := strings.Fields(cmdStr)
        if len(parts) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("empty command")
        }</span>

        // Use shell to execute complex commands
        <span class="cov9" title="26">var cmd *exec.Cmd

        // Determine shell based on OS
        var shell, shellFlag string
        if strings.Contains(os.Getenv("SHELL"), "fish") </span><span class="cov9" title="26">{
                shell = "fish"
                shellFlag = "-c"
        }</span> else<span class="cov0" title="0"> if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                shell = "cmd"
                shellFlag = "/c"
        }</span> else<span class="cov0" title="0"> {
                shell = "sh"
                shellFlag = "-c"
        }</span>

        <span class="cov9" title="26">cmd = exec.CommandContext(ctx, shell, shellFlag, cmdStr)

        // Set environment variables
        cmd.Env = os.Environ()

        // Capture output
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov4" title="3">{
                tflog.Error(ctx, fmt.Sprintf("Command failed: %s", cmdStr), map[string]interface{}{
                        "error":  err.Error(),
                        "output": string(output),
                })
                return fmt.Errorf("command '%s' failed: %w (output: %s)", cmdStr, err, string(output))
        }</span>

        <span class="cov9" title="23">tflog.Info(ctx, fmt.Sprintf("Command executed successfully: %s", cmdStr), map[string]interface{}{
                "output": string(output),
        })

        return nil</span>
}

// validateSourceFileExists checks if the source file exists and is readable.
func (r *FileResource) validateSourceFileExists(ctx context.Context, sourcePath string) error <span class="cov4" title="4">{
        // Check if source file exists
        info, err := os.Stat(sourcePath)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                return fmt.Errorf("source file '%s' does not exist", sourcePath)
        }</span>
        <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot access source file '%s': %w", sourcePath, err)
        }</span>

        // Check if it's a regular file (not a directory or special file)
        <span class="cov4" title="3">if !info.Mode().IsRegular() </span><span class="cov1" title="1">{
                return fmt.Errorf("source path '%s' is not a regular file (mode: %s)", sourcePath, info.Mode().String())
        }</span>

        // Check if file is readable by attempting to open it
        <span class="cov2" title="2">file, err := os.Open(sourcePath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("source file '%s' is not readable: %w", sourcePath, err)
        }</span>
        <span class="cov1" title="1">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                tflog.Warn(ctx, "Failed to close file", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "fmt"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// PermissionsModel defines the permissions configuration block.
type PermissionsModel struct {
        Directory types.String `tfsdk:"directory"`
        Files     types.String `tfsdk:"files"`
        Recursive types.Bool   `tfsdk:"recursive"`
}

// EnhancedFileResourceModel extends FileResourceModel with permission management.
type EnhancedFileResourceModel struct {
        FileResourceModel
        Permissions     *PermissionsModel `tfsdk:"permissions"`
        PermissionRules types.Map         `tfsdk:"permission_rules"`

        // Post-creation hooks (Priority 2 feature)
        PostCreateCommands types.List `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List `tfsdk:"pre_destroy_commands"`
}

// EnhancedSymlinkResourceModel extends SymlinkResourceModel with permission management.
type EnhancedSymlinkResourceModel struct {
        SymlinkResourceModel
        Permissions     *PermissionsModel `tfsdk:"permissions"`
        PermissionRules types.Map         `tfsdk:"permission_rules"`

        // Post-creation hooks (Priority 2 feature)
        PostCreateCommands types.List `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List `tfsdk:"pre_destroy_commands"`
}

// GetPermissionsSchemaBlock returns the schema block for permissions.
func GetPermissionsSchemaBlock() schema.SingleNestedBlock <span class="cov6" title="6">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Permission management for files and directories",
                Attributes: map[string]schema.Attribute{
                        "directory": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("0755"),
                                MarkdownDescription: "Directory permission mode (e.g., '0755')",
                        },
                        "files": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("0644"),
                                MarkdownDescription: "File permission mode (e.g., '0644')",
                        },
                        "recursive": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Apply permissions recursively to subdirectories and files",
                        },
                },
        }
}</span>

// GetPermissionRulesAttribute returns the schema attribute for permission rules.
func GetPermissionRulesAttribute() schema.MapAttribute <span class="cov6" title="6">{
        return schema.MapAttribute{
                Optional:            true,
                ElementType:         types.StringType,
                MarkdownDescription: "Pattern-based permission rules (e.g., 'id_*' = '0600')",
        }
}</span>

// GetPostHooksAttributes returns the schema attributes for post-creation hooks.
func GetPostHooksAttributes() map[string]schema.Attribute <span class="cov6" title="6">{
        return map[string]schema.Attribute{
                "post_create_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute after resource creation",
                },
                "post_update_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute after resource update",
                },
                "pre_destroy_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute before resource destruction",
                },
        }
}</span>

// parsePermission parses a permission string (e.g., "0644") to uint32.
func parsePermission(perm string) (uint32, error) <span class="cov8" title="10">{
        if perm == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("permission cannot be empty")
        }</span>

        // Remove leading zeros for parsing, but preserve them for validation
        <span class="cov8" title="10">trimmed := strings.TrimLeft(perm, "0")
        if trimmed == "" </span><span class="cov0" title="0">{
                trimmed = "0"
        }</span>

        // Parse as octal
        <span class="cov8" title="10">parsed, err := strconv.ParseUint(trimmed, 8, 32)
        if err != nil </span><span class="cov3" title="2">{
                return 0, fmt.Errorf("invalid permission format %q: %w", perm, err)
        }</span>

        // Validate permission range (0-777)
        <span class="cov7" title="8">if parsed &gt; 0777 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("permission %q is out of valid range (0-777)", perm)
        }</span>

        <span class="cov7" title="8">return uint32(parsed), nil</span>
}

// matchesPermissionPattern checks if a filename matches a permission rule pattern.
func matchesPermissionPattern(pattern, filename string) bool <span class="cov10" title="17">{
        // Simple glob matching - can be enhanced with more sophisticated patterns
        matched, err := filepath.Match(pattern, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="17">return matched</span>
}

// isMoreSpecific determines if pattern1 is more specific than pattern2.
func isMoreSpecific(pattern1, pattern2 string) bool <span class="cov0" title="0">{
        // Count wildcards - fewer wildcards means more specific
        wildcards1 := strings.Count(pattern1, "*") + strings.Count(pattern1, "?")
        wildcards2 := strings.Count(pattern2, "*") + strings.Count(pattern2, "?")

        if wildcards1 != wildcards2 </span><span class="cov0" title="0">{
                return wildcards1 &lt; wildcards2
        }</span>

        // If same number of wildcards, prefer exact character matches
        <span class="cov0" title="0">exactChars1 := len(pattern1) - wildcards1
        exactChars2 := len(pattern2) - wildcards2

        return exactChars1 &gt; exactChars2</span>
}

// ApplyPermissionRules applies permission rules to a file based on patterns.
func ApplyPermissionRules(filename string, rules types.Map, defaultPerm string) (string, error) <span class="cov5" title="4">{
        if rules.IsNull() || rules.IsUnknown() </span><span class="cov0" title="0">{
                return defaultPerm, nil
        }</span>

        <span class="cov5" title="4">elements := rules.Elements()
        bestMatch := ""
        bestPerm := ""

        // Find the most specific pattern match
        for pattern, permValue := range elements </span><span class="cov8" title="12">{
                if strPerm, ok := permValue.(types.String); ok </span><span class="cov8" title="12">{
                        if matchesPermissionPattern(pattern, filename) </span><span class="cov5" title="4">{
                                // Prefer more specific patterns (patterns with more characters are generally more specific)
                                if bestMatch == "" || len(pattern) &gt; len(bestMatch) || isMoreSpecific(pattern, bestMatch) </span><span class="cov5" title="4">{
                                        // Validate the permission
                                        if _, err := parsePermission(strPerm.ValueString()); err != nil </span><span class="cov0" title="0">{
                                                return defaultPerm, fmt.Errorf("invalid permission in rule %s: %w", pattern, err)
                                        }</span>
                                        <span class="cov5" title="4">bestMatch = pattern
                                        bestPerm = strPerm.ValueString()</span>
                                }
                        }
                }
        }

        <span class="cov5" title="4">if bestMatch != "" </span><span class="cov4" title="3">{
                return bestPerm, nil
        }</span>

        <span class="cov1" title="1">return defaultPerm, nil</span>
}

// ValidatePermissionsModel validates the permissions configuration.
func ValidatePermissionsModel(permissions *PermissionsModel) error <span class="cov0" title="0">{
        if permissions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate directory permission
        <span class="cov0" title="0">if !permissions.Directory.IsNull() </span><span class="cov0" title="0">{
                if _, err := parsePermission(permissions.Directory.ValueString()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory permission: %w", err)
                }</span>
        }

        // Validate file permission
        <span class="cov0" title="0">if !permissions.Files.IsNull() </span><span class="cov0" title="0">{
                if _, err := parsePermission(permissions.Files.ValueString()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid files permission: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidatePermissionRules validates permission rules map.
func ValidatePermissionRules(rules types.Map) error <span class="cov0" title="0">{
        if rules.IsNull() || rules.IsUnknown() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">elements := rules.Elements()
        for pattern, permValue := range elements </span><span class="cov0" title="0">{
                if strPerm, ok := permValue.(types.String); ok </span><span class="cov0" title="0">{
                        if _, err := parsePermission(strPerm.ValueString()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid permission in rule %s: %w", pattern, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("permission rule %s has invalid type", pattern)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/ephemeral"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// Ensure DotfilesProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;DotfilesProvider{}

// DotfilesProvider defines the provider implementation.
type DotfilesProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// DotfilesProviderModel describes the provider data model.
type DotfilesProviderModel struct {
        DotfilesRoot       types.String         `tfsdk:"dotfiles_root"`
        BackupEnabled      types.Bool           `tfsdk:"backup_enabled"`
        BackupDirectory    types.String         `tfsdk:"backup_directory"`
        Strategy           types.String         `tfsdk:"strategy"`
        ConflictResolution types.String         `tfsdk:"conflict_resolution"`
        DryRun             types.Bool           `tfsdk:"dry_run"`
        AutoDetectPlatform types.Bool           `tfsdk:"auto_detect_platform"`
        TargetPlatform     types.String         `tfsdk:"target_platform"`
        TemplateEngine     types.String         `tfsdk:"template_engine"`
        LogLevel           types.String         `tfsdk:"log_level"`
        BackupStrategy     *BackupStrategyModel `tfsdk:"backup_strategy"`
        Recovery           *RecoveryModel       `tfsdk:"recovery"`
}

func (p *DotfilesProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov3" title="2">{
        resp.TypeName = "dotfiles"
        resp.Version = p.version
}</span>

func (p *DotfilesProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov5" title="3">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Terraform provider for managing dotfiles in a declarative, cross-platform manner.",
                Attributes: map[string]schema.Attribute{
                        "dotfiles_root": schema.StringAttribute{
                                MarkdownDescription: "Root directory of the dotfiles repository. Defaults to ~/dotfiles",
                                Optional:            true,
                        },
                        "backup_enabled": schema.BoolAttribute{
                                MarkdownDescription: "Enable automatic backups of existing files before modification. Defaults to true",
                                Optional:            true,
                        },
                        "backup_directory": schema.StringAttribute{
                                MarkdownDescription: "Directory to store backup files. Defaults to ~/.dotfiles-backups",
                                Optional:            true,
                        },
                        "strategy": schema.StringAttribute{
                                MarkdownDescription: "Default strategy for file management: symlink (default), copy, or template",
                                Optional:            true,
                        },
                        "conflict_resolution": schema.StringAttribute{
                                MarkdownDescription: "How to handle conflicts: backup (default), overwrite, skip, or prompt",
                                Optional:            true,
                        },
                        "dry_run": schema.BoolAttribute{
                                MarkdownDescription: "Preview changes without applying them. Defaults to false",
                                Optional:            true,
                        },
                        "auto_detect_platform": schema.BoolAttribute{
                                MarkdownDescription: "Automatically detect the target platform. Defaults to true",
                                Optional:            true,
                        },
                        "target_platform": schema.StringAttribute{
                                MarkdownDescription: "Target platform: auto (default), macos, linux, or windows",
                                Optional:            true,
                        },
                        "template_engine": schema.StringAttribute{
                                MarkdownDescription: "Template engine to use: go (default), handlebars, or mustache",
                                Optional:            true,
                                Validators: []validator.String{
                                        validators.ValidTemplateEngine(),
                                },
                        },
                        "log_level": schema.StringAttribute{
                                MarkdownDescription: "Log level: debug, info (default), warn, or error",
                                Optional:            true,
                        },
                },
                Blocks: map[string]schema.Block{
                        "backup_strategy": GetBackupStrategySchemaBlock(),
                        "recovery":        GetRecoverySchemaBlock(),
                },
        }
}</span>

func (p *DotfilesProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{
        var data EnhancedProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create and configure the client
        <span class="cov0" title="0">config := &amp;DotfilesConfig{}

        // Set configuration values from provider data
        if !data.DotfilesRoot.IsNull() </span><span class="cov0" title="0">{
                config.DotfilesRoot = data.DotfilesRoot.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                config.BackupEnabled = data.BackupEnabled.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.BackupEnabled = true // default to true
        }</span>

        <span class="cov0" title="0">if !data.BackupDirectory.IsNull() </span><span class="cov0" title="0">{
                config.BackupDirectory = data.BackupDirectory.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.Strategy.IsNull() </span><span class="cov0" title="0">{
                config.Strategy = data.Strategy.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.ConflictResolution.IsNull() </span><span class="cov0" title="0">{
                config.ConflictResolution = data.ConflictResolution.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.DryRun.IsNull() </span><span class="cov0" title="0">{
                config.DryRun = data.DryRun.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.DryRun = false
        }</span>

        <span class="cov0" title="0">if !data.AutoDetectPlatform.IsNull() </span><span class="cov0" title="0">{
                config.AutoDetectPlatform = data.AutoDetectPlatform.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.AutoDetectPlatform = true
        }</span>

        <span class="cov0" title="0">if !data.TargetPlatform.IsNull() </span><span class="cov0" title="0">{
                config.TargetPlatform = data.TargetPlatform.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.TemplateEngine.IsNull() </span><span class="cov0" title="0">{
                config.TemplateEngine = data.TemplateEngine.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.LogLevel.IsNull() </span><span class="cov0" title="0">{
                config.LogLevel = data.LogLevel.ValueString()
        }</span>

        // Set defaults for any empty values
        <span class="cov0" title="0">if err := config.SetDefaults(); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to set configuration defaults",
                        "An error occurred while setting default configuration values: "+err.Error(),
                )
                return
        }</span>

        // Handle backup strategy configuration
        <span class="cov0" title="0">if data.BackupStrategy != nil </span><span class="cov0" title="0">{
                // Warn if both top-level and backup_strategy block are used
                if !data.BackupEnabled.IsNull() &amp;&amp; !data.BackupStrategy.Enabled.IsNull() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Conflicting backup configuration",
                                "Both top-level 'backup_enabled' and 'backup_strategy.enabled' are set. The backup_strategy block takes precedence.",
                        )
                }</span>
                <span class="cov0" title="0">if !data.BackupDirectory.IsNull() &amp;&amp; !data.BackupStrategy.Directory.IsNull() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Conflicting backup directory configuration",
                                "Both top-level 'backup_directory' and 'backup_strategy.directory' are set. The backup_strategy block takes precedence.",
                        )
                }</span>

                // Apply backup strategy configuration (overrides top-level settings)
                <span class="cov0" title="0">if !data.BackupStrategy.Enabled.IsNull() </span><span class="cov0" title="0">{
                        config.BackupEnabled = data.BackupStrategy.Enabled.ValueBool()
                }</span>
                <span class="cov0" title="0">if !data.BackupStrategy.Directory.IsNull() </span><span class="cov0" title="0">{
                        config.BackupDirectory = data.BackupStrategy.Directory.ValueString()
                }</span>
                // Additional backup strategy fields can be handled here as needed
                // For now, we keep the existing simple backup configuration approach
        }

        // Handle recovery configuration
        <span class="cov0" title="0">if data.Recovery != nil </span><span class="cov0" title="0">{
                // Recovery configuration is mainly used by resources
                // Log that recovery features are enabled if configured
                if !data.Recovery.CreateRestoreScripts.IsNull() &amp;&amp; data.Recovery.CreateRestoreScripts.ValueBool() </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Recovery restore scripts enabled")
                }</span>
                <span class="cov0" title="0">if !data.Recovery.ValidateBackups.IsNull() &amp;&amp; data.Recovery.ValidateBackups.ValueBool() </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Backup validation enabled")
                }</span>
        }

        // Validate configuration
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid provider configuration",
                        "The provider configuration is invalid: "+err.Error(),
                )
                return
        }</span>

        // Create the client
        <span class="cov0" title="0">client, err := NewDotfilesClient(config)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create dotfiles client",
                        "An error occurred while creating the dotfiles client: "+err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Configured dotfiles provider", map[string]interface{}{
                "dotfiles_root":   config.DotfilesRoot,
                "backup_enabled":  config.BackupEnabled,
                "strategy":        config.Strategy,
                "target_platform": config.TargetPlatform,
                "dry_run":         config.DryRun,
        })

        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

func (p *DotfilesProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov3" title="2">{
        return []func() resource.Resource{
                NewRepositoryResource,
                NewFileResource,
                NewSymlinkResource,
                NewDirectoryResource,
                NewApplicationResource,
        }
}</span>

func (p *DotfilesProvider) EphemeralResources(ctx context.Context) []func() ephemeral.EphemeralResource <span class="cov1" title="1">{
        return []func() ephemeral.EphemeralResource{
                // No ephemeral resources planned for initial implementation
        }
}</span>

func (p *DotfilesProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov3" title="2">{
        return []func() datasource.DataSource{
                NewSystemDataSource,
                NewFileInfoDataSource,
        }
}</span>

func (p *DotfilesProvider) Functions(ctx context.Context) []func() function.Function <span class="cov1" title="1">{
        return []func() function.Function{
                // Functions will be added in later phases
        }
}</span>

func New(version string) func() provider.Provider <span class="cov10" title="10">{
        return func() provider.Provider </span><span class="cov10" title="10">{
                return &amp;DotfilesProvider{
                        version: version,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/git"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;RepositoryResource{}

func NewRepositoryResource() resource.Resource <span class="cov10" title="5">{
        return &amp;RepositoryResource{}
}</span>

// RepositoryResource defines the resource implementation.
type RepositoryResource struct {
        client *DotfilesClient
}

// RepositoryResourceModel describes the resource data model.
type RepositoryResourceModel struct {
        ID                   types.String `tfsdk:"id"`
        Name                 types.String `tfsdk:"name"`
        SourcePath           types.String `tfsdk:"source_path"`
        Description          types.String `tfsdk:"description"`
        DefaultBackupEnabled types.Bool   `tfsdk:"default_backup_enabled"`
        DefaultFileMode      types.String `tfsdk:"default_file_mode"`
        DefaultDirMode       types.String `tfsdk:"default_dir_mode"`

        // Git-specific attributes
        GitBranch              types.String `tfsdk:"git_branch"`
        GitPersonalAccessToken types.String `tfsdk:"git_personal_access_token"`
        GitUsername            types.String `tfsdk:"git_username"`
        GitSSHPrivateKeyPath   types.String `tfsdk:"git_ssh_private_key_path"`
        GitSSHPassphrase       types.String `tfsdk:"git_ssh_passphrase"`
        GitUpdateInterval      types.String `tfsdk:"git_update_interval"`

        // Computed attributes
        LocalPath  types.String `tfsdk:"local_path"`
        LastCommit types.String `tfsdk:"last_commit"`
        LastUpdate types.String `tfsdk:"last_update"`
}

func (r *RepositoryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_repository"
}</span>

func (r *RepositoryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages a dotfiles repository configuration. Supports both local paths and Git repositories (GitHub, GitLab, etc.)",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Repository identifier",
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Repository name",
                        },
                        "source_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the dotfiles repository. Can be a local path or Git URL (e.g., 'https://github.com/user/dotfiles.git')",
                        },
                        "description": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Repository description",
                        },
                        "default_backup_enabled": schema.BoolAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default backup setting for resources in this repository",
                        },
                        "default_file_mode": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default file permissions (e.g., '0644')",
                        },
                        "default_dir_mode": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default directory permissions (e.g., '0755')",
                        },

                        // Git-specific attributes
                        "git_branch": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Git branch to checkout (defaults to repository default branch)",
                        },
                        "git_personal_access_token": schema.StringAttribute{
                                Optional:            true,
                                Sensitive:           true,
                                MarkdownDescription: "GitHub Personal Access Token for private repository authentication",
                        },
                        "git_username": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Username for Git authentication (optional when using PAT)",
                        },
                        "git_ssh_private_key_path": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Path to SSH private key for Git authentication",
                        },
                        "git_ssh_passphrase": schema.StringAttribute{
                                Optional:            true,
                                Sensitive:           true,
                                MarkdownDescription: "Passphrase for SSH private key",
                        },
                        "git_update_interval": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Interval to check for updates (e.g., '1h', '30m'). Use 'never' to disable automatic updates",
                        },

                        // Computed attributes
                        "local_path": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Local path where the repository is stored",
                        },
                        "last_commit": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "SHA of the last commit",
                        },
                        "last_update": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Timestamp of the last repository update",
                        },
                },
        }
}</span>

func (r *RepositoryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov7" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov4" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else. Please report this issue to the provider developers.",
                )
                return
        }</span>

        <span class="cov1" title="1">r.client = client</span>
}

func (r *RepositoryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        tflog.Debug(ctx, "=== REPOSITORY CREATE START ===")
        tflog.Debug(ctx, "Getting plan data from request")
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get plan data", map[string]interface{}{
                        "diagnostics_count": len(resp.Diagnostics),
                })
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating repository resource", map[string]interface{}{
                "name":                   data.Name.ValueString(),
                "source_path":            data.SourcePath.ValueString(),
                "description":            data.Description.ValueString(),
                "default_backup_enabled": data.DefaultBackupEnabled.ValueBool(),
                "default_file_mode":      data.DefaultFileMode.ValueString(),
                "default_dir_mode":       data.DefaultDirMode.ValueString(),
                "git_branch":             data.GitBranch.ValueString(),
                "git_update_interval":    data.GitUpdateInterval.ValueString(),
        })

        sourcePath := data.SourcePath.ValueString()
        tflog.Debug(ctx, "Processing source path", map[string]interface{}{
                "raw_source_path": sourcePath,
        })

        // Check if source is a Git URL
        isGitURL := git.IsGitURL(sourcePath)
        tflog.Debug(ctx, "Checking source type", map[string]interface{}{
                "is_git_url":  isGitURL,
                "source_path": sourcePath,
        })

        if isGitURL </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Processing as Git repository")
                // Handle Git repository
                info, err := r.setupGitRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Git repository setup failed", map[string]interface{}{
                                "error":       err.Error(),
                                "source_path": sourcePath,
                        })
                        resp.Diagnostics.AddError(
                                "Failed to setup Git repository",
                                fmt.Sprintf("Could not clone or setup Git repository: %s", err.Error()),
                        )
                        return
                }</span>

                // Update model with Git info
                <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                data.LastCommit = types.StringValue(info.LastCommit)
                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))

                tflog.Info(ctx, "Git repository cloned successfully", map[string]interface{}{
                        "url":         info.URL,
                        "local_path":  info.LocalPath,
                        "last_commit": info.LastCommit,
                        "last_update": data.LastUpdate.ValueString(),
                })</span>
        } else<span class="cov0" title="0"> {
                tflog.Debug(ctx, "Processing as local repository")
                // Handle local repository
                err := r.setupLocalRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Local repository setup failed", map[string]interface{}{
                                "error":       err.Error(),
                                "source_path": sourcePath,
                        })
                        resp.Diagnostics.AddError(
                                "Failed to setup local repository",
                                fmt.Sprintf("Could not setup local repository: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.LocalPath = data.SourcePath
                data.LastUpdate = types.StringValue(time.Now().Format(time.RFC3339))

                // Check if local repository is a Git repository and get commit info
                localPath := data.SourcePath.ValueString()

                tflog.Debug(ctx, "Checking if repository is a Git repository", map[string]interface{}{
                        "local_path": localPath,
                })

                isGitRepo := r.isGitRepository(localPath)
                tflog.Debug(ctx, "Git repository detection result", map[string]interface{}{
                        "local_path": localPath,
                        "is_git":     isGitRepo,
                })

                if isGitRepo </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Creating Git manager for local repository", map[string]interface{}{
                                "local_path": localPath,
                        })

                        gitManager, err := git.NewGitManager(nil) // No auth needed for local repos
                        if err == nil </span><span class="cov0" title="0">{
                                tflog.Debug(ctx, "Git manager created successfully, retrieving repository info", map[string]interface{}{
                                        "local_path": localPath,
                                })

                                info, err := gitManager.GetRepositoryInfo(localPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        data.LastCommit = types.StringValue(info.LastCommit)
                                        tflog.Info(ctx, "Successfully retrieved Git info for local repository", map[string]interface{}{
                                                "local_path":  localPath,
                                                "last_commit": info.LastCommit,
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        tflog.Error(ctx, "Failed to get Git repository info", map[string]interface{}{
                                                "error":      err.Error(),
                                                "local_path": localPath,
                                        })
                                        // Set empty but valid commit for repositories with Git issues
                                        data.LastCommit = types.StringValue("")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tflog.Error(ctx, "Failed to create Git manager", map[string]interface{}{
                                        "error":      err.Error(),
                                        "local_path": localPath,
                                })
                                data.LastCommit = types.StringValue("")
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "Repository is not a Git repository, setting empty commit", map[string]interface{}{
                                "local_path": localPath,
                        })
                        // Not a Git repository, set empty but valid commit
                        data.LastCommit = types.StringValue("")
                }</span>

                <span class="cov0" title="0">tflog.Info(ctx, "Local repository setup successfully", map[string]interface{}{
                        "source_path": sourcePath,
                        "local_path":  data.LocalPath.ValueString(),
                        "last_commit": data.LastCommit.ValueString(),
                        "last_update": data.LastUpdate.ValueString(),
                })</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        // Check if this is a Git repository
        sourcePath := data.SourcePath.ValueString()
        if git.IsGitURL(sourcePath) </span><span class="cov0" title="0">{
                // Handle Git repository
                if !data.LocalPath.IsNull() </span><span class="cov0" title="0">{
                        localPath := data.LocalPath.ValueString()

                        // Check if local repository still exists
                        if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                                // Get current repository info
                                authConfig := r.buildAuthConfig(&amp;data)
                                gitManager, err := git.NewGitManager(authConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        tflog.Warn(ctx, "Failed to create Git manager during read", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        info, err := gitManager.GetRepositoryInfo(localPath)
                                        if err == nil </span><span class="cov0" title="0">{
                                                // Update computed attributes
                                                data.LastCommit = types.StringValue(info.LastCommit)
                                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))
                                        }</span> else<span class="cov0" title="0"> {
                                                tflog.Warn(ctx, "Failed to get repository info", map[string]interface{}{
                                                        "error": err.Error(),
                                                })
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                tflog.Warn(ctx, "Local repository path no longer exists", map[string]interface{}{
                                        "local_path": localPath,
                                })
                                // Repository was deleted externally, mark for recreation
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle local repository - just verify it still exists
                localPath := data.LocalPath.ValueString()
                if localPath == "" </span><span class="cov0" title="0">{
                        localPath = sourcePath
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(localPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Local repository not found",
                                fmt.Sprintf("The local repository at %s no longer exists.", localPath),
                        )
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        sourcePath := data.SourcePath.ValueString()

        // Check if source is a Git URL and needs updating
        if git.IsGitURL(sourcePath) </span><span class="cov0" title="0">{
                // Handle Git repository update
                if !data.LocalPath.IsNull() </span><span class="cov0" title="0">{
                        localPath := data.LocalPath.ValueString()

                        // Check if local repository exists
                        if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                                // Update the repository
                                authConfig := r.buildAuthConfig(&amp;data)
                                gitManager, err := git.NewGitManager(authConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to create Git manager",
                                                fmt.Sprintf("Could not create Git manager for update: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                <span class="cov0" title="0">info, err := gitManager.UpdateRepository(ctx, localPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to update Git repository",
                                                fmt.Sprintf("Could not update Git repository: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                // Update computed attributes
                                <span class="cov0" title="0">data.LastCommit = types.StringValue(info.LastCommit)
                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))

                                tflog.Info(ctx, "Git repository updated successfully", map[string]interface{}{
                                        "local_path":  info.LocalPath,
                                        "last_commit": info.LastCommit,
                                })</span>
                        } else<span class="cov0" title="0"> {
                                // Repository doesn't exist locally, re-create it
                                tflog.Info(ctx, "Local repository not found, re-cloning", map[string]interface{}{
                                        "local_path": localPath,
                                })

                                info, err := r.setupGitRepository(ctx, &amp;data)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to re-setup Git repository",
                                                fmt.Sprintf("Could not re-clone Git repository: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                // Update model with Git info
                                <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                                data.LastCommit = types.StringValue(info.LastCommit)
                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // No local path set, treat as new setup
                        info, err := r.setupGitRepository(ctx, &amp;data)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        "Failed to setup Git repository",
                                        fmt.Sprintf("Could not setup Git repository: %s", err.Error()),
                                )
                                return
                        }</span>

                        // Update model with Git info
                        <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                        data.LastCommit = types.StringValue(info.LastCommit)
                        data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle local repository update
                err := r.setupLocalRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Failed to update local repository",
                                fmt.Sprintf("Could not update local repository: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.LocalPath = data.SourcePath
                data.LastUpdate = types.StringValue(time.Now().Format(time.RFC3339))

                // Check if local repository is a Git repository and get commit info
                localPath := data.SourcePath.ValueString()
                if r.isGitRepository(localPath) </span><span class="cov0" title="0">{
                        gitManager, err := git.NewGitManager(nil) // No auth needed for local repos
                        if err == nil </span><span class="cov0" title="0">{
                                info, err := gitManager.GetRepositoryInfo(localPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        data.LastCommit = types.StringValue(info.LastCommit)
                                        tflog.Debug(ctx, "Retrieved Git info for local repository update", map[string]interface{}{
                                                "local_path":  localPath,
                                                "last_commit": info.LastCommit,
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        tflog.Warn(ctx, "Failed to get Git info for local repository update", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                        // Set empty but valid commit for non-Git local repos
                                        data.LastCommit = types.StringValue("")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.LastCommit = types.StringValue("")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not a Git repository, set empty but valid commit
                        data.LastCommit = types.StringValue("")
                }</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        // For dotfiles repositories, we typically don't delete the actual files,
        // just remove them from Terraform state. The local cache will remain.
        tflog.Info(ctx, "Repository resource removed from state", map[string]interface{}{
                "name": data.Name.ValueString(),
        })</span>
}

// setupGitRepository handles cloning and setting up a Git repository.
func (r *RepositoryResource) setupGitRepository(ctx context.Context, data *RepositoryResourceModel) (*git.RepositoryInfo, error) <span class="cov0" title="0">{
        sourcePath := data.SourcePath.ValueString()

        // Create authentication config
        authConfig := &amp;git.AuthConfig{}

        // Configure PAT authentication
        if !data.GitPersonalAccessToken.IsNull() </span><span class="cov0" title="0">{
                authConfig.PersonalAccessToken = data.GitPersonalAccessToken.ValueString()
                if !data.GitUsername.IsNull() </span><span class="cov0" title="0">{
                        authConfig.Username = data.GitUsername.ValueString()
                }</span>
        }

        // Configure SSH authentication
        <span class="cov0" title="0">if !data.GitSSHPrivateKeyPath.IsNull() </span><span class="cov0" title="0">{
                authConfig.SSHPrivateKeyPath = data.GitSSHPrivateKeyPath.ValueString()
                if !data.GitSSHPassphrase.IsNull() </span><span class="cov0" title="0">{
                        authConfig.SSHPassphrase = data.GitSSHPassphrase.ValueString()
                }</span>
        }

        // Check for environment variable PAT if not provided
        <span class="cov0" title="0">if authConfig.PersonalAccessToken == "" </span><span class="cov0" title="0">{
                if envPAT := os.Getenv("GITHUB_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                        tflog.Debug(ctx, "Using GitHub token from GITHUB_TOKEN environment variable")
                }</span> else<span class="cov0" title="0"> if envPAT := os.Getenv("GH_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                        tflog.Debug(ctx, "Using GitHub token from GH_TOKEN environment variable")
                }</span>
        }

        // Create Git manager
        <span class="cov0" title="0">gitManager, err := git.NewGitManager(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Git manager: %w", err)
        }</span>

        // Determine local cache path
        <span class="cov0" title="0">cacheRoot := filepath.Join(r.client.HomeDir, ".terraform-dotfiles-cache")
        localPath, err := git.GetLocalCachePath(cacheRoot, sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine cache path: %w", err)
        }</span>

        // Check if repository already exists locally
        <span class="cov0" title="0">if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                // Repository exists, try to update it
                tflog.Debug(ctx, "Repository already exists locally, updating", map[string]interface{}{
                        "local_path": localPath,
                })

                info, err := gitManager.UpdateRepository(ctx, localPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to update existing repository, will re-clone", map[string]interface{}{
                                "error": err.Error(),
                        })

                        // Remove existing directory and re-clone
                        if err := os.RemoveAll(localPath); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to remove existing repository: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return info, nil
                }</span>
        }

        // Clone repository
        <span class="cov0" title="0">branch := ""
        if !data.GitBranch.IsNull() </span><span class="cov0" title="0">{
                branch = data.GitBranch.ValueString()
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Cloning Git repository", map[string]interface{}{
                "url":        sourcePath,
                "local_path": localPath,
                "branch":     branch,
        })

        info, err := gitManager.CloneRepository(ctx, sourcePath, localPath, branch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// setupLocalRepository handles validation of a local repository.
func (r *RepositoryResource) setupLocalRepository(ctx context.Context, data *RepositoryResourceModel) error <span class="cov8" title="4">{
        tflog.Debug(ctx, "=== SETUP LOCAL REPOSITORY START ===")

        sourcePath := data.SourcePath.ValueString()
        tflog.Debug(ctx, "Initial source path", map[string]interface{}{
                "source_path": sourcePath,
                "home_dir":    r.client.HomeDir,
        })

        // Expand the path
        originalPath := sourcePath
        if sourcePath[0] == '~' </span><span class="cov1" title="1">{
                sourcePath = filepath.Join(r.client.HomeDir, sourcePath[1:])
                tflog.Debug(ctx, "Expanded tilde path", map[string]interface{}{
                        "original_path": originalPath,
                        "expanded_path": sourcePath,
                })
        }</span>

        // Convert to absolute path
        <span class="cov8" title="4">absPath, err := filepath.Abs(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get absolute path", map[string]interface{}{
                        "error":       err.Error(),
                        "source_path": sourcePath,
                })
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>
        <span class="cov8" title="4">tflog.Debug(ctx, "Converted to absolute path", map[string]interface{}{
                "source_path": sourcePath,
                "abs_path":    absPath,
        })

        // Check if path exists
        tflog.Debug(ctx, "Checking if path exists", map[string]interface{}{
                "abs_path": absPath,
        })
        stat, err := os.Stat(absPath)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                tflog.Info(ctx, "Local repository directory does not exist, creating it", map[string]interface{}{
                        "abs_path":    absPath,
                        "permissions": "0755",
                })
                if err := os.MkdirAll(absPath, 0755); err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to create directory", map[string]interface{}{
                                "error":    err.Error(),
                                "abs_path": absPath,
                        })
                        return fmt.Errorf("failed to create local repository directory: %w", err)
                }</span>
                <span class="cov1" title="1">tflog.Debug(ctx, "Local repository directory created successfully", map[string]interface{}{
                        "abs_path": absPath,
                })

                // Re-stat the newly created directory
                stat, err = os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to stat newly created directory", map[string]interface{}{
                                "error":    err.Error(),
                                "abs_path": absPath,
                        })
                        return fmt.Errorf("failed to stat newly created path: %w", err)
                }</span>
                <span class="cov1" title="1">tflog.Debug(ctx, "Successfully re-statted created directory", map[string]interface{}{
                        "abs_path": absPath,
                        "is_dir":   stat.IsDir(),
                        "mode":     stat.Mode().String(),
                        "size":     stat.Size(),
                })</span>
        } else<span class="cov7" title="3"> if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to stat existing path", map[string]interface{}{
                        "error":    err.Error(),
                        "abs_path": absPath,
                })
                return fmt.Errorf("failed to stat path: %w", err)
        }</span> else<span class="cov7" title="3"> {
                tflog.Debug(ctx, "Path already exists", map[string]interface{}{
                        "abs_path": absPath,
                        "is_dir":   stat.IsDir(),
                        "mode":     stat.Mode().String(),
                        "size":     stat.Size(),
                })
        }</span>

        // Ensure it's a directory
        <span class="cov8" title="4">if !stat.IsDir() </span><span class="cov1" title="1">{
                tflog.Error(ctx, "Source path is not a directory", map[string]interface{}{
                        "abs_path": absPath,
                        "mode":     stat.Mode().String(),
                        "is_dir":   stat.IsDir(),
                })
                return fmt.Errorf("source path is not a directory: %s", absPath)
        }</span>

        <span class="cov7" title="3">tflog.Debug(ctx, "Local repository validated successfully", map[string]interface{}{
                "original_source_path": originalPath,
                "final_abs_path":       absPath,
                "is_directory":         true,
        })

        // Update source path to absolute path
        data.SourcePath = types.StringValue(absPath)
        tflog.Debug(ctx, "Updated source path in data model", map[string]interface{}{
                "new_source_path": absPath,
        })

        tflog.Debug(ctx, "=== SETUP LOCAL REPOSITORY END ===")
        return nil</span>
}

// buildAuthConfig creates authentication config from resource data.
func (r *RepositoryResource) buildAuthConfig(data *RepositoryResourceModel) *git.AuthConfig <span class="cov7" title="3">{
        authConfig := &amp;git.AuthConfig{}

        // Configure PAT authentication
        if !data.GitPersonalAccessToken.IsNull() </span><span class="cov1" title="1">{
                authConfig.PersonalAccessToken = data.GitPersonalAccessToken.ValueString()
                if !data.GitUsername.IsNull() </span><span class="cov1" title="1">{
                        authConfig.Username = data.GitUsername.ValueString()
                }</span>
        }

        // Configure SSH authentication
        <span class="cov7" title="3">if !data.GitSSHPrivateKeyPath.IsNull() </span><span class="cov1" title="1">{
                authConfig.SSHPrivateKeyPath = data.GitSSHPrivateKeyPath.ValueString()
                if !data.GitSSHPassphrase.IsNull() </span><span class="cov1" title="1">{
                        authConfig.SSHPassphrase = data.GitSSHPassphrase.ValueString()
                }</span>
        }

        // Check for environment variable PAT if not provided
        <span class="cov7" title="3">if authConfig.PersonalAccessToken == "" </span><span class="cov4" title="2">{
                if envPAT := os.Getenv("GITHUB_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                }</span> else<span class="cov4" title="2"> if envPAT := os.Getenv("GH_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                }</span>
        }

        <span class="cov7" title="3">return authConfig</span>
}

// isGitRepository checks if a local path contains a Git repository.
func (r *RepositoryResource) isGitRepository(localPath string) bool <span class="cov0" title="0">{
        gitDir := filepath.Join(localPath, ".git")

        stat, err := os.Stat(gitDir)
        if err != nil </span><span class="cov0" title="0">{
                // .git directory/file doesn't exist
                return false
        }</span>

        // .git exists, check if it's a directory (normal repo) or file (worktree/submodule)
        <span class="cov0" title="0">isGitRepo := stat.IsDir() || stat.Mode().IsRegular()
        return isGitRepo</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

var _ resource.Resource = &amp;SymlinkResource{}

func NewSymlinkResource() resource.Resource <span class="cov10" title="6">{
        return &amp;SymlinkResource{}
}</span>

type SymlinkResource struct {
        client *DotfilesClient
}

type SymlinkResourceModel struct {
        ID            types.String `tfsdk:"id"`
        Repository    types.String `tfsdk:"repository"`
        Name          types.String `tfsdk:"name"`
        SourcePath    types.String `tfsdk:"source_path"`
        TargetPath    types.String `tfsdk:"target_path"`
        ForceUpdate   types.Bool   `tfsdk:"force_update"`
        CreateParents types.Bool   `tfsdk:"create_parents"`

        // Enhanced fields
        Permissions        *PermissionsModel `tfsdk:"permissions"`
        PermissionRules    types.Map         `tfsdk:"permission_rules"`
        PostCreateCommands types.List        `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List        `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List        `tfsdk:"pre_destroy_commands"`

        // Computed attributes
        LinkExists   types.Bool   `tfsdk:"link_exists"`
        IsSymlink    types.Bool   `tfsdk:"is_symlink"`
        LinkTarget   types.String `tfsdk:"link_target"`
        LastModified types.String `tfsdk:"last_modified"`
}

func (r *SymlinkResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_symlink"
}</span>

func (r *SymlinkResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov4" title="2">{
        // Build base attributes
        baseAttributes := map[string]schema.Attribute{
                "id": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Symlink identifier",
                },
                "repository": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Repository ID this symlink belongs to",
                },
                "name": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Symlink name/identifier",
                },
                "source_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Path to source in repository",
                },
                "target_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Target symlink path",
                },
                "force_update": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Force update existing symlinks",
                },
                "create_parents": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Create parent directories",
                },
                "permission_rules": GetPermissionRulesAttribute(),
                "link_exists": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the symlink exists",
                },
                "is_symlink": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the target is actually a symlink",
                },
                "link_target": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "The target that the symlink points to",
                },
                "last_modified": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Last modification timestamp of the symlink",
                },
        }

        // Add post-hooks attributes
        postHooksAttrs := GetPostHooksAttributes()
        for key, attr := range postHooksAttrs </span><span class="cov10" title="6">{
                baseAttributes[key] = attr
        }</span>

        <span class="cov4" title="2">resp.Schema = schema.Schema{
                MarkdownDescription: "Manages symbolic links to dotfiles with comprehensive permission management",
                Attributes:          baseAttributes,
                Blocks: map[string]schema.Block{
                        "permissions": GetPermissionsSchemaBlock(),
                },
        }</span>
}

func (r *SymlinkResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov6" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov4" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else.",
                )
                return
        }</span>

        <span class="cov1" title="1">r.client = client</span>
}

func (r *SymlinkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel

        tflog.Debug(ctx, "=== SYMLINK CREATE START ===")
        tflog.Debug(ctx, "Getting plan data from request")
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get plan data", map[string]interface{}{
                        "diagnostics_count": len(resp.Diagnostics),
                })
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating symlink resource", map[string]interface{}{
                "name":           data.Name.ValueString(),
                "repository":     data.Repository.ValueString(),
                "source_path":    data.SourcePath.ValueString(),
                "target_path":    data.TargetPath.ValueString(),
                "force_update":   data.ForceUpdate.ValueBool(),
                "create_parents": data.CreateParents.ValueBool(),
        })

        // Get repository local path
        repositoryID := data.Repository.ValueString()
        repositoryLocalPath := r.getRepositoryLocalPath(repositoryID)
        tflog.Debug(ctx, "Retrieved repository local path", map[string]interface{}{
                "repository_id":   repositoryID,
                "repository_path": repositoryLocalPath,
        })

        // Build source path
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()
        tflog.Debug(ctx, "Built file paths", map[string]interface{}{
                "raw_source_path":  data.SourcePath.ValueString(),
                "full_source_path": sourcePath,
                "raw_target_path":  targetPath,
        })

        // Expand target path
        platformProvider := platform.DetectPlatform()
        tflog.Debug(ctx, "Detected platform", map[string]interface{}{
                "platform_type": fmt.Sprintf("%T", platformProvider),
        })

        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to expand target path", map[string]interface{}{
                        "error":       err.Error(),
                        "target_path": targetPath,
                })
                resp.Diagnostics.AddError(
                        "Invalid target path",
                        fmt.Sprintf("Could not expand target path %s: %s", targetPath, err.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Expanded target path", map[string]interface{}{
                "original_target": targetPath,
                "expanded_target": expandedTargetPath,
        })

        // Expand source path
        expandedSourcePath, err := platformProvider.ExpandPath(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to expand source path", map[string]interface{}{
                        "error":       err.Error(),
                        "source_path": sourcePath,
                })
                resp.Diagnostics.AddError(
                        "Invalid source path",
                        fmt.Sprintf("Could not expand source path %s: %s", sourcePath, err.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Expanded source path", map[string]interface{}{
                "original_source": sourcePath,
                "expanded_source": expandedSourcePath,
        })

        // Verify source exists
        tflog.Debug(ctx, "Checking if source exists", map[string]interface{}{
                "expanded_source": expandedSourcePath,
        })
        sourceExists := utils.PathExists(expandedSourcePath)
        if !sourceExists </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Source path does not exist", map[string]interface{}{
                        "expanded_source": expandedSourcePath,
                })
                resp.Diagnostics.AddError(
                        "Source not found",
                        fmt.Sprintf("Source path does not exist: %s", expandedSourcePath),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Source path verified", map[string]interface{}{
                "expanded_source": expandedSourcePath,
        })

        // Create file manager
        dryRun := r.client.Config.DryRun
        tflog.Debug(ctx, "Creating file manager", map[string]interface{}{
                "dry_run": dryRun,
        })
        fileManager := fileops.NewFileManager(platformProvider, dryRun)

        // Handle existing target
        tflog.Debug(ctx, "Checking if target exists", map[string]interface{}{
                "expanded_target": expandedTargetPath,
        })
        targetExists := utils.PathExists(expandedTargetPath)
        tflog.Debug(ctx, "Target existence check result", map[string]interface{}{
                "target_exists": targetExists,
        })

        if targetExists </span><span class="cov0" title="0">{
                if !data.ForceUpdate.ValueBool() </span><span class="cov0" title="0">{
                        // Create backup if enabled
                        if r.client.Config.BackupEnabled </span><span class="cov0" title="0">{
                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddWarning(
                                                "Backup failed",
                                                fmt.Sprintf("Could not create backup of existing target: %s", err.Error()),
                                        )
                                }</span>
                        }
                }

                // Remove existing target (handle both files and directories)
                <span class="cov0" title="0">tflog.Debug(ctx, "Statting existing target for removal", map[string]interface{}{
                        "expanded_target": expandedTargetPath,
                })
                info, err := os.Stat(expandedTargetPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to stat existing target", map[string]interface{}{
                                "error":           err.Error(),
                                "expanded_target": expandedTargetPath,
                        })
                        resp.Diagnostics.AddError(
                                "Could not stat existing target",
                                fmt.Sprintf("Could not stat existing target at %s: %s", expandedTargetPath, err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">isDir := info.IsDir()
                tflog.Debug(ctx, "Target stat results", map[string]interface{}{
                        "is_directory": isDir,
                        "mode":         info.Mode().String(),
                        "size":         info.Size(),
                })

                if isDir </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Removing existing directory with RemoveAll")
                        // Use RemoveAll for directories
                        err = os.RemoveAll(expandedTargetPath)
                }</span> else<span class="cov0" title="0"> {
                        tflog.Debug(ctx, "Removing existing file with Remove")
                        // Use Remove for files
                        err = os.Remove(expandedTargetPath)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to remove existing target", map[string]interface{}{
                                "error":           err.Error(),
                                "expanded_target": expandedTargetPath,
                                "was_directory":   isDir,
                        })
                        resp.Diagnostics.AddError(
                                "Could not remove existing target",
                                fmt.Sprintf("Could not remove existing target at %s: %s", expandedTargetPath, err.Error()),
                        )
                        return
                }</span>
                <span class="cov0" title="0">tflog.Debug(ctx, "Successfully removed existing target", map[string]interface{}{
                        "expanded_target": expandedTargetPath,
                        "was_directory":   isDir,
                })</span>
        }

        // Create symlink
        <span class="cov0" title="0">tflog.Debug(ctx, "Creating symlink", map[string]interface{}{
                "source_path":    expandedSourcePath,
                "target_path":    expandedTargetPath,
                "create_parents": data.CreateParents.ValueBool(),
        })

        var finalErr error
        if data.CreateParents.ValueBool() </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Using CreateSymlinkWithParents")
                finalErr = fileManager.CreateSymlinkWithParents(expandedSourcePath, expandedTargetPath)
        }</span> else<span class="cov0" title="0"> {
                tflog.Debug(ctx, "Using CreateSymlink")
                finalErr = fileManager.CreateSymlink(expandedSourcePath, expandedTargetPath)
        }</span>

        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Symlink creation failed", map[string]interface{}{
                        "error":       finalErr.Error(),
                        "source_path": expandedSourcePath,
                        "target_path": expandedTargetPath,
                })
                resp.Diagnostics.AddError(
                        "Symlink creation failed",
                        fmt.Sprintf("Could not create symlink %s -&gt; %s: %s", expandedTargetPath, expandedSourcePath, finalErr.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Symlink created successfully")

        // Update computed attributes
        tflog.Debug(ctx, "Updating computed attributes")
        if err := r.updateComputedAttributes(ctx, &amp;data, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                tflog.Warn(ctx, "Failed to update computed attributes, setting defaults", map[string]interface{}{
                        "error": err.Error(),
                })
                // Set default values for computed attributes if update fails
                data.LinkExists = types.BoolValue(utils.PathExists(expandedTargetPath))
                data.IsSymlink = types.BoolValue(false)
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))

                resp.Diagnostics.AddWarning(
                        "Could not update symlink metadata",
                        fmt.Sprintf("Symlink created successfully but could not update metadata: %s", err.Error()),
                )
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">tflog.Debug(ctx, "Setting resource ID and saving state", map[string]interface{}{
                "id": data.Name.ValueString(),
        })
        data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Symlink resource created successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
                "source_path": expandedSourcePath,
                "link_exists": data.LinkExists.ValueBool(),
                "is_symlink":  data.IsSymlink.ValueBool(),
        })
        tflog.Debug(ctx, "=== SYMLINK CREATE END ===")</span>
}

func (r *SymlinkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading symlink resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Expand target path to check current state
        platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(data.TargetPath.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to expand target path",
                        fmt.Sprintf("Error expanding target path for symlink %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes with current state
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, expandedTargetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for symlink %s: %v", data.Name.ValueString(), err),
                )
                // Set default values if update fails
                data.LinkExists = types.BoolValue(utils.PathExists(expandedTargetPath))
                data.IsSymlink = types.BoolValue(utils.IsSymlink(expandedTargetPath))
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))
        }</span>

        // Verify symlink integrity if it exists
        <span class="cov0" title="0">if data.LinkExists.ValueBool() &amp;&amp; data.IsSymlink.ValueBool() </span><span class="cov0" title="0">{
                // Check if the symlink target matches our expected source
                actualTarget, err := os.Readlink(expandedTargetPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Could not read symlink target", map[string]interface{}{
                                "target_path": expandedTargetPath,
                                "error":       err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        // Expand the source path to compare
                        expandedSourcePath, err := platformProvider.ExpandPath(data.SourcePath.ValueString())
                        if err == nil </span><span class="cov0" title="0">{
                                // Make paths absolute for comparison
                                expectedTarget, _ := filepath.Abs(expandedSourcePath)
                                actualTargetAbs, _ := filepath.Abs(actualTarget)

                                if expectedTarget != actualTargetAbs </span><span class="cov0" title="0">{
                                        tflog.Info(ctx, "Symlink target drift detected", map[string]interface{}{
                                                "expected": expectedTarget,
                                                "actual":   actualTargetAbs,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SymlinkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SymlinkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting symlink resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Remove the symlink
        targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Could not expand target path",
                                fmt.Sprintf("Could not expand target path for cleanup: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                        err := os.Remove(expandedTargetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Could not remove symlink",
                                        fmt.Sprintf("Could not remove symlink %s: %s", expandedTargetPath, err.Error()),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "Symlink resource removed", map[string]interface{}{
                                        "target_path": expandedTargetPath,
                                })
                        }</span>
                }
        }
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *SymlinkResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>

// updateComputedAttributes updates computed attributes for state tracking.
func (r *SymlinkResource) updateComputedAttributes(ctx context.Context, data *SymlinkResourceModel, targetPath string) error <span class="cov0" title="0">{
        tflog.Debug(ctx, "Updating computed attributes for symlink", map[string]interface{}{
                "target_path": targetPath,
        })

        // Check if link exists
        exists := utils.PathExists(targetPath)
        data.LinkExists = types.BoolValue(exists)
        tflog.Debug(ctx, "Link exists check", map[string]interface{}{
                "exists": exists,
        })

        if exists </span><span class="cov0" title="0">{
                // Check if it's actually a symlink
                isSymlink := utils.IsSymlink(targetPath)
                data.IsSymlink = types.BoolValue(isSymlink)
                tflog.Debug(ctx, "Symlink check", map[string]interface{}{
                        "is_symlink": isSymlink,
                })

                if isSymlink </span><span class="cov0" title="0">{
                        // Get symlink target
                        linkTarget, err := os.Readlink(targetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                tflog.Warn(ctx, "Failed to read symlink target", map[string]interface{}{
                                        "error": err.Error(),
                                })
                                data.LinkTarget = types.StringNull()
                                // Return error for critical symlink read failures
                                return fmt.Errorf("failed to read symlink target: %w", err)
                        }</span> else<span class="cov0" title="0"> {
                                data.LinkTarget = types.StringValue(linkTarget)
                                tflog.Debug(ctx, "Symlink target read", map[string]interface{}{
                                        "target": linkTarget,
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.LinkTarget = types.StringNull()
                }</span>

                // Get modification time
                <span class="cov0" title="0">info, err := os.Lstat(targetPath) // Use Lstat to get symlink info, not target info
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to stat symlink, using current time", map[string]interface{}{
                                "error": err.Error(),
                        })
                        data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))
                        // Don't return error for stat failures - they're not critical
                }</span> else<span class="cov0" title="0"> {
                        data.LastModified = types.StringValue(info.ModTime().Format(time.RFC3339))
                        tflog.Debug(ctx, "Modification time set", map[string]interface{}{
                                "mod_time": info.ModTime().Format(time.RFC3339),
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                data.IsSymlink = types.BoolValue(false)
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringNull()
                tflog.Debug(ctx, "Link does not exist, set default values")
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Computed attributes updated successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var _ datasource.DataSource = &amp;SystemDataSource{}

func NewSystemDataSource() datasource.DataSource <span class="cov10" title="5">{
        return &amp;SystemDataSource{}
}</span>

type SystemDataSource struct {
        client *DotfilesClient
}

type SystemDataSourceModel struct {
        ID           types.String `tfsdk:"id"`
        Platform     types.String `tfsdk:"platform"`
        Architecture types.String `tfsdk:"architecture"`
        HomeDir      types.String `tfsdk:"home_dir"`
        ConfigDir    types.String `tfsdk:"config_dir"`
}

func (d *SystemDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_system"
}</span>

func (d *SystemDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "System information data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Data source identifier",
                        },
                        "platform": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Operating system platform",
                        },
                        "architecture": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "System architecture",
                        },
                        "home_dir": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "User home directory",
                        },
                        "config_dir": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "User config directory",
                        },
                },
        }
}</span>

func (d *SystemDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov7" title="3">{
        if req.ProviderData == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError("Unexpected Data Source Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov1" title="1">d.client = client</span>
}

func (d *SystemDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SystemDataSourceModel

        data.ID = types.StringValue("system")
        data.Platform = types.StringValue(d.client.Platform)
        data.Architecture = types.StringValue(d.client.Architecture)
        data.HomeDir = types.StringValue(d.client.HomeDir)
        data.ConfigDir = types.StringValue(d.client.ConfigDir)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package services

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// BackupService defines the interface for backup operations.
type BackupService interface {
        // CreateBackup creates a backup of the specified file or directory
        CreateBackup(ctx context.Context, sourcePath, backupDir string, options BackupOptions) (*BackupResult, error)

        // CreateEnhancedBackup creates a backup with enhanced features like compression and metadata
        CreateEnhancedBackup(ctx context.Context, sourcePath string, config *EnhancedBackupConfig) (*BackupResult, error)

        // RestoreBackup restores a file from backup
        RestoreBackup(ctx context.Context, backupPath, targetPath string) error

        // ListBackups lists all available backups for a given file
        ListBackups(ctx context.Context, originalPath, backupDir string) ([]*BackupInfo, error)

        // CleanupBackups removes old backups based on retention policy
        CleanupBackups(ctx context.Context, backupDir string, retention RetentionPolicy) error

        // ValidateBackup verifies the integrity of a backup
        ValidateBackup(ctx context.Context, backupPath string) (*ValidationResult, error)
}

// BackupOptions contains options for backup operations.
type BackupOptions struct {
        // Compression enables compression for the backup
        Compression bool

        // Format specifies the backup format (timestamped, numbered, git-style)
        Format BackupFormat

        // Metadata includes additional metadata in the backup
        Metadata map[string]string

        // DryRun indicates whether this is a dry run
        DryRun bool
}

// BackupFormat represents different backup naming formats.
type BackupFormat string

const (
        BackupFormatTimestamped BackupFormat = "timestamped"
        BackupFormatNumbered    BackupFormat = "numbered"
        BackupFormatGitStyle    BackupFormat = "git-style"
)

// BackupResult contains information about a completed backup operation.
type BackupResult struct {
        // BackupPath is the full path to the created backup
        BackupPath string

        // Size is the size of the backup in bytes
        Size int64

        // CreatedAt is when the backup was created
        CreatedAt time.Time

        // Checksum is the checksum of the backup for integrity verification
        Checksum string

        // Compressed indicates if the backup is compressed
        Compressed bool

        // Metadata contains additional backup metadata
        Metadata map[string]string
}

// BackupInfo contains information about an existing backup.
type BackupInfo struct {
        // Path is the full path to the backup
        Path string

        // OriginalPath is the path of the original file
        OriginalPath string

        // Size is the size of the backup
        Size int64

        // CreatedAt is when the backup was created
        CreatedAt time.Time

        // Format is the backup format used
        Format BackupFormat

        // Checksum is the backup checksum
        Checksum string

        // Valid indicates if the backup passed validation
        Valid bool
}

// EnhancedBackupConfig contains configuration for enhanced backup operations.
type EnhancedBackupConfig struct {
        // Enabled indicates if enhanced backup is enabled
        Enabled bool

        // Directory is the backup directory
        Directory string

        // Format is the backup format to use
        Format BackupFormat

        // Compression enables compression
        Compression bool

        // Retention defines the retention policy
        Retention RetentionPolicy

        // Metadata contains additional metadata
        Metadata map[string]string

        // Incremental enables incremental backups
        Incremental bool
}

// RetentionPolicy defines how long backups should be kept.
type RetentionPolicy struct {
        // MaxAge is the maximum age of backups to keep
        MaxAge time.Duration

        // MaxCount is the maximum number of backups to keep
        MaxCount int

        // KeepDaily indicates how many daily backups to keep
        KeepDaily int

        // KeepWeekly indicates how many weekly backups to keep
        KeepWeekly int

        // KeepMonthly indicates how many monthly backups to keep
        KeepMonthly int
}

// ValidationResult contains the result of backup validation.
type ValidationResult struct {
        // Valid indicates if the backup is valid
        Valid bool

        // Errors contains any validation errors
        Errors []string

        // Warnings contains any validation warnings
        Warnings []string

        // ChecksumMatch indicates if the checksum matches
        ChecksumMatch bool

        // Size is the validated size
        Size int64
}

// DefaultBackupService provides a default implementation of BackupService.
type DefaultBackupService struct {
        // platformProvider provides platform-specific operations
        platformProvider PlatformProvider

        // dryRun indicates if operations should be simulated
        dryRun bool
}

// PlatformProvider defines platform-specific operations needed by the backup service.
type PlatformProvider interface {
        // CopyFile copies a file from source to destination
        CopyFile(src, dst string, mode os.FileMode) error

        // CreateDirectory creates a directory with the specified permissions
        CreateDirectory(path string, mode os.FileMode) error

        // GetFileInfo returns information about a file
        GetFileInfo(path string) (os.FileInfo, error)

        // CalculateChecksum calculates the checksum of a file
        CalculateChecksum(path string) (string, error)
}

// NewDefaultBackupService creates a new default backup service.
func NewDefaultBackupService(platformProvider PlatformProvider, dryRun bool) *DefaultBackupService <span class="cov10" title="23">{
        return &amp;DefaultBackupService{
                platformProvider: platformProvider,
                dryRun:           dryRun,
        }
}</span>

// CreateBackup implements BackupService.CreateBackup.
func (s *DefaultBackupService) CreateBackup(ctx context.Context, sourcePath, backupDir string, options BackupOptions) (*BackupResult, error) <span class="cov9" title="19">{
        if s.dryRun || options.DryRun </span><span class="cov1" title="1">{
                return s.simulateBackup(ctx, sourcePath, backupDir, options)
        }</span>

        <span class="cov9" title="18">return s.performBackup(ctx, sourcePath, backupDir, options)</span>
}

// CreateEnhancedBackup implements BackupService.CreateEnhancedBackup.
func (s *DefaultBackupService) CreateEnhancedBackup(ctx context.Context, sourcePath string, config *EnhancedBackupConfig) (*BackupResult, error) <span class="cov1" title="1">{
        if s.dryRun </span><span class="cov0" title="0">{
                return s.simulateEnhancedBackup(ctx, sourcePath, config)
        }</span>

        <span class="cov1" title="1">return s.performEnhancedBackup(ctx, sourcePath, config)</span>
}

// RestoreBackup implements BackupService.RestoreBackup.
func (s *DefaultBackupService) RestoreBackup(ctx context.Context, backupPath, targetPath string) error <span class="cov0" title="0">{
        if s.dryRun </span><span class="cov0" title="0">{
                return s.simulateRestore(ctx, backupPath, targetPath)
        }</span>

        <span class="cov0" title="0">return s.performRestore(ctx, backupPath, targetPath)</span>
}

// ListBackups implements BackupService.ListBackups.
func (s *DefaultBackupService) ListBackups(ctx context.Context, originalPath, backupDir string) ([]*BackupInfo, error) <span class="cov0" title="0">{
        return s.scanBackups(ctx, originalPath, backupDir)
}</span>

// CleanupBackups implements BackupService.CleanupBackups.
func (s *DefaultBackupService) CleanupBackups(ctx context.Context, backupDir string, retention RetentionPolicy) error <span class="cov4" title="3">{
        if s.dryRun </span><span class="cov0" title="0">{
                return s.simulateCleanup(ctx, backupDir, retention)
        }</span>

        <span class="cov4" title="3">return s.performCleanup(ctx, backupDir, retention)</span>
}

// ValidateBackup implements BackupService.ValidateBackup.
func (s *DefaultBackupService) ValidateBackup(ctx context.Context, backupPath string) (*ValidationResult, error) <span class="cov1" title="1">{
        return s.performValidation(ctx, backupPath)
}</span>

// Helper methods (implementation details)

func (s *DefaultBackupService) simulateBackup(_ context.Context, sourcePath, backupDir string, options BackupOptions) (*BackupResult, error) <span class="cov1" title="1">{
        // Simulate backup operation for dry run
        return &amp;BackupResult{
                BackupPath: s.generateBackupPath(sourcePath, backupDir, options.Format),
                Size:       0, // Would be calculated in real operation
                CreatedAt:  time.Now(),
                Checksum:   "simulated-checksum",
                Compressed: options.Compression,
                Metadata:   options.Metadata,
        }, nil
}</span>

func (s *DefaultBackupService) performBackup(ctx context.Context, sourcePath, backupDir string, options BackupOptions) (*BackupResult, error) <span class="cov9" title="19">{
        // Ensure backup directory exists
        if err := s.platformProvider.CreateDirectory(backupDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        <span class="cov9" title="19">backupPath := s.generateBackupPath(sourcePath, backupDir, options.Format)

        // Copy the source to backup path
        mode := os.FileMode(0644)
        if err := s.platformProvider.CopyFile(sourcePath, backupPath, mode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to copy file for backup: %w", err)
        }</span>

        // Get file info for the backup
        <span class="cov9" title="19">info, err := s.platformProvider.GetFileInfo(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get backup file info: %w", err)
        }</span>

        // Calculate checksum
        <span class="cov9" title="19">checksum, err := s.platformProvider.CalculateChecksum(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>

        <span class="cov9" title="19">result := &amp;BackupResult{
                BackupPath: backupPath,
                Size:       info.Size(),
                CreatedAt:  time.Now(),
                Checksum:   checksum,
                Compressed: options.Compression,
                Metadata:   options.Metadata,
        }
        return result, nil</span>
}

func (s *DefaultBackupService) simulateEnhancedBackup(_ context.Context, sourcePath string, config *EnhancedBackupConfig) (*BackupResult, error) <span class="cov0" title="0">{
        // Simulate enhanced backup for dry run
        return &amp;BackupResult{
                BackupPath: s.generateBackupPath(sourcePath, config.Directory, config.Format),
                Size:       0,
                CreatedAt:  time.Now(),
                Checksum:   "simulated-enhanced-checksum",
                Compressed: config.Compression,
                Metadata:   config.Metadata,
        }, nil
}</span>

func (s *DefaultBackupService) performEnhancedBackup(ctx context.Context, sourcePath string, config *EnhancedBackupConfig) (*BackupResult, error) <span class="cov1" title="1">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("enhanced backup not enabled")
        }</span>

        <span class="cov1" title="1">options := BackupOptions{
                Format:      config.Format,
                Compression: config.Compression,
                Metadata:    config.Metadata,
        }

        result, err := s.performBackup(ctx, sourcePath, config.Directory, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Optionally apply retention policy
        <span class="cov1" title="1">if err := s.CleanupBackups(ctx, config.Directory, config.Retention); err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail the backup - cleanup errors are non-fatal
                _ = err // Explicitly ignore the error
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func (s *DefaultBackupService) simulateRestore(ctx context.Context, backupPath, targetPath string) error <span class="cov0" title="0">{
        // Simulate restore for dry run
        return nil
}</span>

func (s *DefaultBackupService) performRestore(ctx context.Context, backupPath, targetPath string) error <span class="cov0" title="0">{
        // Implementation would go here
        return nil
}</span>

func (s *DefaultBackupService) scanBackups(ctx context.Context, originalPath, backupDir string) ([]*BackupInfo, error) <span class="cov0" title="0">{
        // Implementation would go here
        return nil, nil
}</span>

func (s *DefaultBackupService) simulateCleanup(ctx context.Context, backupDir string, retention RetentionPolicy) error <span class="cov0" title="0">{
        // Simulate cleanup for dry run
        return nil
}</span>

func (s *DefaultBackupService) performCleanup(ctx context.Context, backupDir string, retention RetentionPolicy) error <span class="cov4" title="3">{
        // Implementation would go here
        return nil
}</span>

func (s *DefaultBackupService) performValidation(_ context.Context, _ string) (*ValidationResult, error) <span class="cov1" title="1">{
        // Implementation would go here
        return &amp;ValidationResult{
                Valid:         true,
                Errors:        []string{},
                Warnings:      []string{},
                ChecksumMatch: true,
                Size:          0,
        }, nil
}</span>

func (s *DefaultBackupService) generateBackupPath(sourcePath, backupDir string, format BackupFormat) string <span class="cov9" title="20">{
        base := filepath.Base(sourcePath)
        timestamp := time.Now().Format("20060102-150405")
        switch format </span>{
        case BackupFormatTimestamped:<span class="cov8" title="13">
                return filepath.Join(backupDir, base+".backup."+timestamp)</span>
        case BackupFormatNumbered:<span class="cov2" title="2">
                return filepath.Join(backupDir, base+".backup.1")</span> // Simple implementation
        case BackupFormatGitStyle:<span class="cov2" title="2">
                return filepath.Join(backupDir, base+".backup~1")</span>
        default:<span class="cov4" title="3">
                return filepath.Join(backupDir, base+".backup")</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package services

import (
        "context"
        "sync"
        "sync/atomic"
        "time"
)

// CacheService defines the interface for caching operations.
type CacheService interface {
        // Get retrieves a value from the cache
        Get(ctx context.Context, key string) (interface{}, bool)

        // Set stores a value in the cache with optional TTL
        Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error

        // Delete removes a value from the cache
        Delete(ctx context.Context, key string) error

        // Clear removes all values from the cache
        Clear(ctx context.Context) error

        // Size returns the current number of items in the cache
        Size() int

        // Stats returns cache statistics
        Stats() CacheStats

        // Cleanup removes expired entries
        Cleanup(ctx context.Context) error
}

// CacheEntry represents a cached item.
type CacheEntry struct {
        Value       interface{}
        ExpiresAt   time.Time
        CreatedAt   time.Time
        AccessCount int64
        LastAccess  time.Time
}

// CacheStats contains cache performance statistics.
type CacheStats struct {
        Size        int
        Hits        int64
        Misses      int64
        Evictions   int64
        Cleanups    int64
        HitRatio    float64
        LastCleanup time.Time
}

// InMemoryCache provides an in-memory cache implementation.
type InMemoryCache struct {
        // Configuration
        maxSize    int
        defaultTTL time.Duration

        // Storage
        data map[string]*CacheEntry

        // Statistics
        stats CacheStats

        // Synchronization
        mu sync.RWMutex

        // Cleanup
        cleanupTicker *time.Ticker
        stopCleanup   chan struct{}
}

// CacheConfig contains configuration for cache initialization.
type CacheConfig struct {
        MaxSize         int
        DefaultTTL      time.Duration
        CleanupInterval time.Duration
}

// Cache constants.
const (
        DefaultCacheSize      = 1000
        DefaultCacheTTL       = 300 // 5 minutes in seconds
        CacheCleanupInterval  = 600 // 10 minutes in seconds
        DefaultMaxConcurrency = 10
        MaxConcurrency        = 50
)

// NewInMemoryCache creates a new in-memory cache with the provided configuration.
func NewInMemoryCache(config CacheConfig) *InMemoryCache <span class="cov2" title="11">{
        if config.MaxSize &lt;= 0 </span><span class="cov1" title="1">{
                config.MaxSize = DefaultCacheSize
        }</span>
        <span class="cov2" title="11">if config.DefaultTTL &lt;= 0 </span><span class="cov2" title="7">{
                config.DefaultTTL = time.Duration(DefaultCacheTTL) * time.Second
        }</span>
        <span class="cov2" title="11">if config.CleanupInterval &lt;= 0 </span><span class="cov2" title="9">{
                config.CleanupInterval = time.Duration(CacheCleanupInterval) * time.Second
        }</span>

        <span class="cov2" title="11">cache := &amp;InMemoryCache{
                maxSize:     config.MaxSize,
                defaultTTL:  config.DefaultTTL,
                data:        make(map[string]*CacheEntry),
                stats:       CacheStats{LastCleanup: time.Now()},
                stopCleanup: make(chan struct{}),
        }

        // Start cleanup goroutine
        cache.cleanupTicker = time.NewTicker(config.CleanupInterval)
        go cache.cleanupLoop()

        return cache</span>
}

// Get implements CacheService.Get.
func (c *InMemoryCache) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov6" title="1021">{
        c.mu.RLock()
        entry, exists := c.data[key]
        if !exists </span><span class="cov6" title="927">{
                atomic.AddInt64(&amp;c.stats.Misses, 1)
                c.mu.RUnlock()
                return nil, false
        }</span>

        // Check if expired
        <span class="cov4" title="94">if time.Now().After(entry.ExpiresAt) </span><span class="cov1" title="1">{
                // Need to upgrade to write lock to delete entry
                c.mu.RUnlock()
                c.mu.Lock()
                // Double-check the entry still exists and is still expired
                entry, exists = c.data[key]
                if exists &amp;&amp; time.Now().After(entry.ExpiresAt) </span><span class="cov1" title="1">{
                        delete(c.data, key)
                        atomic.AddInt64(&amp;c.stats.Evictions, 1)
                        c.stats.Size = len(c.data)
                }</span>
                <span class="cov1" title="1">atomic.AddInt64(&amp;c.stats.Misses, 1)
                c.mu.Unlock()
                return nil, false</span>
        }

        // Update access statistics  
        <span class="cov4" title="93">entry.AccessCount++
        entry.LastAccess = time.Now()
        atomic.AddInt64(&amp;c.stats.Hits, 1)
        c.mu.RUnlock()

        return entry.Value, true</span>
}

// Set implements CacheService.Set.
func (c *InMemoryCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov6" title="1018">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Use default TTL if not specified
        if ttl &lt;= 0 </span><span class="cov6" title="1014">{
                ttl = c.defaultTTL
        }</span>

        // Check if we need to evict entries to make room
        <span class="cov6" title="1018">if len(c.data) &gt;= c.maxSize </span><span class="cov6" title="902">{
                c.evictLRU()
        }</span>

        // Create new entry
        <span class="cov6" title="1018">now := time.Now()
        entry := &amp;CacheEntry{
                Value:       value,
                ExpiresAt:   now.Add(ttl),
                CreatedAt:   now,
                AccessCount: 0,
                LastAccess:  now,
        }

        c.data[key] = entry
        c.stats.Size = len(c.data)

        return nil</span>
}

// Delete implements CacheService.Delete.
func (c *InMemoryCache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.data, key)
        c.stats.Size = len(c.data)

        return nil
}</span>

// Clear implements CacheService.Clear.
func (c *InMemoryCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.data = make(map[string]*CacheEntry)
        c.stats.Size = 0

        return nil
}</span>

// Size implements CacheService.Size.
func (c *InMemoryCache) Size() int <span class="cov1" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.data)
}</span>

// Stats implements CacheService.Stats.
func (c *InMemoryCache) Stats() CacheStats <span class="cov1" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := c.stats
        stats.Size = len(c.data)

        // Calculate hit ratio
        total := stats.Hits + stats.Misses
        if total &gt; 0 </span><span class="cov1" title="1">{
                stats.HitRatio = float64(stats.Hits) / float64(total)
        }</span>

        <span class="cov1" title="2">return stats</span>
}

// Cleanup implements CacheService.Cleanup.
func (c *InMemoryCache) Cleanup(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        now := time.Now()
        removed := 0

        for key, entry := range c.data </span><span class="cov1" title="3">{
                if now.After(entry.ExpiresAt) </span><span class="cov1" title="2">{
                        delete(c.data, key)
                        removed++
                }</span>
        }

        <span class="cov1" title="1">c.stats.Size = len(c.data)
        c.stats.Evictions += int64(removed)
        c.stats.Cleanups++
        c.stats.LastCleanup = now

        return nil</span>
}

// Stop stops the cache cleanup goroutine.
func (c *InMemoryCache) Stop() <span class="cov2" title="11">{
        if c.cleanupTicker != nil </span><span class="cov2" title="11">{
                c.cleanupTicker.Stop()
        }</span>
        <span class="cov2" title="11">close(c.stopCleanup)</span>
}

// Helper methods

func (c *InMemoryCache) evictLRU() <span class="cov6" title="902">{
        // Find the least recently used entry
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.data </span><span class="cov10" title="90103">{
                if oldestKey == "" || entry.LastAccess.Before(oldestTime) </span><span class="cov7" title="3937">{
                        oldestKey = key
                        oldestTime = entry.LastAccess
                }</span>
        }

        <span class="cov6" title="902">if oldestKey != "" </span><span class="cov6" title="902">{
                delete(c.data, oldestKey)
                c.stats.Evictions++
        }</span>
}

func (c *InMemoryCache) cleanupLoop() <span class="cov2" title="11">{
        for </span><span class="cov2" title="11">{
                select </span>{
                case &lt;-c.cleanupTicker.C:<span class="cov0" title="0">
                        _ = c.Cleanup(context.Background())</span> // Ignore cleanup errors in background
                case &lt;-c.stopCleanup:<span class="cov2" title="11">
                        return</span>
                }
        }
}

// ConcurrencyManager manages concurrent operations.
type ConcurrencyManager struct {
        maxConcurrency int
        semaphore      chan struct{}
        activeOps      int64
        mu             sync.RWMutex
}

// NewConcurrencyManager creates a new concurrency manager.
func NewConcurrencyManager(maxConcurrency int) *ConcurrencyManager <span class="cov2" title="7">{
        if maxConcurrency &lt;= 0 </span><span class="cov1" title="1">{
                maxConcurrency = DefaultMaxConcurrency
        }</span>
        <span class="cov2" title="7">if maxConcurrency &gt; MaxConcurrency </span><span class="cov1" title="1">{
                maxConcurrency = MaxConcurrency
        }</span>

        <span class="cov2" title="7">return &amp;ConcurrencyManager{
                maxConcurrency: maxConcurrency,
                semaphore:      make(chan struct{}, maxConcurrency),
        }</span>
}

// Acquire acquires a slot for concurrent operation.
func (cm *ConcurrencyManager) Acquire(ctx context.Context) error <span class="cov2" title="7">{
        select </span>{
        case cm.semaphore &lt;- struct{}{}:<span class="cov2" title="6">
                cm.mu.Lock()
                cm.activeOps++
                cm.mu.Unlock()
                return nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        }
}

// Release releases a slot after operation completion.
func (cm *ConcurrencyManager) Release() <span class="cov2" title="6">{
        select </span>{
        case &lt;-cm.semaphore:<span class="cov2" title="6">
                cm.mu.Lock()
                cm.activeOps--
                cm.mu.Unlock()</span>
        default:<span class="cov0" title="0"></span>
                // Should not happen, but handle gracefully
        }
}

// ActiveOperations returns the number of currently active operations.
func (cm *ConcurrencyManager) ActiveOperations() int64 <span class="cov2" title="7">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return cm.activeOps
}</span>

// MaxConcurrency returns the maximum allowed concurrent operations.
func (cm *ConcurrencyManager) MaxConcurrency() int <span class="cov1" title="3">{
        return cm.maxConcurrency
}</span>

// OperationWrapper wraps an operation with concurrency control.
func (cm *ConcurrencyManager) OperationWrapper(ctx context.Context, operation func() error) error <span class="cov1" title="2">{
        if err := cm.Acquire(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="2">defer cm.Release()

        return operation()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package services

import (
        "context"
        "sync"
)

// ServiceRegistry manages all services used by the provider.
type ServiceRegistry struct {
        // Services
        backupService   BackupService
        templateService TemplateService

        // Configuration
        dryRun bool

        // Synchronization
        mu sync.RWMutex
}

// ServiceConfig contains configuration for service initialization.
type ServiceConfig struct {
        // DryRun indicates if services should operate in dry-run mode
        DryRun bool

        // PlatformProvider provides platform-specific operations
        PlatformProvider ServicePlatformProvider
}

// ServicePlatformProvider combines all platform provider interfaces needed by services.
type ServicePlatformProvider interface {
        PlatformProvider
        TemplatePlatformProvider
}

// NewServiceRegistry creates a new service registry with the provided configuration.
func NewServiceRegistry(config ServiceConfig) *ServiceRegistry <span class="cov7" title="8">{
        registry := &amp;ServiceRegistry{
                dryRun: config.DryRun,
        }

        // Initialize services
        registry.backupService = NewDefaultBackupService(config.PlatformProvider, config.DryRun)
        registry.templateService = NewDefaultTemplateService(config.PlatformProvider, config.DryRun)

        return registry
}</span>

// BackupService returns the backup service instance.
func (r *ServiceRegistry) BackupService() BackupService <span class="cov8" title="13">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.backupService
}</span>

// TemplateService returns the template service instance.
func (r *ServiceRegistry) TemplateService() TemplateService <span class="cov8" title="12">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.templateService
}</span>

// SetDryRun updates the dry-run mode for all services.
func (r *ServiceRegistry) SetDryRun(dryRun bool) <span class="cov10" title="22">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.dryRun = dryRun

        // Update services if they support dynamic dry-run changes
        if defaultBackup, ok := r.backupService.(*DefaultBackupService); ok </span><span class="cov10" title="22">{
                defaultBackup.dryRun = dryRun
        }</span>

        <span class="cov10" title="22">if defaultTemplate, ok := r.templateService.(*DefaultTemplateService); ok </span><span class="cov10" title="22">{
                defaultTemplate.dryRun = dryRun
        }</span>
}

// Shutdown gracefully shuts down all services.
func (r *ServiceRegistry) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Services don't currently need shutdown logic, but this provides
        // a hook for future cleanup operations

        return nil
}</span>

// HealthCheck performs a health check on all services.
func (r *ServiceRegistry) HealthCheck(ctx context.Context) *HealthCheckResult <span class="cov8" title="12">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := &amp;HealthCheckResult{
                Healthy:  true,
                Services: make(map[string]ServiceHealth),
        }

        // Check backup service
        backupHealth := r.checkBackupService(ctx)
        result.Services["backup"] = backupHealth
        if !backupHealth.Healthy </span><span class="cov0" title="0">{
                result.Healthy = false
        }</span>

        // Check template service
        <span class="cov8" title="12">templateHealth := r.checkTemplateService(ctx)
        result.Services["template"] = templateHealth
        if !templateHealth.Healthy </span><span class="cov1" title="1">{
                result.Healthy = false
        }</span>

        <span class="cov8" title="12">return result</span>
}

// Helper methods for health checks

func (r *ServiceRegistry) checkBackupService(_ context.Context) ServiceHealth <span class="cov8" title="12">{
        // Basic health check for backup service
        // In a real implementation, this might test basic operations
        return ServiceHealth{
                Healthy: true,
                Message: "Backup service operational",
        }
}</span>

func (r *ServiceRegistry) checkTemplateService(_ context.Context) ServiceHealth <span class="cov8" title="12">{
        // Basic health check for template service
        engines := r.templateService.GetSupportedEngines()
        if len(engines) == 0 </span><span class="cov1" title="1">{
                return ServiceHealth{
                        Healthy: false,
                        Message: "No template engines available",
                }
        }</span>

        <span class="cov7" title="11">return ServiceHealth{
                Healthy: true,
                Message: "Template service operational with " + string(rune(len(engines))) + " engines",
        }</span>
}

// HealthCheckResult contains the result of a service registry health check.
type HealthCheckResult struct {
        // Healthy indicates if all services are healthy
        Healthy bool

        // Services contains health status for individual services
        Services map[string]ServiceHealth

        // Message contains an overall health message
        Message string
}

// ServiceHealth contains health information for a single service.
type ServiceHealth struct {
        // Healthy indicates if the service is healthy
        Healthy bool

        // Message contains a health status message
        Message string

        // LastCheck is when the health check was performed
        LastCheck string
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package services

import (
        "context"
        "fmt"
        "strings"
        "text/template"
)

// TemplateService defines the interface for template operations.
type TemplateService interface {
        // ProcessTemplate processes a template file and writes the result to the target
        ProcessTemplate(ctx context.Context, sourcePath, targetPath string, config *TemplateConfig) error

        // RenderTemplate renders a template string with the provided variables
        RenderTemplate(ctx context.Context, templateContent string, variables map[string]interface{}, config *TemplateConfig) (string, error)

        // ValidateTemplate validates template syntax without rendering
        ValidateTemplate(ctx context.Context, templateContent string, engine TemplateEngine) (*ValidationResult, error)

        // GetSupportedEngines returns a list of supported template engines
        GetSupportedEngines() []TemplateEngine

        // CreateEngine creates a template engine with custom functions
        CreateEngine(engine TemplateEngine, functions template.FuncMap) (Engine, error)

        // GetPlatformVariables returns platform-specific template variables
        GetPlatformVariables(ctx context.Context) map[string]interface{}
}

// TemplateEngine represents different template engines.
type TemplateEngine string

const (
        TemplateEngineGo         TemplateEngine = "go"
        TemplateEngineHandlebars TemplateEngine = "handlebars"
        TemplateEngineMustache   TemplateEngine = "mustache"
)

// TemplateConfig contains configuration for template processing.
type TemplateConfig struct {
        // Engine specifies which template engine to use
        Engine TemplateEngine

        // Variables contains template variables
        Variables map[string]interface{}

        // Functions contains custom template functions
        Functions template.FuncMap

        // PlatformVariables includes platform-specific variables
        PlatformVariables bool

        // StrictMode enables strict variable checking
        StrictMode bool

        // Delimiters specifies custom template delimiters
        Delimiters *TemplateDelimiters

        // DryRun indicates if this is a dry run
        DryRun bool
}

// TemplateDelimiters defines custom template delimiters.
type TemplateDelimiters struct {
        Left  string
        Right string
}

// Engine represents a template engine instance.
type Engine interface {
        // Render renders a template with the provided variables
        Render(templateContent string, variables map[string]interface{}) (string, error)

        // Validate validates template syntax
        Validate(templateContent string) error

        // GetEngine returns the engine type
        GetEngine() TemplateEngine
}

// TemplateResult contains the result of template processing.
type TemplateResult struct {
        // Content is the rendered template content
        Content string

        // Variables contains the variables used in rendering
        Variables map[string]interface{}

        // Engine is the template engine used
        Engine TemplateEngine

        // ProcessingTime is how long the rendering took
        ProcessingTime int64
}

// DefaultTemplateService provides a default implementation of TemplateService.
type DefaultTemplateService struct {
        // platformProvider provides platform-specific operations
        platformProvider TemplatePlatformProvider

        // dryRun indicates if operations should be simulated
        dryRun bool

        // engines contains registered template engines
        engines map[TemplateEngine]Engine
}

// TemplatePlatformProvider defines platform-specific operations needed by the template service.
type TemplatePlatformProvider interface {
        // ReadFile reads a file and returns its content
        ReadFile(path string) ([]byte, error)

        // WriteFile writes content to a file
        WriteFile(path string, content []byte, mode uint32) error

        // GetPlatformInfo returns platform-specific information
        GetPlatformInfo() map[string]interface{}

        // ExpandPath expands a path with environment variables
        ExpandPath(path string) (string, error)
}

// NewDefaultTemplateService creates a new default template service.
func NewDefaultTemplateService(platformProvider TemplatePlatformProvider, dryRun bool) *DefaultTemplateService <span class="cov7" title="21">{
        service := &amp;DefaultTemplateService{
                platformProvider: platformProvider,
                dryRun:           dryRun,
                engines:          make(map[TemplateEngine]Engine),
        }

        // Register default engines
        service.registerDefaultEngines()

        return service
}</span>

// ProcessTemplate implements TemplateService.ProcessTemplate.
func (s *DefaultTemplateService) ProcessTemplate(ctx context.Context, sourcePath, targetPath string, config *TemplateConfig) error <span class="cov3" title="3">{
        if s.dryRun || config.DryRun </span><span class="cov1" title="1">{
                return s.simulateProcessTemplate(ctx, sourcePath, targetPath, config)
        }</span>

        <span class="cov2" title="2">return s.performProcessTemplate(ctx, sourcePath, targetPath, config)</span>
}

// RenderTemplate implements TemplateService.RenderTemplate.
func (s *DefaultTemplateService) RenderTemplate(ctx context.Context, templateContent string, variables map[string]interface{}, config *TemplateConfig) (string, error) <span class="cov4" title="6">{
        engine, exists := s.engines[config.Engine]
        if !exists </span><span class="cov0" title="0">{
                return "", &amp;TemplateError{
                        Type:    "unsupported_engine",
                        Message: "Unsupported template engine: " + string(config.Engine),
                        Engine:  config.Engine,
                }
        }</span>

        // Merge platform variables if requested
        <span class="cov4" title="6">if config.PlatformVariables </span><span class="cov1" title="1">{
                platformVars := s.GetPlatformVariables(ctx)
                variables = s.mergeVariables(variables, platformVars)
        }</span>

        <span class="cov4" title="6">return engine.Render(templateContent, variables)</span>
}

// ValidateTemplate implements TemplateService.ValidateTemplate.
func (s *DefaultTemplateService) ValidateTemplate(ctx context.Context, templateContent string, engine TemplateEngine) (*ValidationResult, error) <span class="cov4" title="5">{
        templateEngine, exists := s.engines[engine]
        if !exists </span><span class="cov1" title="1">{
                return &amp;ValidationResult{
                        Valid:  false,
                        Errors: []string{"Unsupported template engine: " + string(engine)},
                }, nil
        }</span>

        <span class="cov3" title="4">err := templateEngine.Validate(templateContent)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;ValidationResult{
                        Valid:  false,
                        Errors: []string{fmt.Sprintf("Template validation failed: %v", err)},
                }, nil
        }</span>

        <span class="cov3" title="3">return &amp;ValidationResult{
                Valid:    true,
                Errors:   []string{},
                Warnings: []string{},
        }, nil</span>
}

// GetSupportedEngines implements TemplateService.GetSupportedEngines.
func (s *DefaultTemplateService) GetSupportedEngines() []TemplateEngine <span class="cov6" title="13">{
        engines := make([]TemplateEngine, 0, len(s.engines))
        for engine := range s.engines </span><span class="cov8" title="39">{
                engines = append(engines, engine)
        }</span>
        <span class="cov6" title="13">return engines</span>
}

// CreateEngine implements TemplateService.CreateEngine.
func (s *DefaultTemplateService) CreateEngine(engine TemplateEngine, functions template.FuncMap) (Engine, error) <span class="cov10" title="67">{
        switch engine </span>{
        case TemplateEngineGo:<span class="cov7" title="22">
                return NewGoEngine(functions), nil</span>
        case TemplateEngineHandlebars:<span class="cov7" title="22">
                return NewHandlebarsEngine(functions), nil</span>
        case TemplateEngineMustache:<span class="cov7" title="22">
                return NewMustacheEngine(functions), nil</span>
        default:<span class="cov1" title="1">
                return nil, &amp;TemplateError{
                        Type:    "unsupported_engine",
                        Message: "Unsupported template engine: " + string(engine),
                        Engine:  engine,
                }</span>
        }
}

// GetPlatformVariables implements TemplateService.GetPlatformVariables.
func (s *DefaultTemplateService) GetPlatformVariables(ctx context.Context) map[string]interface{} <span class="cov2" title="2">{
        return s.platformProvider.GetPlatformInfo()
}</span>

// Helper methods

func (s *DefaultTemplateService) registerDefaultEngines() <span class="cov7" title="21">{
        // Register Go template engine
        if goEngine, err := s.CreateEngine(TemplateEngineGo, nil); err == nil </span><span class="cov7" title="21">{
                s.engines[TemplateEngineGo] = goEngine
        }</span>

        // Register Handlebars engine
        <span class="cov7" title="21">if handlebarsEngine, err := s.CreateEngine(TemplateEngineHandlebars, nil); err == nil </span><span class="cov7" title="21">{
                s.engines[TemplateEngineHandlebars] = handlebarsEngine
        }</span>

        // Register Mustache engine
        <span class="cov7" title="21">if mustacheEngine, err := s.CreateEngine(TemplateEngineMustache, nil); err == nil </span><span class="cov7" title="21">{
                s.engines[TemplateEngineMustache] = mustacheEngine
        }</span>
}

func (s *DefaultTemplateService) simulateProcessTemplate(ctx context.Context, sourcePath, targetPath string, config *TemplateConfig) error <span class="cov1" title="1">{
        // Simulate template processing for dry run
        return nil
}</span>

func (s *DefaultTemplateService) performProcessTemplate(ctx context.Context, sourcePath, targetPath string, config *TemplateConfig) error <span class="cov2" title="2">{
        // Read template content
        content, err := s.platformProvider.ReadFile(sourcePath)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;TemplateError{
                        Type:    "read_error",
                        Message: "Failed to read template file: " + err.Error(),
                        Path:    sourcePath,
                }
        }</span>

        // Render template
        <span class="cov1" title="1">rendered, err := s.RenderTemplate(ctx, string(content), config.Variables, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write rendered content
        <span class="cov1" title="1">return s.platformProvider.WriteFile(targetPath, []byte(rendered), 0644)</span>
}

func (s *DefaultTemplateService) mergeVariables(base, additional map[string]interface{}) map[string]interface{} <span class="cov1" title="1">{
        merged := make(map[string]interface{})

        // Copy base variables
        for k, v := range base </span><span class="cov1" title="1">{
                merged[k] = v
        }</span>

        // Add additional variables (may overwrite base)
        <span class="cov1" title="1">for k, v := range additional </span><span class="cov3" title="4">{
                merged[k] = v
        }</span>

        <span class="cov1" title="1">return merged</span>
}

// TemplateError represents template-related errors.
type TemplateError struct {
        Type    string
        Message string
        Path    string
        Engine  TemplateEngine
        Line    int
        Column  int
}

func (e *TemplateError) Error() string <span class="cov3" title="3">{
        if e.Path != "" </span><span class="cov1" title="1">{
                return e.Message + " (path: " + e.Path + ")"
        }</span>
        <span class="cov2" title="2">return e.Message</span>
}

// Engine implementations

// GoEngine implements the Go template engine.
type GoEngine struct {
        functions template.FuncMap
}

func NewGoEngine(functions template.FuncMap) *GoEngine <span class="cov7" title="24">{
        return &amp;GoEngine{
                functions: functions,
        }
}</span>

func (e *GoEngine) Render(templateContent string, variables map[string]interface{}) (string, error) <span class="cov4" title="6">{
        tmpl := template.New("template")
        if e.functions != nil </span><span class="cov0" title="0">{
                tmpl = tmpl.Funcs(e.functions)
        }</span>

        <span class="cov4" title="6">tmpl, err := tmpl.Parse(templateContent)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov4" title="6">var buf strings.Builder
        err = tmpl.Execute(&amp;buf, variables)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov4" title="6">return buf.String(), nil</span>
}

func (e *GoEngine) Validate(templateContent string) error <span class="cov3" title="4">{
        tmpl := template.New("validation")
        if e.functions != nil </span><span class="cov0" title="0">{
                tmpl = tmpl.Funcs(e.functions)
        }</span>

        <span class="cov3" title="4">_, err := tmpl.Parse(templateContent)
        return err</span>
}

func (e *GoEngine) GetEngine() TemplateEngine <span class="cov2" title="2">{
        return TemplateEngineGo
}</span>

// HandlebarsEngine implements the Handlebars template engine.
type HandlebarsEngine struct {
        functions template.FuncMap
}

func NewHandlebarsEngine(functions template.FuncMap) *HandlebarsEngine <span class="cov7" title="23">{
        return &amp;HandlebarsEngine{
                functions: functions,
        }
}</span>

func (e *HandlebarsEngine) Render(templateContent string, variables map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // This would integrate with a Handlebars library
        // For now, this is a placeholder
        return "", nil
}</span>

func (e *HandlebarsEngine) Validate(templateContent string) error <span class="cov2" title="2">{
        // Validate Handlebars syntax
        return nil
}</span>

func (e *HandlebarsEngine) GetEngine() TemplateEngine <span class="cov2" title="2">{
        return TemplateEngineHandlebars
}</span>

// MustacheEngine implements the Mustache template engine.
type MustacheEngine struct {
        functions template.FuncMap
}

func NewMustacheEngine(functions template.FuncMap) *MustacheEngine <span class="cov7" title="23">{
        return &amp;MustacheEngine{
                functions: functions,
        }
}</span>

func (e *MustacheEngine) Render(templateContent string, variables map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // This would integrate with a Mustache library
        // For now, this is a placeholder
        return "", nil
}</span>

func (e *MustacheEngine) Validate(templateContent string) error <span class="cov2" title="2">{
        // Validate Mustache syntax
        return nil
}</span>

func (e *MustacheEngine) GetEngine() TemplateEngine <span class="cov2" title="2">{
        return TemplateEngineMustache
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package template

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

// TemplateEngine defines the interface for template processing.
type TemplateEngine interface {
        ProcessTemplate(templateContent string, context map[string]interface{}) (string, error)
        ProcessTemplateFile(templatePath, outputPath string, context map[string]interface{}, fileMode string) error
        ValidateTemplate(templateContent string) error
}

// GoTemplateEngine implements TemplateEngine using Go templates.
type GoTemplateEngine struct {
        functions template.FuncMap
}

// NewGoTemplateEngine creates a new Go template engine with default functions.
func NewGoTemplateEngine() (*GoTemplateEngine, error) <span class="cov8" title="11">{
        engine := &amp;GoTemplateEngine{
                functions: getDefaultTemplateFunctions(),
        }

        return engine, nil
}</span>

// NewGoTemplateEngineWithFunctions creates a new Go template engine with custom functions.
func NewGoTemplateEngineWithFunctions(customFunctions map[string]interface{}) (*GoTemplateEngine, error) <span class="cov3" title="2">{
        // Start with default functions from getDefaultTemplateFunctions
        allFunctions := getDefaultTemplateFunctions()

        // Add custom functions
        for name, fn := range customFunctions </span><span class="cov5" title="4">{
                allFunctions[name] = fn
        }</span>

        <span class="cov3" title="2">engine := &amp;GoTemplateEngine{
                functions: allFunctions,
        }

        return engine, nil</span>
}

// getDefaultTemplateFunctions returns the standard template functions used across all engines.
func getDefaultTemplateFunctions() template.FuncMap <span class="cov10" title="15">{
        return template.FuncMap{
                // Path helper functions
                "configPath": func(app string) string </span><span class="cov1" title="1">{
                        return filepath.Join("~/.config", app)
                }</span>,
                "homebrewBin": func(prefix string) string <span class="cov1" title="1">{
                        return filepath.Join(prefix, "bin")
                }</span>,
                "homebrewPrefix": func() string <span class="cov0" title="0">{
                        return "/opt/homebrew" // Default for macOS
                }</span>,

                // String helper functions
                "upper": strings.ToUpper,
                "lower": strings.ToLower,
                "title": func(s string) string <span class="cov0" title="0">{
                        if len(s) == 0 </span><span class="cov0" title="0">{
                                return s
                        }</span>
                        <span class="cov0" title="0">return strings.ToUpper(s[:1]) + s[1:]</span>
                },
                "camelCase": func(s string) string <span class="cov0" title="0">{
                        parts := strings.Split(s, "_")
                        if len(parts) == 0 </span><span class="cov0" title="0">{
                                return s
                        }</span>
                        <span class="cov0" title="0">result := parts[0]
                        for i := 1; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                                if len(parts[i]) &gt; 0 </span><span class="cov0" title="0">{
                                        result += strings.ToUpper(parts[i][:1]) + parts[i][1:]
                                }</span>
                        }
                        <span class="cov0" title="0">return result</span>
                },

                // Conditional helpers
                "default": func(defaultValue, value interface{}) interface{} <span class="cov0" title="0">{
                        if value == nil || value == "" </span><span class="cov0" title="0">{
                                return defaultValue
                        }</span>
                        <span class="cov0" title="0">return value</span>
                },

                // Platform helpers
                "isLinux":   func(platform string) bool <span class="cov0" title="0">{ return platform == "linux" }</span>,
                "isMacOS":   func(platform string) bool <span class="cov0" title="0">{ return platform == "macos" }</span>,
                "isWindows": func(platform string) bool <span class="cov0" title="0">{ return platform == "windows" }</span>,
        }
}

// ProcessTemplate processes a template string with the given context.
func (e *GoTemplateEngine) ProcessTemplate(templateContent string, context map[string]interface{}) (string, error) <span class="cov8" title="11">{
        // Create template with custom functions
        tmpl, err := template.New("template").Funcs(e.functions).Parse(templateContent)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse template: %w", err)
        }</span>

        // Execute template
        <span class="cov8" title="11">var buf bytes.Buffer
        err = tmpl.Execute(&amp;buf, context)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov8" title="11">return buf.String(), nil</span>
}

// ProcessTemplateFile processes a template file and writes the result to output file.
func (e *GoTemplateEngine) ProcessTemplateFile(templatePath, outputPath string, context map[string]interface{}, fileMode string) error <span class="cov5" title="4">{
        // Read template file
        templateContent, err := os.ReadFile(templatePath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read template file: %w", err)
        }</span>

        // Process template
        <span class="cov4" title="3">result, err := e.ProcessTemplate(string(templateContent), context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process template: %w", err)
        }</span>

        // Parse file mode
        <span class="cov4" title="3">mode, err := utils.ParseFileMode(fileMode)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid file mode: %w", err)
        }</span>

        // Create parent directories
        <span class="cov3" title="2">parentDir := filepath.Dir(outputPath)
        err = os.MkdirAll(parentDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        // Write result to output file
        <span class="cov3" title="2">err = os.WriteFile(outputPath, []byte(result), mode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// ValidateTemplate validates template syntax without executing it.
func (e *GoTemplateEngine) ValidateTemplate(templateContent string) error <span class="cov3" title="2">{
        _, err := template.New("validation").Funcs(e.functions).Parse(templateContent)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("template validation failed: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CreateTemplateContext creates a template context with system and user variables.
func CreateTemplateContext(systemInfo, userVars map[string]interface{}) map[string]interface{} <span class="cov3" title="2">{
        context := make(map[string]interface{})

        // Add system information
        context["system"] = systemInfo

        // Add user variables at root level
        for key, value := range userVars </span><span class="cov3" title="2">{
                context[key] = value
        }</span>

        <span class="cov3" title="2">return context</span>
}

// CreateTemplateContextWithFeatures creates a template context with system, user, and feature variables.
func CreateTemplateContextWithFeatures(systemInfo, userVars, features map[string]interface{}) map[string]interface{} <span class="cov1" title="1">{
        context := CreateTemplateContext(systemInfo, userVars)

        // Add features
        context["features"] = features

        return context
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package template

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

// HandlebarsTemplateEngine implements TemplateEngine using Handlebars-style syntax.
type HandlebarsTemplateEngine struct {
        functions template.FuncMap
}

// MustacheTemplateEngine implements TemplateEngine using Mustache-style syntax.
type MustacheTemplateEngine struct {
        functions template.FuncMap
}

// NewHandlebarsTemplateEngine creates a new Handlebars-style template engine.
func NewHandlebarsTemplateEngine() (*HandlebarsTemplateEngine, error) <span class="cov1" title="1">{
        engine := &amp;HandlebarsTemplateEngine{
                functions: getDefaultTemplateFunctions(),
        }
        return engine, nil
}</span>

// NewMustacheTemplateEngine creates a new Mustache-style template engine.
func NewMustacheTemplateEngine() (*MustacheTemplateEngine, error) <span class="cov1" title="1">{
        engine := &amp;MustacheTemplateEngine{
                functions: getDefaultTemplateFunctions(),
        }
        return engine, nil
}</span>

// (NewGoTemplateEngineWithFunctions is implemented in engine.go).

// ProcessTemplate processes a Handlebars-style template.
func (e *HandlebarsTemplateEngine) ProcessTemplate(templateContent string, context map[string]interface{}) (string, error) <span class="cov1" title="1">{
        // Convert Handlebars syntax to Go template syntax for compatibility
        // {{var}} -&gt; {{.var}}
        // {{#if}} -&gt; {{if}}
        // {{/if}} -&gt; {{end}}
        converted := convertHandlebarsToGo(templateContent)

        // Create Go template with functions
        tmpl, err := template.New("handlebars").Funcs(e.functions).Parse(converted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse handlebars template: %w", err)
        }</span>

        // Execute template
        <span class="cov1" title="1">var buf bytes.Buffer
        err = tmpl.Execute(&amp;buf, context)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to execute handlebars template: %w", err)
        }</span>

        <span class="cov1" title="1">return buf.String(), nil</span>
}

// ProcessTemplateFile processes a Handlebars template file.
func (e *HandlebarsTemplateEngine) ProcessTemplateFile(templatePath, outputPath string, context map[string]interface{}, fileMode string) error <span class="cov0" title="0">{
        // Read template file
        templateContent, err := os.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read template file: %w", err)
        }</span>

        // Process template
        <span class="cov0" title="0">result, err := e.ProcessTemplate(string(templateContent), context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process template: %w", err)
        }</span>

        // Parse file mode
        <span class="cov0" title="0">mode, err := utils.ParseFileMode(fileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file mode: %w", err)
        }</span>

        // Create parent directories
        <span class="cov0" title="0">parentDir := filepath.Dir(outputPath)
        err = os.MkdirAll(parentDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        // Write result to output file
        <span class="cov0" title="0">err = os.WriteFile(outputPath, []byte(result), mode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateTemplate validates Handlebars template syntax.
func (e *HandlebarsTemplateEngine) ValidateTemplate(templateContent string) error <span class="cov0" title="0">{
        converted := convertHandlebarsToGo(templateContent)
        _, err := template.New("validation").Funcs(e.functions).Parse(converted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handlebars template validation failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ProcessTemplate processes a Mustache-style template.
func (e *MustacheTemplateEngine) ProcessTemplate(templateContent string, context map[string]interface{}) (string, error) <span class="cov1" title="1">{
        // Convert Mustache syntax to Go template syntax for compatibility
        // {{var}} -&gt; {{.var}}
        // {{#section}} -&gt; {{with .section}}
        // {{/section}} -&gt; {{end}}
        converted := convertMustacheToGo(templateContent)

        // Create Go template with functions
        tmpl, err := template.New("mustache").Funcs(e.functions).Parse(converted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse mustache template: %w", err)
        }</span>

        // Execute template
        <span class="cov1" title="1">var buf bytes.Buffer
        err = tmpl.Execute(&amp;buf, context)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to execute mustache template: %w", err)
        }</span>

        <span class="cov1" title="1">return buf.String(), nil</span>
}

// ProcessTemplateFile processes a Mustache template file.
func (e *MustacheTemplateEngine) ProcessTemplateFile(templatePath, outputPath string, context map[string]interface{}, fileMode string) error <span class="cov0" title="0">{
        // Read template file
        templateContent, err := os.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read template file: %w", err)
        }</span>

        // Process template
        <span class="cov0" title="0">result, err := e.ProcessTemplate(string(templateContent), context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process template: %w", err)
        }</span>

        // Parse file mode
        <span class="cov0" title="0">mode, err := utils.ParseFileMode(fileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file mode: %w", err)
        }</span>

        // Create parent directories
        <span class="cov0" title="0">parentDir := filepath.Dir(outputPath)
        err = os.MkdirAll(parentDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        // Write result to output file
        <span class="cov0" title="0">err = os.WriteFile(outputPath, []byte(result), mode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateTemplate validates Mustache template syntax.
func (e *MustacheTemplateEngine) ValidateTemplate(templateContent string) error <span class="cov0" title="0">{
        converted := convertMustacheToGo(templateContent)
        _, err := template.New("validation").Funcs(e.functions).Parse(converted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mustache template validation failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// (getDefaultTemplateFunctions is implemented in engine.go).

// convertHandlebarsToGo converts Handlebars syntax to Go template syntax.
func convertHandlebarsToGo(content string) string <span class="cov1" title="1">{
        // More robust conversion for Handlebars compatibility
        result := content

        // Convert {{#if var}} to {{if .var}}
        result = strings.ReplaceAll(result, "{{#if ", "{{if .")
        result = strings.ReplaceAll(result, "{{/if}}", "{{end}}")

        // Convert {{#unless var}} to {{if not .var}}
        result = strings.ReplaceAll(result, "{{#unless ", "{{if not .")
        result = strings.ReplaceAll(result, "{{/unless}}", "{{end}}")

        // Convert {{#each items}} to {{range .items}}
        result = strings.ReplaceAll(result, "{{#each ", "{{range .")
        result = strings.ReplaceAll(result, "{{/each}}", "{{end}}")

        // Convert {{#with obj}} to {{with .obj}}
        result = strings.ReplaceAll(result, "{{#with ", "{{with .")
        result = strings.ReplaceAll(result, "{{/with}}", "{{end}}")

        // Convert simple variables: {{var}} to {{.var}} (but not if already has dot or contains spaces/operators)
        lines := strings.Split(result, "\n")
        for i, line := range lines </span><span class="cov5" title="3">{
                // Find all {{...}} patterns
                start := 0
                for </span><span class="cov10" title="8">{
                        openIdx := strings.Index(line[start:], "{{")
                        if openIdx == -1 </span><span class="cov5" title="3">{
                                break</span>
                        }
                        <span class="cov7" title="5">openIdx += start

                        closeIdx := strings.Index(line[openIdx:], "}}")
                        if closeIdx == -1 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov7" title="5">closeIdx += openIdx + 2

                        // Extract the content between {{ and }}
                        content := line[openIdx+2 : closeIdx-2]
                        content = strings.TrimSpace(content)

                        // Skip if it's a control structure, already has dot, or contains operators
                        if !strings.HasPrefix(content, ".") &amp;&amp;
                                !strings.Contains(content, " ") &amp;&amp;
                                !strings.Contains(content, "if") &amp;&amp;
                                !strings.Contains(content, "range") &amp;&amp;
                                !strings.Contains(content, "with") &amp;&amp;
                                !strings.Contains(content, "end") &amp;&amp;
                                !strings.Contains(content, "not") &amp;&amp;
                                content != "" </span><span class="cov0" title="0">{
                                // Replace {{var}} with {{.var}}
                                newContent := "{{." + content + "}}"
                                line = line[:openIdx] + newContent + line[closeIdx:]
                                start = openIdx + len(newContent)
                        }</span> else<span class="cov7" title="5"> {
                                start = closeIdx
                        }</span>
                }
                <span class="cov5" title="3">lines[i] = line</span>
        }

        <span class="cov1" title="1">return strings.Join(lines, "\n")</span>
}

// convertMustacheToGo converts Mustache syntax to Go template syntax.
func convertMustacheToGo(content string) string <span class="cov1" title="1">{
        // More robust conversion for Mustache compatibility
        result := content

        // Convert {{#section}} to {{with .section}} (for object context)
        // Convert {{#items}} to {{range .items}} (for array iteration)
        // This is a simplified approach - real Mustache would need context analysis

        // Handle sections that look like arrays (plural names often indicate arrays)
        result = strings.ReplaceAll(result, "{{#items}}", "{{range .items}}")
        result = strings.ReplaceAll(result, "{{#users}}", "{{range .users}}")
        result = strings.ReplaceAll(result, "{{#files}}", "{{range .files}}")
        result = strings.ReplaceAll(result, "{{#configs}}", "{{range .configs}}")

        // Handle sections that look like objects
        result = strings.ReplaceAll(result, "{{#user}}", "{{with .user}}")
        result = strings.ReplaceAll(result, "{{#config}}", "{{with .config}}")
        result = strings.ReplaceAll(result, "{{#settings}}", "{{with .settings}}")

        // Convert closing tags
        result = strings.ReplaceAll(result, "{{/items}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/users}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/files}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/configs}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/user}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/config}}", "{{end}}")
        result = strings.ReplaceAll(result, "{{/settings}}", "{{end}}")

        // Convert simple variables: {{var}} to {{.var}} (similar to Handlebars)
        lines := strings.Split(result, "\n")
        for i, line := range lines </span><span class="cov5" title="3">{
                // Find all {{...}} patterns
                start := 0
                for </span><span class="cov10" title="8">{
                        openIdx := strings.Index(line[start:], "{{")
                        if openIdx == -1 </span><span class="cov5" title="3">{
                                break</span>
                        }
                        <span class="cov7" title="5">openIdx += start

                        closeIdx := strings.Index(line[openIdx:], "}}")
                        if closeIdx == -1 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov7" title="5">closeIdx += openIdx + 2

                        // Extract the content between {{ and }}
                        content := line[openIdx+2 : closeIdx-2]
                        content = strings.TrimSpace(content)

                        // Skip if it's a control structure, already has dot, or contains operators
                        if !strings.HasPrefix(content, ".") &amp;&amp;
                                !strings.Contains(content, " ") &amp;&amp;
                                !strings.Contains(content, "range") &amp;&amp;
                                !strings.Contains(content, "with") &amp;&amp;
                                !strings.Contains(content, "end") &amp;&amp;
                                !strings.HasPrefix(content, "#") &amp;&amp;
                                !strings.HasPrefix(content, "/") &amp;&amp;
                                content != "" </span><span class="cov0" title="0">{
                                // Replace {{var}} with {{.var}}
                                newContent := "{{." + content + "}}"
                                line = line[:openIdx] + newContent + line[closeIdx:]
                                start = openIdx + len(newContent)
                        }</span> else<span class="cov7" title="5"> {
                                start = closeIdx
                        }</span>
                }
                <span class="cov5" title="3">lines[i] = line</span>
        }

        <span class="cov1" title="1">return strings.Join(lines, "\n")</span>
}

// CreateTemplateEngine creates a template engine based on the specified type.
func CreateTemplateEngine(engineType string) (TemplateEngine, error) <span class="cov7" title="4">{
        switch engineType </span>{
        case "", "go":<span class="cov1" title="1">
                return NewGoTemplateEngine()</span>
        case "handlebars":<span class="cov1" title="1">
                return NewHandlebarsTemplateEngine()</span>
        case "mustache":<span class="cov1" title="1">
                return NewMustacheTemplateEngine()</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported template engine: %s", engineType)</span>
        }
}

// CreateTemplateEngineWithFunctions creates a template engine with custom functions.
func CreateTemplateEngineWithFunctions(engineType string, customFunctions map[string]interface{}) (TemplateEngine, error) <span class="cov1" title="1">{
        switch engineType </span>{
        case "", "go":<span class="cov1" title="1">
                return NewGoTemplateEngineWithFunctions(customFunctions)</span>
        case "handlebars":<span class="cov0" title="0">
                engine, err := NewHandlebarsTemplateEngine()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Add custom functions to the Handlebars engine
                <span class="cov0" title="0">for name, fn := range customFunctions </span><span class="cov0" title="0">{
                        engine.functions[name] = fn
                }</span>
                <span class="cov0" title="0">return engine, nil</span>
        case "mustache":<span class="cov0" title="0">
                engine, err := NewMustacheTemplateEngine()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Add custom functions to the Mustache engine
                <span class="cov0" title="0">for name, fn := range customFunctions </span><span class="cov0" title="0">{
                        engine.functions[name] = fn
                }</span>
                <span class="cov0" title="0">return engine, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported template engine: %s", engineType)</span>
        }
}

// BuildPlatformAwareTemplateContext creates template context with platform-specific variables.
func BuildPlatformAwareTemplateContext(systemInfo, userVars map[string]interface{}, platformVars map[string]map[string]interface{}) map[string]interface{} <span class="cov5" title="3">{
        context := make(map[string]interface{})

        // Add user vars at root level
        for k, v := range userVars </span><span class="cov10" title="8">{
                context[k] = v
        }</span>

        // Add system info
        <span class="cov5" title="3">context["system"] = systemInfo

        // Add platform-specific vars based on current platform
        if platform, ok := systemInfo["platform"].(string); ok </span><span class="cov5" title="3">{
                if platformSpecific, exists := platformVars[platform]; exists </span><span class="cov5" title="3">{
                        for k, v := range platformSpecific </span><span class="cov10" title="8">{
                                context[k] = v
                        }</span>
                }
        }

        // Add platform vars to context for template functions
        <span class="cov5" title="3">context["platform_vars"] = platformVars

        return context</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package utils

import (
        "os"
        "path/filepath"
        "strconv"
        "strings"
)

// ParseFileMode parses a file mode string like "0644" into os.FileMode.
func ParseFileMode(modeStr string) (os.FileMode, error) <span class="cov6" title="5">{
        if modeStr == "" </span><span class="cov1" title="1">{
                return 0644, nil // default
        }</span>

        // Handle octal mode strings
        <span class="cov6" title="4">if strings.HasPrefix(modeStr, "0") </span><span class="cov3" title="2">{
                mode, err := strconv.ParseUint(modeStr, 8, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov3" title="2">return os.FileMode(mode), nil</span>
        }

        // Handle decimal mode
        <span class="cov3" title="2">mode, err := strconv.ParseUint(modeStr, 10, 32)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return os.FileMode(mode), nil</span>
}

// FormatFileMode formats an os.FileMode as an octal string like "0644".
func FormatFileMode(mode os.FileMode) string <span class="cov4" title="3">{
        return "0" + strconv.FormatUint(uint64(mode.Perm()), 8)
}</span>

// PathExists checks if a path exists.
func PathExists(path string) bool <span class="cov10" title="12">{
        _, err := os.Stat(path)
        return err == nil
}</span>

// IsSymlink checks if a path is a symbolic link.
func IsSymlink(path string) bool <span class="cov6" title="4">{
        info, err := os.Lstat(path)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="3">return info.Mode()&amp;os.ModeSymlink != 0</span>
}

// CreateTempDotfilesRepo creates a temporary dotfiles repository for testing.
func CreateTempDotfilesRepo(tempDir string) (string, error) <span class="cov1" title="1">{
        repoDir := filepath.Join(tempDir, "dotfiles")
        err := os.MkdirAll(repoDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create basic dotfiles structure
        <span class="cov1" title="1">dirs := []string{
                "git",
                "fish",
                "ssh",
                "tools",
        }

        for _, dir := range dirs </span><span class="cov6" title="4">{
                err := os.MkdirAll(filepath.Join(repoDir, dir), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // Create test files
        <span class="cov1" title="1">files := map[string]string{
                "git/gitconfig": `[user]
    name = Test User
    email = test@example.com
[core]
    editor = vim`,
                "fish/config.fish": `# Fish configuration
set -g fish_greeting ""
set -gx EDITOR vim`,
                "ssh/config": `Host github.com
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519`,
                "tools/cursor.json": `{
    "editor.fontSize": 14,
    "workbench.colorTheme": "Dark+ (default dark)"
}`,
        }

        for filePath, content := range files </span><span class="cov6" title="4">{
                fullPath := filepath.Join(repoDir, filePath)
                err := os.WriteFile(fullPath, []byte(content), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">return repoDir, nil</span>
}

// GenerateTestID generates a unique test ID.
func GenerateTestID(prefix string) string <span class="cov3" title="2">{
        return prefix + "-" + strconv.Itoa(os.Getpid())
}</span>

// CompareFileContent compares the content of two files.
func CompareFileContent(file1, file2 string) (bool, error) <span class="cov4" title="3">{
        content1, err := os.ReadFile(file1)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="3">content2, err := os.ReadFile(file2)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        <span class="cov3" title="2">return string(content1) == string(content2), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package validators

import (
        "context"
        "fmt"
        "os"
        "regexp"
        "strconv"

        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// FileModeValidator validates that a string represents a valid file mode.
type FileModeValidator struct{}

// Description returns a description of the validator.
func (v FileModeValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a valid file mode (e.g., '0644', '0755', '644', '755')"
}</span>

// MarkdownDescription returns a markdown description of the validator.
func (v FileModeValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// ValidateString performs the validation.
func (v FileModeValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return // Empty values are handled by other validators
        }</span>

        // Parse the file mode
        <span class="cov0" title="0">mode, err := parseFileMode(value)
        if err != nil </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid File Mode",
                        fmt.Sprintf("Invalid file mode '%s': %s", value, err),
                )
                return
        }</span>

        // Validate that the mode is reasonable (not too permissive or restrictive)
        <span class="cov0" title="0">if mode &gt; 0777 </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid File Mode",
                        fmt.Sprintf("File mode '%s' is too permissive (maximum is 0777)", value),
                )
                return
        }</span>

        <span class="cov0" title="0">if mode == 0 </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Restrictive File Mode",
                        fmt.Sprintf("File mode '%s' grants no permissions to anyone", value),
                )
        }</span>

        // Warn about potentially problematic permissions
        <span class="cov0" title="0">if mode&amp;0002 != 0 </span><span class="cov0" title="0">{ // World writable
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "World Writable File Mode",
                        fmt.Sprintf("File mode '%s' is world-writable, which may be a security risk", value),
                )
        }</span>

        <span class="cov0" title="0">if mode&amp;0044 == 0 &amp;&amp; mode&amp;0004 == 0 </span><span class="cov0" title="0">{ // Not readable by owner or group
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Unreadable File Mode",
                        fmt.Sprintf("File mode '%s' may make the file unreadable", value),
                )
        }</span>
}

// parseFileMode parses a file mode string into os.FileMode.
func parseFileMode(modeStr string) (os.FileMode, error) <span class="cov10" title="6">{
        if modeStr == "" </span><span class="cov1" title="1">{
                return 0644, nil // default
        }</span>

        // Check if it looks like an octal mode (only valid octal digits 0-7)
        <span class="cov9" title="5">octalPattern := regexp.MustCompile(`^0[0-7]{3}$|^[0-7]{3}$`)
        if octalPattern.MatchString(modeStr) </span><span class="cov6" title="3">{
                // Parse as octal
                var base int
                var modeValue string
                if modeStr[0] == '0' &amp;&amp; len(modeStr) &gt; 1 </span><span class="cov4" title="2">{
                        // Explicit octal (e.g., "0644")
                        base = 8
                        modeValue = modeStr
                }</span> else<span class="cov1" title="1"> if len(modeStr) == 3 || len(modeStr) == 4 </span><span class="cov1" title="1">{
                        // Implicit octal (e.g., "644")
                        base = 8
                        modeValue = modeStr
                }</span> else<span class="cov0" title="0"> {
                        return 0, fmt.Errorf("ambiguous file mode format")
                }</span>

                <span class="cov6" title="3">mode, err := strconv.ParseUint(modeValue, base, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid octal file mode: %w", err)
                }</span>
                <span class="cov6" title="3">if mode &gt; 0777 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("file mode %s is too permissive (maximum is 0777)", modeValue)
                }</span>
                <span class="cov6" title="3">return os.FileMode(mode), nil</span>
        }

        // If it doesn't match octal pattern, reject it
        <span class="cov4" title="2">return 0, fmt.Errorf("invalid file mode format '%s' (expected octal format like '0644' or '644' with digits 0-7 only)", modeStr)</span>
}

// ValidFileMode returns a validator which ensures that the provided value is a valid file mode.
func ValidFileMode() validator.String <span class="cov0" title="0">{
        return FileModeValidator{}
}</span>

// SecureFileMode returns a validator which ensures that the provided file mode is secure.
func SecureFileMode() validator.String <span class="cov0" title="0">{
        return secureFileModeValidator{}
}</span>

// secureFileModeValidator validates that a file mode is secure (not world-readable/writable).
type secureFileModeValidator struct{}

func (v secureFileModeValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a secure file mode (not world-readable or world-writable)"
}</span>

func (v secureFileModeValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

func (v secureFileModeValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return // Empty values are handled by other validators
        }</span>

        // Parse the file mode
        <span class="cov0" title="0">mode, err := parseFileMode(value)
        if err != nil </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid File Mode",
                        fmt.Sprintf("Invalid file mode '%s': %s", value, err),
                )
                return
        }</span>

        // Check for world-readable
        <span class="cov0" title="0">if mode&amp;0004 != 0 </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Insecure File Mode",
                        fmt.Sprintf("File mode '%s' is world-readable, which may be a security risk for sensitive files", value),
                )
                return
        }</span>

        // Check for world-writable
        <span class="cov0" title="0">if mode&amp;0002 != 0 </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Insecure File Mode",
                        fmt.Sprintf("File mode '%s' is world-writable, which is a security risk", value),
                )
                return
        }</span>

        // Check for group-readable for very sensitive files
        <span class="cov0" title="0">if mode&amp;0040 != 0 </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Group-Readable File Mode",
                        fmt.Sprintf("File mode '%s' is group-readable, consider using more restrictive permissions for sensitive files", value),
                )
        }</span>
}

// DirectoryFileMode returns a validator for directory file modes.
func DirectoryFileMode() validator.String <span class="cov0" title="0">{
        return directoryFileModeValidator{}
}</span>

// directoryFileModeValidator validates directory-specific file modes.
type directoryFileModeValidator struct{}

func (v directoryFileModeValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a valid directory file mode with execute permissions"
}</span>

func (v directoryFileModeValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

func (v directoryFileModeValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return // Empty values are handled by other validators
        }</span>

        // Parse the file mode
        <span class="cov0" title="0">mode, err := parseFileMode(value)
        if err != nil </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Directory Mode",
                        fmt.Sprintf("Invalid directory mode '%s': %s", value, err),
                )
                return
        }</span>

        // Directories need execute permission to be accessible
        <span class="cov0" title="0">if mode&amp;0100 == 0 </span><span class="cov0" title="0">{ // Owner execute
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Directory Mode",
                        fmt.Sprintf("Directory mode '%s' lacks owner execute permission, directory will not be accessible", value),
                )
                return
        }</span>

        // Warn if directory is not readable by owner
        <span class="cov0" title="0">if mode&amp;0400 == 0 </span><span class="cov0" title="0">{ // Owner read
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Directory Not Readable",
                        fmt.Sprintf("Directory mode '%s' lacks owner read permission, directory contents may not be listable", value),
                )
        }</span>

        // Common directory modes validation
        <span class="cov0" title="0">commonDirModes := []os.FileMode{0755, 0750, 0700, 0711}
        isCommon := false
        for _, common := range commonDirModes </span><span class="cov0" title="0">{
                if mode == common </span><span class="cov0" title="0">{
                        isCommon = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isCommon </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Unusual Directory Mode",
                        fmt.Sprintf("Directory mode '%s' is unusual, common modes are 0755, 0750, 0700, or 0711", value),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package validators

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// PathValidator validates that a string is a valid path.
type PathValidator struct {
        allowRelative bool
        mustExist     bool
        mustBeDir     bool
}

// Description returns a description of the validator.
func (v PathValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        desc := "value must be a valid path"
        if !v.allowRelative </span><span class="cov0" title="0">{
                desc += " (absolute path required)"
        }</span>
        <span class="cov0" title="0">if v.mustExist </span><span class="cov0" title="0">{
                desc += " and must exist"
        }</span>
        <span class="cov0" title="0">if v.mustBeDir </span><span class="cov0" title="0">{
                desc += " and must be a directory"
        }</span>
        <span class="cov0" title="0">return desc</span>
}

// MarkdownDescription returns a markdown description of the validator.
func (v PathValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// ValidateString performs the validation.
func (v PathValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Path",
                        "Path cannot be empty",
                )
                return
        }</span>

        // Check for invalid characters
        <span class="cov0" title="0">if strings.Contains(value, "\x00") </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Path",
                        "Path cannot contain null characters",
                )
                return
        }</span>

        // Check if absolute path is required
        <span class="cov0" title="0">if !v.allowRelative &amp;&amp; !filepath.IsAbs(value) &amp;&amp; !strings.HasPrefix(value, "~") </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Path",
                        fmt.Sprintf("Path must be absolute, got: %s", value),
                )
                return
        }</span>

        // Expand tilde if present (for existence checks)
        <span class="cov0" title="0">expandedPath := value
        if strings.HasPrefix(value, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err == nil </span><span class="cov0" title="0">{
                        expandedPath = filepath.Join(homeDir, value[1:])
                }</span>
        }

        // Convert to absolute path for existence checks
        <span class="cov0" title="0">if v.mustExist || v.mustBeDir </span><span class="cov0" title="0">{
                absPath, err := filepath.Abs(expandedPath)
                if err != nil </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Invalid Path",
                                fmt.Sprintf("Cannot resolve path: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">expandedPath = absPath</span>
        }

        // Check if path must exist
        <span class="cov0" title="0">if v.mustExist </span><span class="cov0" title="0">{
                if _, err := os.Stat(expandedPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Path Not Found",
                                fmt.Sprintf("Path does not exist: %s", expandedPath),
                        )
                        return
                }</span>
        }

        // Check if path must be a directory
        <span class="cov0" title="0">if v.mustBeDir </span><span class="cov0" title="0">{
                if info, err := os.Stat(expandedPath); err == nil </span><span class="cov0" title="0">{
                        if !info.IsDir() </span><span class="cov0" title="0">{
                                response.Diagnostics.AddAttributeError(
                                        request.Path,
                                        "Invalid Path Type",
                                        fmt.Sprintf("Path must be a directory, got file: %s", expandedPath),
                                )
                                return
                        }</span>
                } else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Path Access Error",
                                fmt.Sprintf("Cannot access path: %s", err),
                        )
                        return
                }</span>
        }
}

// ValidPath returns a validator which ensures that the provided value is a valid path.
func ValidPath() validator.String <span class="cov0" title="0">{
        return PathValidator{
                allowRelative: true,
                mustExist:     false,
                mustBeDir:     false,
        }
}</span>

// AbsolutePath returns a validator which ensures that the provided value is an absolute path.
func AbsolutePath() validator.String <span class="cov0" title="0">{
        return PathValidator{
                allowRelative: false,
                mustExist:     false,
                mustBeDir:     false,
        }
}</span>

// ExistingPath returns a validator which ensures that the provided path exists.
func ExistingPath() validator.String <span class="cov0" title="0">{
        return PathValidator{
                allowRelative: true,
                mustExist:     true,
                mustBeDir:     false,
        }
}</span>

// ExistingDirectory returns a validator which ensures that the provided path exists and is a directory.
func ExistingDirectory() validator.String <span class="cov0" title="0">{
        return PathValidator{
                allowRelative: true,
                mustExist:     true,
                mustBeDir:     true,
        }
}</span>

// WritableDirectory returns a validator which ensures that the provided path is a writable directory.
func WritableDirectory() validator.String <span class="cov0" title="0">{
        return writableDirectoryValidator{}
}</span>

// writableDirectoryValidator validates that a path is a writable directory.
type writableDirectoryValidator struct{}

func (v writableDirectoryValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a writable directory path"
}</span>

func (v writableDirectoryValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

func (v writableDirectoryValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Path",
                        "Path cannot be empty",
                )
                return
        }</span>

        // Expand tilde if present
        <span class="cov0" title="0">expandedPath := value
        if strings.HasPrefix(value, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Path Expansion Error",
                                fmt.Sprintf("Cannot expand home directory: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">expandedPath = filepath.Join(homeDir, value[1:])</span>
        }

        // Convert to absolute path
        <span class="cov0" title="0">absPath, err := filepath.Abs(expandedPath)
        if err != nil </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Path",
                        fmt.Sprintf("Cannot resolve path: %s", err),
                )
                return
        }</span>

        // Check if directory exists or can be created
        <span class="cov0" title="0">if info, err := os.Stat(absPath); err == nil </span><span class="cov0" title="0">{
                // Directory exists, check if it's writable
                if !info.IsDir() </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Invalid Path Type",
                                fmt.Sprintf("Path must be a directory, got file: %s", absPath),
                        )
                        return
                }</span>

                // Test write access by creating a temporary file
                <span class="cov0" title="0">tempFile := filepath.Join(absPath, ".terraform-provider-dotfiles-write-test")
                if file, err := os.Create(tempFile); err != nil </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Directory Not Writable",
                                fmt.Sprintf("Directory is not writable: %s", absPath),
                        )
                        return
                }</span> else<span class="cov0" title="0"> {
                        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue
                                fmt.Printf("Warning: failed to close temp file: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">if err := os.Remove(tempFile); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue - this is just cleanup
                                fmt.Printf("Warning: failed to remove temp file: %v\n", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Directory doesn't exist, check if parent is writable
                parentDir := filepath.Dir(absPath)
                if parentInfo, err := os.Stat(parentDir); err != nil </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Parent Directory Not Found",
                                fmt.Sprintf("Parent directory does not exist: %s", parentDir),
                        )
                        return
                }</span> else<span class="cov0" title="0"> if !parentInfo.IsDir() </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Invalid Parent Path",
                                fmt.Sprintf("Parent path is not a directory: %s", parentDir),
                        )
                        return
                }</span>

                // Test write access in parent directory
                <span class="cov0" title="0">tempFile := filepath.Join(parentDir, ".terraform-provider-dotfiles-write-test")
                if file, err := os.Create(tempFile); err != nil </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeError(
                                request.Path,
                                "Parent Directory Not Writable",
                                fmt.Sprintf("Cannot create directory in parent: %s", parentDir),
                        )
                        return
                }</span> else<span class="cov0" title="0"> {
                        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue
                                fmt.Printf("Warning: failed to close temp file: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">if err := os.Remove(tempFile); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue - this is just cleanup
                                fmt.Printf("Warning: failed to remove temp file: %v\n", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Path Access Error",
                        fmt.Sprintf("Cannot access path: %s", err),
                )
                return
        }</span>
}

// EnvironmentVariableExpansion returns a validator that supports environment variable expansion.
func EnvironmentVariableExpansion() validator.String <span class="cov0" title="0">{
        return envVarValidator{}
}</span>

// envVarValidator validates and expands environment variables in paths.
type envVarValidator struct{}

func (v envVarValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value supports environment variable expansion (e.g., $HOME, ${HOME})"
}</span>

func (v envVarValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

func (v envVarValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return // Empty values are handled by other validators
        }</span>

        // Check for valid environment variable syntax
        // Matches $VAR or ${VAR} patterns
        <span class="cov0" title="0">envVarPattern := regexp.MustCompile(`\$\{?[A-Za-z_][A-Za-z0-9_]*\}?`)
        matches := envVarPattern.FindAllString(value, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                // Extract variable name
                varName := match
                if strings.HasPrefix(match, "${") &amp;&amp; strings.HasSuffix(match, "}") </span><span class="cov0" title="0">{
                        varName = match[2 : len(match)-1]
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(match, "$") </span><span class="cov0" title="0">{
                        varName = match[1:]
                }</span>

                // Check if environment variable exists (warning only)
                <span class="cov0" title="0">if os.Getenv(varName) == "" </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeWarning(
                                request.Path,
                                "Environment Variable Not Set",
                                fmt.Sprintf("Environment variable '%s' is not set, expansion may result in empty string", varName),
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package validators

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// TemplateVariableNameValidator validates that a string is a valid template variable name.
type TemplateVariableNameValidator struct{}

// Description returns a description of the validator.
func (v TemplateVariableNameValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a valid template variable name (alphanumeric and underscores, starting with letter or underscore)"
}</span>

// MarkdownDescription returns a markdown description of the validator.
func (v TemplateVariableNameValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// ValidateString performs the validation.
func (v TemplateVariableNameValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Template Variable Name",
                        "Template variable name cannot be empty",
                )
                return
        }</span>

        // Check if it's a valid identifier
        <span class="cov0" title="0">validName := regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)
        if !validName.MatchString(value) </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Template Variable Name",
                        fmt.Sprintf("Template variable name '%s' must start with a letter or underscore and contain only letters, numbers, and underscores", value),
                )
                return
        }</span>

        // Check for reserved keywords that might conflict with template engines
        <span class="cov0" title="0">reservedKeywords := []string{
                "if", "else", "end", "range", "with", "define", "template", "block",
                "true", "false", "nil", "null", "undefined",
                "index", "len", "print", "printf", "println",
        }

        lowerValue := strings.ToLower(value)
        for _, keyword := range reservedKeywords </span><span class="cov0" title="0">{
                if lowerValue == keyword </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeWarning(
                                request.Path,
                                "Reserved Template Variable Name",
                                fmt.Sprintf("Template variable name '%s' is a reserved keyword and may cause conflicts", value),
                        )
                        break</span>
                }
        }

        // Warn about potentially confusing names
        <span class="cov0" title="0">if strings.HasPrefix(lowerValue, "system") || strings.HasPrefix(lowerValue, "platform") </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Potentially Conflicting Variable Name",
                        fmt.Sprintf("Template variable name '%s' may conflict with built-in system/platform variables", value),
                )
        }</span>
}

// ValidTemplateVariableName returns a validator which ensures that the provided value is a valid template variable name.
func ValidTemplateVariableName() validator.String <span class="cov0" title="0">{
        return TemplateVariableNameValidator{}
}</span>

// TemplateEngineValidator validates that a string is a supported template engine.
type TemplateEngineValidator struct{}

// Description returns a description of the validator.
func (v TemplateEngineValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return "value must be a supported template engine: 'go', 'handlebars', or 'mustache'"
}</span>

// MarkdownDescription returns a markdown description of the validator.
func (v TemplateEngineValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// ValidateString performs the validation.
func (v TemplateEngineValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return // Empty values default to "go"
        }</span>

        <span class="cov0" title="0">supportedEngines := []string{"go", "handlebars", "mustache"}
        for _, engine := range supportedEngines </span><span class="cov0" title="0">{
                if value == engine </span><span class="cov0" title="0">{
                        return // Valid engine
                }</span>
        }

        <span class="cov0" title="0">response.Diagnostics.AddAttributeError(
                request.Path,
                "Unsupported Template Engine",
                fmt.Sprintf("Template engine '%s' is not supported. Supported engines are: %s", value, strings.Join(supportedEngines, ", ")),
        )</span>
}

// ValidTemplateEngine returns a validator which ensures that the provided value is a supported template engine.
func ValidTemplateEngine() validator.String <span class="cov0" title="0">{
        return TemplateEngineValidator{}
}</span>

// TemplateSyntaxValidator validates basic template syntax.
type TemplateSyntaxValidator struct {
        engine string
}

// Description returns a description of the validator.
func (v TemplateSyntaxValidator) Description(_ context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("value must contain valid %s template syntax", v.engine)
}</span>

// MarkdownDescription returns a markdown description of the validator.
func (v TemplateSyntaxValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// ValidateString performs the validation.
func (v TemplateSyntaxValidator) ValidateString(ctx context.Context, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">value := request.ConfigValue.ValueString()
        if value == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Basic syntax validation for template delimiters
        <span class="cov0" title="0">if !v.validateBasicSyntax(value) </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeError(
                        request.Path,
                        "Invalid Template Syntax",
                        fmt.Sprintf("Template contains unmatched delimiters or invalid syntax for %s engine", v.engine),
                )
                return
        }</span>

        // Engine-specific validation
        <span class="cov0" title="0">switch v.engine </span>{
        case "go":<span class="cov0" title="0">
                v.validateGoTemplate(value, request, response)</span>
        case "handlebars":<span class="cov0" title="0">
                v.validateHandlebarsTemplate(value, request, response)</span>
        case "mustache":<span class="cov0" title="0">
                v.validateMustacheTemplate(value, request, response)</span>
        }
}

// validateBasicSyntax checks for balanced delimiters.
func (v TemplateSyntaxValidator) validateBasicSyntax(content string) bool <span class="cov0" title="0">{
        openCount := strings.Count(content, "{{")
        closeCount := strings.Count(content, "}}")
        return openCount == closeCount
}</span>

// validateGoTemplate validates Go template syntax.
func (v TemplateSyntaxValidator) validateGoTemplate(content string, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        // Check for common Go template patterns
        goPatterns := []string{`\{\{\.`, `\{\{range`, `\{\{if`, `\{\{with`, `\{\{end\}\}`}
        hasGoSyntax := false
        for _, pattern := range goPatterns </span><span class="cov0" title="0">{
                if matched, _ := regexp.MatchString(pattern, content); matched </span><span class="cov0" title="0">{
                        hasGoSyntax = true
                        break</span>
                }
        }

        // If it contains template delimiters but no Go syntax, warn
        <span class="cov0" title="0">if strings.Contains(content, "{{") &amp;&amp; !hasGoSyntax </span><span class="cov0" title="0">{
                response.Diagnostics.AddAttributeWarning(
                        request.Path,
                        "Potential Template Syntax Issue",
                        "Template contains delimiters but no recognizable Go template syntax patterns",
                )
        }</span>
}

// validateHandlebarsTemplate validates Handlebars template syntax.
func (v TemplateSyntaxValidator) validateHandlebarsTemplate(content string, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        // Check for Handlebars-specific syntax
        handlebarsPatterns := []string{`\{\{#if`, `\{\{#each`, `\{\{#with`, `\{\{/`, `\{\{#unless`}
        hasHandlebarsSyntax := false
        for _, pattern := range handlebarsPatterns </span><span class="cov0" title="0">{
                if matched, _ := regexp.MatchString(pattern, content); matched </span><span class="cov0" title="0">{
                        hasHandlebarsSyntax = true
                        break</span>
                }
        }
        <span class="cov0" title="0">_ = hasHandlebarsSyntax // Reserved for future use

        // Check for unmatched block helpers
        if strings.Contains(content, "{{#") </span><span class="cov0" title="0">{
                ifCount := strings.Count(content, "{{#if")
                endIfCount := strings.Count(content, "{{/if}}")
                if ifCount != endIfCount </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeWarning(
                                request.Path,
                                "Unmatched Handlebars Blocks",
                                "Template may have unmatched {{#if}}/{{/if}} blocks",
                        )
                }</span>

                <span class="cov0" title="0">eachCount := strings.Count(content, "{{#each")
                endEachCount := strings.Count(content, "{{/each}}")
                if eachCount != endEachCount </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeWarning(
                                request.Path,
                                "Unmatched Handlebars Blocks",
                                "Template may have unmatched {{#each}}/{{/each}} blocks",
                        )
                }</span>
        }
}

// validateMustacheTemplate validates Mustache template syntax.
func (v TemplateSyntaxValidator) validateMustacheTemplate(content string, request validator.StringRequest, response *validator.StringResponse) <span class="cov0" title="0">{
        // Check for Mustache-specific syntax
        mustachePatterns := []string{`\{\{#`, `\{\{/`, `\{\{\^`, `\{\{&amp;`, `\{\{\{.*\}\}\}`}
        hasMustacheSyntax := false
        for _, pattern := range mustachePatterns </span><span class="cov0" title="0">{
                if matched, _ := regexp.MatchString(pattern, content); matched </span><span class="cov0" title="0">{
                        hasMustacheSyntax = true
                        break</span>
                }
        }
        <span class="cov0" title="0">_ = hasMustacheSyntax // Reserved for future use

        // Check for unmatched sections
        if strings.Contains(content, "{{#") || strings.Contains(content, "{{^") </span><span class="cov0" title="0">{
                // This is a simplified check - real validation would need proper parsing
                openSections := strings.Count(content, "{{#") + strings.Count(content, "{{^")
                closeSections := strings.Count(content, "{{/")
                if openSections != closeSections </span><span class="cov0" title="0">{
                        response.Diagnostics.AddAttributeWarning(
                                request.Path,
                                "Unmatched Mustache Sections",
                                "Template may have unmatched section tags",
                        )
                }</span>
        }
}

// ValidTemplateSyntax returns a validator which ensures that the provided value contains valid template syntax for the specified engine.
func ValidTemplateSyntax(engine string) validator.String <span class="cov0" title="0">{
        return TemplateSyntaxValidator{engine: engine}
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package main

import (
        "context"
        "flag"
        "log"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/provider"
)

var (
        // these will be set by the goreleaser configuration
        // to appropriate values for the compiled binary.
        version string = "dev"

        // goreleaser can pass other information to the main package, such as the specific commit
        // https://goreleaser.com/cookbooks/using-main.version/
)

func main() <span class="cov0" title="0">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the provider with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                Address: "registry.terraform.io/jamesainslie/dotfiles",
                Debug:   debug,
        }

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
