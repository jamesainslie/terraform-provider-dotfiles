
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/application_detection_models.go (100.0%)</option>
				
				<option value="file1">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/application_resource.go (23.0%)</option>
				
				<option value="file2">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/client.go (79.2%)</option>
				
				<option value="file3">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/config.go (85.1%)</option>
				
				<option value="file4">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/directory_resource.go (5.0%)</option>
				
				<option value="file5">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/enhanced_backup_models.go (100.0%)</option>
				
				<option value="file6">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/enhanced_template_models.go (100.0%)</option>
				
				<option value="file7">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/file_info_data_source.go (50.0%)</option>
				
				<option value="file8">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/file_resource.go (34.4%)</option>
				
				<option value="file9">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/permissions.go (57.6%)</option>
				
				<option value="file10">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/provider.go (14.1%)</option>
				
				<option value="file11">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/repository_resource.go (20.8%)</option>
				
				<option value="file12">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/symlink_resource.go (7.5%)</option>
				
				<option value="file13">github.com/jamesainslie/terraform-provider-dotfiles/internal/provider/system_data_source.go (58.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// DetectionMethodModel describes a detection method configuration.
type DetectionMethodModel struct {
        Type    types.String `tfsdk:"type"`
        Test    types.String `tfsdk:"test"`
        Path    types.String `tfsdk:"path"`
        Name    types.String `tfsdk:"name"`
        Manager types.String `tfsdk:"manager"`
}

// ConfigMappingModel describes a configuration mapping.
type ConfigMappingModel struct {
        TargetPath         types.String `tfsdk:"target_path"`
        TargetPathTemplate types.String `tfsdk:"target_path_template"`
        MergeStrategy      types.String `tfsdk:"merge_strategy"`
        Required           types.Bool   `tfsdk:"required"`
}

// DetectionMethodsModel represents detection methods configuration.
type DetectionMethodsModel struct {
        Methods []DetectionMethodModel `tfsdk:"methods"`
}

// GetDetectionMethodsSchemaBlock returns the schema block for detection methods.
func GetDetectionMethodsSchemaBlock() schema.ListNestedBlock <span class="cov8" title="1">{
        return schema.ListNestedBlock{
                MarkdownDescription: "Application detection methods configuration",
                NestedObject: schema.NestedBlockObject{
                        Attributes: map[string]schema.Attribute{
                                "type": schema.StringAttribute{
                                        Required:            true,
                                        MarkdownDescription: "Detection method type: command, file, brew_cask, package_manager",
                                },
                                "test": schema.StringAttribute{
                                        Optional:            true,
                                        MarkdownDescription: "Command to test for command-type detection",
                                },
                                "path": schema.StringAttribute{
                                        Optional:            true,
                                        MarkdownDescription: "File/directory path to check for file-type detection",
                                },
                                "name": schema.StringAttribute{
                                        Optional:            true,
                                        MarkdownDescription: "Package/cask name for package manager detection",
                                },
                                "manager": schema.StringAttribute{
                                        Optional:            true,
                                        MarkdownDescription: "Package manager to use: brew, apt, yum, pacman",
                                },
                        },
                },
        }
}</span>

// ConfigMappingsModel represents configuration mappings.
type ConfigMappingsModel struct {
        Mappings map[string]ConfigMappingModel `tfsdk:"mappings"`
}

// GetConfigMappingsSchemaBlock returns the schema block for configuration mappings.
func GetConfigMappingsSchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Configuration file mappings and strategies",
                Attributes: map[string]schema.Attribute{
                        "target_path": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Target path for configuration file",
                        },
                        "target_path_template": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Template for generating target path ({{.app_support_dir}}, {filename})",
                        },
                        "merge_strategy": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("replace"),
                                MarkdownDescription: "Merge strategy: replace, shallow_merge, deep_merge",
                        },
                        "required": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Whether this configuration file is required",
                        },
                },
        }
}</span>

// GetApplicationDetectionAttributes returns attributes for application detection in existing resources.
func GetApplicationDetectionAttributes() map[string]schema.Attribute <span class="cov8" title="1">{
        return map[string]schema.Attribute{
                "require_application": schema.StringAttribute{
                        Optional:            true,
                        MarkdownDescription: "Require this application to be installed before configuring",
                },
                "application_version_min": schema.StringAttribute{
                        Optional:            true,
                        MarkdownDescription: "Minimum required version of the application",
                },
                "application_version_max": schema.StringAttribute{
                        Optional:            true,
                        MarkdownDescription: "Maximum supported version of the application",
                },
                "skip_if_app_missing": schema.BoolAttribute{
                        Optional:            true,
                        Computed:            true,
                        Default:             booldefault.StaticBool(false),
                        MarkdownDescription: "Skip this resource if required application is missing",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;ApplicationResource{}

func NewApplicationResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ApplicationResource{}
}</span>

// ApplicationResource defines the application resource implementation.
type ApplicationResource struct {
        client *DotfilesClient
}

// ApplicationResourceModel describes the application resource data model.
type ApplicationResourceModel struct {
        ID                   types.String `tfsdk:"id"`
        Repository           types.String `tfsdk:"repository"`
        Application          types.String `tfsdk:"application"`
        SourcePath           types.String `tfsdk:"source_path"`
        DetectInstallation   types.Bool   `tfsdk:"detect_installation"`
        SkipIfNotInstalled   types.Bool   `tfsdk:"skip_if_not_installed"`
        WarnIfNotInstalled   types.Bool   `tfsdk:"warn_if_not_installed"`
        MinVersion           types.String `tfsdk:"min_version"`
        MaxVersion           types.String `tfsdk:"max_version"`
        ConditionalOperation types.Bool   `tfsdk:"conditional"`
        ConfigStrategy       types.String `tfsdk:"config_strategy"`

        // Detection configuration blocks
        DetectionMethods []DetectionMethodModel `tfsdk:"detection_methods"`
        ConfigMappings   *ConfigMappingModel    `tfsdk:"config_mappings"`

        // Computed attributes
        Installed        types.Bool   `tfsdk:"installed"`
        Version          types.String `tfsdk:"version"`
        InstallationPath types.String `tfsdk:"installation_path"`
        LastChecked      types.String `tfsdk:"last_checked"`
        DetectionResult  types.String `tfsdk:"detection_result"`
}

func (r *ApplicationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_application"
}</span>

func (r *ApplicationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages application-specific dotfiles with conditional installation detection",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Application resource identifier",
                        },
                        "repository": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Repository ID this application belongs to",
                        },
                        "application": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Application name/identifier",
                        },
                        "source_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to application configuration in repository",
                        },
                        "detect_installation": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Enable application installation detection",
                        },
                        "skip_if_not_installed": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Skip configuration if application is not installed",
                        },
                        "warn_if_not_installed": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Warn if application is not installed",
                        },
                        "min_version": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Minimum required application version",
                        },
                        "max_version": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Maximum supported application version",
                        },
                        "conditional": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Enable conditional configuration based on installation",
                        },
                        "config_strategy": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("symlink"),
                                MarkdownDescription: "Configuration strategy: symlink, copy, merge, template",
                        },
                        "installed": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the application is detected as installed",
                        },
                        "version": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Detected application version",
                        },
                        "installation_path": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Path where application is installed",
                        },
                        "last_checked": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Last time installation was checked",
                        },
                        "detection_result": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Result of the last detection attempt",
                        },
                },
                Blocks: map[string]schema.Block{
                        "detection_methods": GetDetectionMethodsSchemaBlock(),
                        "config_mappings":   GetConfigMappingsSchemaBlock(),
                },
        }
}</span>

func (r *ApplicationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else. Please report this issue to the provider developers.",
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *ApplicationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating application resource", map[string]interface{}{
                "application":         data.Application.ValueString(),
                "source_path":         data.SourcePath.ValueString(),
                "detect_installation": data.DetectInstallation.ValueBool(),
        })

        // Perform application detection
        detectionResult := r.performApplicationDetection(ctx, &amp;data)

        // Update computed attributes with detection results
        data.Installed = types.BoolValue(detectionResult.Installed)
        data.Version = types.StringValue(detectionResult.Version)
        data.InstallationPath = types.StringValue(detectionResult.InstallationPath)
        data.LastChecked = types.StringValue(time.Now().Format(time.RFC3339))
        data.DetectionResult = types.StringValue(detectionResult.Method)

        // Handle conditional behavior
        if data.SkipIfNotInstalled.ValueBool() &amp;&amp; !detectionResult.Installed </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Skipping application configuration - not installed", map[string]interface{}{
                        "application": data.Application.ValueString(),
                })
                // Set ID and save state (but don't configure files)
                data.ID = data.Application
                resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
                return
        }</span>

        <span class="cov0" title="0">if data.WarnIfNotInstalled.ValueBool() &amp;&amp; !detectionResult.Installed </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Application not installed",
                        fmt.Sprintf("Application %s is not installed but configuration will proceed", data.Application.ValueString()),
                )
        }</span>

        // Deploy configuration files if config_mappings is specified
        <span class="cov0" title="0">if data.ConfigMappings != nil </span><span class="cov0" title="0">{
                err := r.deployApplicationConfig(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Failed to deploy application configuration",
                                fmt.Sprintf("Error deploying config for %s: %v", data.Application.ValueString(), err),
                        )
                        return
                }</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Application
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Application resource created successfully", map[string]interface{}{
                "application": data.Application.ValueString(),
                "installed":   detectionResult.Installed,
                "version":     detectionResult.Version,
        })</span>
}

func (r *ApplicationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Re-perform application detection to check current state
        <span class="cov0" title="0">if data.DetectInstallation.ValueBool() </span><span class="cov0" title="0">{
                detectionResult := r.performApplicationDetection(ctx, &amp;data)
                // Update computed attributes
                data.Installed = types.BoolValue(detectionResult.Installed)
                data.Version = types.StringValue(detectionResult.Version)
                data.InstallationPath = types.StringValue(detectionResult.InstallationPath)
                data.LastChecked = types.StringValue(time.Now().Format(time.RFC3339))
                data.DetectionResult = types.StringValue(detectionResult.Method)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ApplicationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating application resource", map[string]interface{}{
                "application":         data.Application.ValueString(),
                "source_path":         data.SourcePath.ValueString(),
                "detect_installation": data.DetectInstallation.ValueBool(),
        })

        // Perform application detection (same as Create method)
        detectionResult := r.performApplicationDetection(ctx, &amp;data)

        // Update computed attributes with detection results
        data.Installed = types.BoolValue(detectionResult.Installed)
        data.Version = types.StringValue(detectionResult.Version)
        data.InstallationPath = types.StringValue(detectionResult.InstallationPath)
        data.LastChecked = types.StringValue(time.Now().Format(time.RFC3339))
        data.DetectionResult = types.StringValue(detectionResult.Method)

        // Handle conditional behavior
        if data.SkipIfNotInstalled.ValueBool() &amp;&amp; !detectionResult.Installed </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Skipping application configuration update - not installed", map[string]interface{}{
                        "application": data.Application.ValueString(),
                })
                // Update ID and save state (but don't configure files)
                data.ID = data.Application
                resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
                return
        }</span>

        <span class="cov0" title="0">if data.WarnIfNotInstalled.ValueBool() &amp;&amp; !detectionResult.Installed </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Application not installed",
                        fmt.Sprintf("Application %s is not installed but configuration update will proceed", data.Application.ValueString()),
                )
        }</span>

        // Deploy configuration files if config_mappings is specified
        <span class="cov0" title="0">if data.ConfigMappings != nil </span><span class="cov0" title="0">{
                err := r.deployApplicationConfig(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Failed to deploy application configuration",
                                fmt.Sprintf("Error deploying config for %s: %v", data.Application.ValueString(), err),
                        )
                        return
                }</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Application
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Application resource updated successfully", map[string]interface{}{
                "application": data.Application.ValueString(),
                "installed":   detectionResult.Installed,
                "version":     detectionResult.Version,
        })</span>
}

func (r *ApplicationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ApplicationResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting application resource", map[string]interface{}{
                "application": data.Application.ValueString(),
        })</span>

        // TODO: Implement cleanup of application configuration files
        // This would remove symlinks/files created by this resource
}

// ApplicationDetectionResult represents the result of application detection.
type ApplicationDetectionResult struct {
        Installed        bool
        Version          string
        InstallationPath string
        Method           string
}

// performApplicationDetection performs application detection using configured methods.
func (r *ApplicationResource) performApplicationDetection(ctx context.Context, data *ApplicationResourceModel) *ApplicationDetectionResult <span class="cov8" title="1">{
        if !data.DetectInstallation.ValueBool() </span><span class="cov0" title="0">{
                return &amp;ApplicationDetectionResult{
                        Installed: true, // Assume installed if detection is disabled
                        Method:    "disabled",
                }
        }</span>

        <span class="cov8" title="1">appName := data.Application.ValueString()

        // Use default detection methods since blocks are handled separately
        detectionMethods := []string{"command", "file"}

        // Try each detection method
        for _, method := range detectionMethods </span><span class="cov8" title="1">{
                result := r.tryDetectionMethod(ctx, appName, method)
                if result.Installed </span><span class="cov8" title="1">{
                        tflog.Info(ctx, "Application detected", map[string]interface{}{
                                "application": appName,
                                "method":      method,
                                "version":     result.Version,
                                "path":        result.InstallationPath,
                        })
                        return result
                }</span>
        }

        // No detection method succeeded
        <span class="cov8" title="1">return &amp;ApplicationDetectionResult{
                Installed: false,
                Method:    "not_found",
        }</span>
}

// tryDetectionMethod attempts to detect application using specified method.
func (r *ApplicationResource) tryDetectionMethod(ctx context.Context, appName, method string) *ApplicationDetectionResult <span class="cov8" title="1">{
        platformProvider := platform.DetectPlatform()

        switch method </span>{
        case "command":<span class="cov8" title="1">
                return r.detectByCommand(ctx, appName)</span>
        case "file":<span class="cov8" title="1">
                return r.detectByFile(ctx, appName, platformProvider)</span>
        case "brew_cask":<span class="cov8" title="1">
                return r.detectByBrewCask(ctx, appName)</span>
        case "package_manager":<span class="cov8" title="1">
                return r.detectByPackageManager(ctx, appName, platformProvider)</span>
        default:<span class="cov0" title="0">
                return &amp;ApplicationDetectionResult{Installed: false}</span>
        }
}

// detectByCommand detects application by running a command.
func (r *ApplicationResource) detectByCommand(ctx context.Context, appName string) *ApplicationDetectionResult <span class="cov8" title="1">{
        // Use command -v to check if command exists in PATH
        cmd := fmt.Sprintf("command -v %s", appName)

        // Execute command using the same shell execution logic as hooks
        err := executeShellCommand(ctx, cmd)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;ApplicationDetectionResult{Installed: false}
        }</span>

        // TODO: Extract version information if possible
        <span class="cov8" title="1">return &amp;ApplicationDetectionResult{
                Installed: true,
                Method:    "command",
                Version:   "unknown", // Could be enhanced to extract version
        }</span>
}

// detectByFile detects application by checking file/directory existence.
func (r *ApplicationResource) detectByFile(ctx context.Context, appName string, platformProvider platform.PlatformProvider) *ApplicationDetectionResult <span class="cov8" title="1">{
        // Use context for structured logging and to avoid unused parameter warnings
        tflog.Debug(ctx, "detectByFile invoked", map[string]interface{}{
                "application": appName,
                "platform":    platformProvider.GetPlatform(),
        })
        // Define common application installation paths by platform
        var searchPaths []string

        switch platformProvider.GetPlatform() </span>{
        case "macos":<span class="cov8" title="1">
                searchPaths = []string{
                        fmt.Sprintf("/Applications/%s.app", capitalizeFirst(appName)),
                        fmt.Sprintf("/Applications/%s.app", appName),
                        fmt.Sprintf("/System/Applications/%s.app", capitalizeFirst(appName)),
                        // For testing, also check in common test locations
                        fmt.Sprintf("./%s.app", capitalizeFirst(appName)),
                        fmt.Sprintf("./%s.app", appName),
                }</span>
        case "linux":<span class="cov0" title="0">
                searchPaths = []string{
                        fmt.Sprintf("/usr/bin/%s", appName),
                        fmt.Sprintf("/usr/local/bin/%s", appName),
                        fmt.Sprintf("/opt/%s", appName),
                        // For testing
                        fmt.Sprintf("./%s", appName),
                }</span>
        case "windows":<span class="cov0" title="0">
                searchPaths = []string{
                        fmt.Sprintf("C:\\Program Files\\%s", capitalizeFirst(appName)),
                        fmt.Sprintf("C:\\Program Files (x86)\\%s", capitalizeFirst(appName)),
                        // For testing
                        fmt.Sprintf(".\\%s", appName),
                }</span>
        }

        // Check each path
        <span class="cov8" title="1">for _, path := range searchPaths </span><span class="cov8" title="1">{
                var expandedPath string
                var err error

                // Handle relative paths for testing
                if strings.HasPrefix(path, "./") || strings.HasPrefix(path, ".\\") </span><span class="cov8" title="1">{
                        // Use working directory as base for relative paths
                        expandedPath = path
                }</span> else<span class="cov8" title="1"> {
                        expandedPath, err = platformProvider.ExpandPath(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if _, err := os.Stat(expandedPath); err == nil </span><span class="cov8" title="1">{
                        return &amp;ApplicationDetectionResult{
                                Installed:        true,
                                InstallationPath: expandedPath,
                                Method:           "file",
                                Version:          "unknown", // Could be enhanced to extract version from app bundle
                        }
                }</span>
        }

        <span class="cov8" title="1">return &amp;ApplicationDetectionResult{Installed: false}</span>
}

// detectByBrewCask detects application installed via Homebrew cask.
func (r *ApplicationResource) detectByBrewCask(ctx context.Context, appName string) *ApplicationDetectionResult <span class="cov8" title="1">{
        cmd := fmt.Sprintf("brew list --cask | grep -q '^%s$'", appName)

        err := executeShellCommand(ctx, cmd)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;ApplicationDetectionResult{Installed: false}
        }</span>

        <span class="cov0" title="0">return &amp;ApplicationDetectionResult{
                Installed: true,
                Method:    "brew_cask",
                Version:   "unknown", // Could be enhanced to get brew cask version
        }</span>
}

// detectByPackageManager detects application via system package manager.
func (r *ApplicationResource) detectByPackageManager(ctx context.Context, appName string, platformProvider platform.PlatformProvider) *ApplicationDetectionResult <span class="cov8" title="1">{
        var cmd string

        switch platformProvider.GetPlatform() </span>{
        case "macos":<span class="cov8" title="1">
                cmd = fmt.Sprintf("brew list | grep -q '^%s$'", appName)</span>
        case "linux":<span class="cov0" title="0">
                // Try common Linux package managers
                managers := []string{
                        fmt.Sprintf("dpkg -l | grep -q ' %s '", appName),      // Debian/Ubuntu
                        fmt.Sprintf("rpm -qa | grep -q '^%s-'", appName),      // RedHat/CentOS
                        fmt.Sprintf("pacman -Q %s &gt; /dev/null 2&gt;&amp;1", appName), // Arch
                }

                // Try each package manager
                for _, managerCmd := range managers </span><span class="cov0" title="0">{
                        if err := executeShellCommand(ctx, managerCmd); err == nil </span><span class="cov0" title="0">{
                                return &amp;ApplicationDetectionResult{
                                        Installed: true,
                                        Method:    "package_manager",
                                }
                        }</span>
                }
                <span class="cov0" title="0">return &amp;ApplicationDetectionResult{Installed: false}</span>
        default:<span class="cov0" title="0">
                return &amp;ApplicationDetectionResult{Installed: false}</span>
        }

        <span class="cov8" title="1">err := executeShellCommand(ctx, cmd)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;ApplicationDetectionResult{Installed: false}
        }</span>

        <span class="cov8" title="1">return &amp;ApplicationDetectionResult{
                Installed: true,
                Method:    "package_manager",
        }</span>
}

// capitalizeFirst capitalizes the first letter of a string.
func capitalizeFirst(s string) string <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(s[:1]) + s[1:]</span>
}

// deployApplicationConfig deploys configuration files based on config_mappings.
func (r *ApplicationResource) deployApplicationConfig(ctx context.Context, data *ApplicationResourceModel) error <span class="cov0" title="0">{
        if data.ConfigMappings == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deploying application configuration", map[string]interface{}{
                "application": data.Application.ValueString(),
                "source_path": data.SourcePath.ValueString(),
        })

        // Get the repository local path
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())
        sourcePath := data.SourcePath.ValueString()

        // Resolve full source path
        var fullSourcePath string
        if strings.HasPrefix(sourcePath, "/") </span><span class="cov0" title="0">{
                fullSourcePath = sourcePath
        }</span> else<span class="cov0" title="0"> {
                fullSourcePath = fmt.Sprintf("%s/%s", repositoryLocalPath, sourcePath)
        }</span>

        // Check if source path exists
        <span class="cov0" title="0">if _, err := os.Stat(fullSourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("source path does not exist: %s", fullSourcePath)
        }</span>

        // Deploy based on target path configuration
        <span class="cov0" title="0">var targetPath string
        if !data.ConfigMappings.TargetPath.IsNull() </span><span class="cov0" title="0">{
                targetPath = data.ConfigMappings.TargetPath.ValueString()
        }</span> else<span class="cov0" title="0"> if !data.ConfigMappings.TargetPathTemplate.IsNull() </span><span class="cov0" title="0">{
                // Expand target path template
                template := data.ConfigMappings.TargetPathTemplate.ValueString()
                expandedPath, err := r.expandTargetPathTemplate(template, data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to expand target path template: %w", err)
                }</span>
                <span class="cov0" title="0">targetPath = expandedPath</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("either target_path or target_path_template must be specified")
        }</span>

        // Expand tilde in target path
        <span class="cov0" title="0">if strings.HasPrefix(targetPath, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">targetPath = strings.Replace(targetPath, "~", homeDir, 1)</span>
        }

        // Create target directory if it doesn't exist
        <span class="cov0" title="0">targetDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory %s: %w", targetDir, err)
        }</span>

        // Deploy using the configured strategy
        <span class="cov0" title="0">strategy := data.ConfigStrategy.ValueString()
        if strategy == "" </span><span class="cov0" title="0">{
                strategy = r.client.Config.Strategy // Use provider default
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deploying config file", map[string]interface{}{
                "source":   fullSourcePath,
                "target":   targetPath,
                "strategy": strategy,
        })

        switch strategy </span>{
        case "symlink":<span class="cov0" title="0">
                return r.createSymlinkForConfig(fullSourcePath, targetPath)</span>
        case "copy":<span class="cov0" title="0">
                return r.copyConfigFile(fullSourcePath, targetPath)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported config strategy: %s", strategy)</span>
        }
}

// expandTargetPathTemplate expands a target path template with application variables.
func (r *ApplicationResource) expandTargetPathTemplate(template string, data *ApplicationResourceModel) (string, error) <span class="cov0" title="0">{
        // Get platform provider for directory paths
        platformProvider := platform.DetectPlatform()

        // Replace common template variables
        result := template

        // Replace {{.home_dir}}
        if strings.Contains(result, "{{.home_dir}}") </span><span class="cov0" title="0">{
                homeDir, err := platformProvider.GetHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">result = strings.ReplaceAll(result, "{{.home_dir}}", homeDir)</span>
        }

        // Replace {{.config_dir}}
        <span class="cov0" title="0">if strings.Contains(result, "{{.config_dir}}") </span><span class="cov0" title="0">{
                configDir, err := platformProvider.GetConfigDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get config directory: %w", err)
                }</span>
                <span class="cov0" title="0">result = strings.ReplaceAll(result, "{{.config_dir}}", configDir)</span>
        }

        // Replace {{.app_support_dir}}
        <span class="cov0" title="0">if strings.Contains(result, "{{.app_support_dir}}") </span><span class="cov0" title="0">{
                appSupportDir, err := platformProvider.GetAppSupportDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get app support directory: %w", err)
                }</span>
                <span class="cov0" title="0">result = strings.ReplaceAll(result, "{{.app_support_dir}}", appSupportDir)</span>
        }

        // Replace {{.application}}
        <span class="cov0" title="0">result = strings.ReplaceAll(result, "{{.application}}", data.Application.ValueString())

        return result, nil</span>
}

// createSymlinkForConfig creates a symlink from source to target.
func (r *ApplicationResource) createSymlinkForConfig(source, target string) error <span class="cov0" title="0">{
        // Remove existing file/symlink if it exists
        if _, err := os.Lstat(target); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing target %s: %w", target, err)
                }</span>
        }

        // Create symlink
        <span class="cov0" title="0">if err := os.Symlink(source, target); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create symlink from %s to %s: %w", source, target, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyConfigFile copies a file from source to target.
func (r *ApplicationResource) copyConfigFile(source, target string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", source, err)
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        // Remove existing file if it exists
        if _, err := os.Stat(target); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing target %s: %w", target, err)
                }</span>
        }

        <span class="cov0" title="0">targetFile, err := os.Create(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target file %s: %w", target, err)
        }</span>
        <span class="cov0" title="0">defer targetFile.Close()

        // Copy content
        if _, err := targetFile.ReadFrom(sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy content from %s to %s: %w", source, target, err)
        }</span>

        // Copy permissions
        <span class="cov0" title="0">sourceInfo, err := sourceFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source file info: %w", err)
        }</span>

        <span class="cov0" title="0">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set target file permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *ApplicationResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
)

// DotfilesClient provides the client interface for dotfiles operations.
type DotfilesClient struct {
        Config       *DotfilesConfig
        Platform     string
        Architecture string
        HomeDir      string
        ConfigDir    string
}

// NewDotfilesClient creates a new dotfiles client with the provided configuration.
func NewDotfilesClient(config *DotfilesConfig) (*DotfilesClient, error) <span class="cov8" title="1">{
        client := &amp;DotfilesClient{
                Config:       config,
                Architecture: runtime.GOARCH,
        }

        // Determine platform
        if config.AutoDetectPlatform || config.TargetPlatform == "auto" </span><span class="cov8" title="1">{
                client.Platform = detectPlatform()
        }</span> else<span class="cov8" title="1"> {
                client.Platform = config.TargetPlatform
        }</span>

        // Get home directory
        <span class="cov8" title="1">homeDir, err := getHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to determine home directory: %w", err)
        }</span>
        <span class="cov8" title="1">client.HomeDir = homeDir

        // Get config directory
        client.ConfigDir = getConfigDir(client.Platform, homeDir)

        return client, nil</span>
}

// detectPlatform detects the current platform.
func detectPlatform() string <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                return "macos"</span>
        case "linux":<span class="cov0" title="0">
                return "linux"</span>
        case "windows":<span class="cov0" title="0">
                return "windows"</span>
        default:<span class="cov0" title="0">
                return runtime.GOOS</span>
        }
}

// getHomeDir returns the user's home directory.
func getHomeDir() (string, error) <span class="cov8" title="1">{
        // This is a placeholder - will be replaced with platform-specific implementation
        // For now, use the OS package
        return os.UserHomeDir()
}</span>

// getConfigDir returns the user's config directory based on platform.
func getConfigDir(platform, homeDir string) string <span class="cov8" title="1">{
        switch platform </span>{
        case "macos", "linux":<span class="cov8" title="1">
                return filepath.Join(homeDir, ".config")</span>
        case "windows":<span class="cov8" title="1">
                appData := os.Getenv("APPDATA")
                if appData != "" </span><span class="cov8" title="1">{
                        return appData
                }</span>
                <span class="cov8" title="1">return filepath.Join(homeDir, "AppData", "Roaming")</span>
        default:<span class="cov0" title="0">
                return filepath.Join(homeDir, ".config")</span>
        }
}

// GetPlatformInfo returns platform information.
func (c *DotfilesClient) GetPlatformInfo() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "platform":     c.Platform,
                "architecture": c.Architecture,
                "home_dir":     c.HomeDir,
                "config_dir":   c.ConfigDir,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// DotfilesConfig holds the provider configuration.
type DotfilesConfig struct {
        DotfilesRoot       string
        BackupEnabled      bool
        BackupDirectory    string
        Strategy           string
        ConflictResolution string
        DryRun             bool
        AutoDetectPlatform bool
        TargetPlatform     string
        TemplateEngine     string
        LogLevel           string
}

// SetDefaults sets default values for the provider configuration.
func (c *DotfilesConfig) SetDefaults() error <span class="cov8" title="1">{
        // Set default dotfiles root
        if c.DotfilesRoot == "" </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get user home directory for dotfiles_root: %w", err)
                }</span>
                <span class="cov0" title="0">c.DotfilesRoot = filepath.Join(homeDir, "dotfiles")</span>
        }

        // Set default backup directory
        <span class="cov8" title="1">if c.BackupDirectory == "" </span><span class="cov8" title="1">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get user home directory for backup_directory: %w", err)
                }</span>
                <span class="cov8" title="1">c.BackupDirectory = filepath.Join(homeDir, ".dotfiles-backups")</span>
        }

        // Set other defaults
        <span class="cov8" title="1">if c.Strategy == "" </span><span class="cov8" title="1">{
                c.Strategy = "symlink"
        }</span>
        <span class="cov8" title="1">if c.ConflictResolution == "" </span><span class="cov8" title="1">{
                c.ConflictResolution = "backup"
        }</span>
        <span class="cov8" title="1">if c.TargetPlatform == "" </span><span class="cov8" title="1">{
                c.TargetPlatform = "auto"
        }</span>
        <span class="cov8" title="1">if c.TemplateEngine == "" </span><span class="cov8" title="1">{
                c.TemplateEngine = "go"
        }</span>
        <span class="cov8" title="1">if c.LogLevel == "" </span><span class="cov8" title="1">{
                c.LogLevel = "info"
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate validates the provider configuration and expands paths.
// Call SetDefaults() before calling this method.
func (c *DotfilesConfig) Validate() error <span class="cov8" title="1">{
        var errs []string

        // Validate dotfiles root
        if c.DotfilesRoot == "" </span><span class="cov8" title="1">{
                errs = append(errs, "dotfiles_root cannot be empty")
        }</span> else<span class="cov8" title="1"> {
                // Expand path
                if strings.HasPrefix(c.DotfilesRoot, "~") </span><span class="cov8" title="1">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("unable to expand dotfiles_root path: %v", err))
                        }</span> else<span class="cov8" title="1"> {
                                c.DotfilesRoot = filepath.Join(homeDir, c.DotfilesRoot[1:])
                        }</span>
                }

                // Convert to absolute path
                <span class="cov8" title="1">absPath, err := filepath.Abs(c.DotfilesRoot)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid dotfiles_root path: %v", err))
                }</span> else<span class="cov8" title="1"> {
                        c.DotfilesRoot = absPath

                        // Validate that DotfilesRoot is writable
                        if err := c.validateWritablePath(c.DotfilesRoot, "dotfiles_root"); err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err.Error())
                        }</span>
                }
        }

        // Validate backup directory if backups are enabled
        <span class="cov8" title="1">if c.BackupEnabled &amp;&amp; c.BackupDirectory != "" </span><span class="cov8" title="1">{
                if strings.HasPrefix(c.BackupDirectory, "~") </span><span class="cov8" title="1">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("unable to expand backup_directory path: %v", err))
                        }</span> else<span class="cov8" title="1"> {
                                c.BackupDirectory = filepath.Join(homeDir, c.BackupDirectory[1:])
                        }</span>
                }

                <span class="cov8" title="1">absPath, err := filepath.Abs(c.BackupDirectory)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid backup_directory path: %v", err))
                }</span> else<span class="cov8" title="1"> {
                        c.BackupDirectory = absPath

                        // Validate that BackupDirectory is writable
                        if err := c.validateWritablePath(c.BackupDirectory, "backup_directory"); err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err.Error())
                        }</span>
                }
        }

        // Validate strategy
        <span class="cov8" title="1">validStrategies := []string{"symlink", "copy", "template"}
        if !contains(validStrategies, c.Strategy) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Sprintf("invalid strategy '%s', must be one of: %v", c.Strategy, validStrategies))
        }</span>

        // Validate conflict resolution
        <span class="cov8" title="1">validConflictResolutions := []string{"backup", "overwrite", "skip", "prompt"}
        if !contains(validConflictResolutions, c.ConflictResolution) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Sprintf("invalid conflict_resolution '%s', must be one of: %v", c.ConflictResolution, validConflictResolutions))
        }</span>

        // Validate target platform
        <span class="cov8" title="1">validPlatforms := []string{"auto", "macos", "linux", "windows"}
        if !contains(validPlatforms, c.TargetPlatform) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Sprintf("invalid target_platform '%s', must be one of: %v", c.TargetPlatform, validPlatforms))
        }</span>

        // Validate template engine
        <span class="cov8" title="1">validEngines := []string{"go", "handlebars", "none"}
        if !contains(validEngines, c.TemplateEngine) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Sprintf("invalid template_engine '%s', must be one of: %v", c.TemplateEngine, validEngines))
        }</span>

        // Validate log level
        <span class="cov8" title="1">validLogLevels := []string{"debug", "info", "warn", "error"}
        if !contains(validLogLevels, c.LogLevel) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Sprintf("invalid log_level '%s', must be one of: %v", c.LogLevel, validLogLevels))
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errors.New(strings.Join(errs, "; "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// contains checks if a slice contains a string.
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// validateWritablePath checks if a path is writable, or if its parent directory is writable for creation.
func (c *DotfilesConfig) validateWritablePath(path, pathType string) error <span class="cov8" title="1">{
        // Check if path exists
        if info, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                // Path exists, check if it's writable
                if info.IsDir() </span><span class="cov8" title="1">{
                        // For directories, try to create a test file
                        testFile := filepath.Join(path, ".terraform-provider-dotfiles-write-test")
                        if file, err := os.Create(testFile); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s directory '%s' is not writable: %w", pathType, path, err)
                        }</span> else<span class="cov8" title="1"> {
                                file.Close()
                                os.Remove(testFile) // Clean up test file
                        }</span>
                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("%s path '%s' exists but is not a directory", pathType, path)
                }</span>
        } else<span class="cov8" title="1"> if os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Path doesn't exist, check if parent directory is writable
                parentDir := filepath.Dir(path)
                if parentInfo, err := os.Stat(parentDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s parent directory '%s' does not exist or is not accessible: %w", pathType, parentDir, err)
                }</span> else<span class="cov8" title="1"> if !parentInfo.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s parent path '%s' is not a directory", pathType, parentDir)
                }</span> else<span class="cov8" title="1"> {
                        // Try to create the directory to test writability
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create %s directory '%s': %w", pathType, path, err)
                        }</span>
                        // Directory created successfully, it's writable
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("cannot access %s path '%s': %w", pathType, path, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

var _ resource.Resource = &amp;DirectoryResource{}

func NewDirectoryResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DirectoryResource{}
}</span>

type DirectoryResource struct {
        client *DotfilesClient
}

type DirectoryResourceModel struct {
        ID                  types.String `tfsdk:"id"`
        Repository          types.String `tfsdk:"repository"`
        Name                types.String `tfsdk:"name"`
        SourcePath          types.String `tfsdk:"source_path"`
        TargetPath          types.String `tfsdk:"target_path"`
        Recursive           types.Bool   `tfsdk:"recursive"`
        PreservePermissions types.Bool   `tfsdk:"preserve_permissions"`

        // Computed attributes
        DirectoryExists types.Bool   `tfsdk:"directory_exists"`
        FileCount       types.Int64  `tfsdk:"file_count"`
        LastSynced      types.String `tfsdk:"last_synced"`
}

func (r *DirectoryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_directory"
}</span>

func (r *DirectoryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages directory structures and their contents",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Directory identifier",
                        },
                        "repository": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Repository ID this directory belongs to",
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Directory name/identifier",
                        },
                        "source_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to source directory in repository",
                                Validators: []validator.String{
                                        validators.ValidPath(),
                                        validators.EnvironmentVariableExpansion(),
                                },
                        },
                        "target_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Target directory path",
                                Validators: []validator.String{
                                        validators.ValidPath(),
                                        validators.EnvironmentVariableExpansion(),
                                },
                        },
                        "recursive": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Process directory recursively. Defaults to true",
                        },
                        "preserve_permissions": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Preserve file permissions. Defaults to true",
                        },
                        "directory_exists": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the target directory exists",
                        },
                        "file_count": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Number of files in the directory",
                        },
                        "last_synced": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Timestamp when the directory was last synced",
                        },
                },
        }
}</span>

func (r *DirectoryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError("Unexpected Resource Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov8" title="1">r.client = client</span>
}

func (r *DirectoryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
                "recursive":   data.Recursive.ValueBool(),
        })

        // Resolve source and target paths
        sourcePath, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Create or sync the directory
        <span class="cov0" title="0">err = r.syncDirectory(ctx, sourcePath, targetPath, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to sync directory",
                        fmt.Sprintf("Error syncing directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Directory resource created successfully", map[string]interface{}{
                "name":       data.Name.ValueString(),
                "file_count": data.FileCount.ValueInt64(),
        })</span>
}

func (r *DirectoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Resolve target path to check current state
        <span class="cov0" title="0">_, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes with current state
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DirectoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Resolve source and target paths
        sourcePath, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Re-sync the directory with updated configuration
        <span class="cov0" title="0">err = r.syncDirectory(ctx, sourcePath, targetPath, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to sync directory",
                        fmt.Sprintf("Error syncing directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Directory resource updated successfully", map[string]interface{}{
                "name":       data.Name.ValueString(),
                "file_count": data.FileCount.ValueInt64(),
        })</span>
}

func (r *DirectoryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DirectoryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting directory resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Resolve target path
        _, targetPath, err := r.resolvePaths(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to resolve paths",
                        fmt.Sprintf("Error resolving paths for directory %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Check if target exists before attempting deletion
        <span class="cov0" title="0">if !utils.PathExists(targetPath) </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Target directory does not exist, nothing to delete", map[string]interface{}{
                        "target_path": targetPath,
                })
                return
        }</span>

        // Safety check: Don't delete system directories or directories outside expected paths
        <span class="cov0" title="0">if err := r.validateDeletionSafety(targetPath); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unsafe directory deletion",
                        fmt.Sprintf("Cannot delete directory %s: %v", targetPath, err),
                )
                return
        }</span>

        // Perform recursive deletion if configured
        <span class="cov0" title="0">if data.Recursive.ValueBool() </span><span class="cov0" title="0">{
                err = os.RemoveAll(targetPath)
        }</span> else<span class="cov0" title="0"> {
                err = os.Remove(targetPath)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to delete directory",
                        fmt.Sprintf("Error deleting directory %s: %v", targetPath, err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Directory resource deleted successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": targetPath,
        })</span>
}

// resolvePaths resolves the source and target paths for the directory.
func (r *DirectoryResource) resolvePaths(data *DirectoryResourceModel) (string, string, error) <span class="cov0" title="0">{
        // Get repository local path
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())
        sourcePath := data.SourcePath.ValueString()

        // Resolve full source path
        var fullSourcePath string
        if strings.HasPrefix(sourcePath, "/") </span><span class="cov0" title="0">{
                fullSourcePath = sourcePath
        }</span> else<span class="cov0" title="0"> {
                fullSourcePath = filepath.Join(repositoryLocalPath, sourcePath)
        }</span>

        // Resolve target path
        <span class="cov0" title="0">targetPath := data.TargetPath.ValueString()
        if strings.HasPrefix(targetPath, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("unable to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">targetPath = strings.Replace(targetPath, "~", homeDir, 1)</span>
        }

        // Convert to absolute paths
        <span class="cov0" title="0">fullSourcePath, err := filepath.Abs(fullSourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get absolute source path: %w", err)
        }</span>

        <span class="cov0" title="0">targetPath, err = filepath.Abs(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get absolute target path: %w", err)
        }</span>

        <span class="cov0" title="0">return fullSourcePath, targetPath, nil</span>
}

// syncDirectory synchronizes the source directory to the target location.
func (r *DirectoryResource) syncDirectory(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        // Check if source exists
        if !utils.PathExists(sourcePath) </span><span class="cov0" title="0">{
                return fmt.Errorf("source directory does not exist: %s", sourcePath)
        }</span>

        // Create target directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(targetPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory: %w", err)
        }</span>

        <span class="cov0" title="0">if data.Recursive.ValueBool() </span><span class="cov0" title="0">{
                return r.syncDirectoryRecursive(ctx, sourcePath, targetPath, data)
        }</span> else<span class="cov0" title="0"> {
                return r.syncDirectoryShallow(ctx, sourcePath, targetPath, data)
        }</span>
}

// syncDirectoryRecursive recursively syncs directories.
func (r *DirectoryResource) syncDirectoryRecursive(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        return filepath.Walk(sourcePath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourcePath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get relative path: %w", err)
                }</span>

                <span class="cov0" title="0">targetFile := filepath.Join(targetPath, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        // Create directory
                        if err := os.MkdirAll(targetFile, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", targetFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        if err := r.copyFile(path, targetFile, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", path, err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// syncDirectoryShallow syncs only the top-level directory contents.
func (r *DirectoryResource) syncDirectoryShallow(ctx context.Context, sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        entries, err := os.ReadDir(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                sourceFile := filepath.Join(sourcePath, entry.Name())
                targetFile := filepath.Join(targetPath, entry.Name())

                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get file info for %s: %w", entry.Name(), err)
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        // Create directory
                        if err := os.MkdirAll(targetFile, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", targetFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        if err := r.copyFile(sourceFile, targetFile, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", sourceFile, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a single file with optional permission preservation.
func (r *DirectoryResource) copyFile(sourcePath, targetPath string, data *DirectoryResourceModel) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        // Create target directory if needed
        targetDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target directory: %w", err)
        }</span>

        <span class="cov0" title="0">targetFile, err := os.Create(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create target file: %w", err)
        }</span>
        <span class="cov0" title="0">defer targetFile.Close()

        // Copy content
        if _, err := targetFile.ReadFrom(sourceFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file content: %w", err)
        }</span>

        // Preserve permissions if requested
        <span class="cov0" title="0">if data.PreservePermissions.ValueBool() </span><span class="cov0" title="0">{
                sourceInfo, err := sourceFile.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get source file permissions: %w", err)
                }</span>

                <span class="cov0" title="0">if err := targetFile.Chmod(sourceInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set target file permissions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateComputedAttributes updates computed attributes based on current directory state.
func (r *DirectoryResource) updateComputedAttributes(ctx context.Context, data *DirectoryResourceModel, targetPath string) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        // Check if directory exists
        exists := utils.PathExists(targetPath)
        data.DirectoryExists = types.BoolValue(exists)

        if exists </span><span class="cov0" title="0">{
                // Count files
                fileCount, err := r.countFiles(targetPath, data.Recursive.ValueBool())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to count files: %w", err)
                }</span>
                <span class="cov0" title="0">data.FileCount = types.Int64Value(fileCount)</span>
        } else<span class="cov0" title="0"> {
                data.FileCount = types.Int64Value(0)
        }</span>

        // Set last synced timestamp
        <span class="cov0" title="0">data.LastSynced = types.StringValue(time.Now().Format(time.RFC3339))

        return nil</span>
}

// countFiles counts the number of files in a directory.
func (r *DirectoryResource) countFiles(dirPath string, recursive bool) (int64, error) <span class="cov0" title="0">{
        var count int64

        if recursive </span><span class="cov0" title="0">{
                err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                                count++
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">return count, err</span>
        } else<span class="cov0" title="0"> {
                entries, err := os.ReadDir(dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
                <span class="cov0" title="0">return count, nil</span>
        }
}

// validateDeletionSafety performs safety checks before deleting a directory.
func (r *DirectoryResource) validateDeletionSafety(targetPath string) error <span class="cov0" title="0">{
        // Get absolute path
        absPath, err := filepath.Abs(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        // List of paths that should never be deleted
        <span class="cov0" title="0">dangerousPaths := []string{
                "/",
                "/bin",
                "/boot",
                "/dev",
                "/etc",
                "/lib",
                "/proc",
                "/root",
                "/sbin",
                "/sys",
                "/tmp",
                "/usr",
                "/var",
        }

        for _, dangerous := range dangerousPaths </span><span class="cov0" title="0">{
                if absPath == dangerous || strings.HasPrefix(absPath+"/", dangerous+"/") </span><span class="cov0" title="0">{
                        return fmt.Errorf("refusing to delete system directory: %s", absPath)
                }</span>
        }

        // Don't delete if outside of home directory or known safe paths
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err == nil </span><span class="cov0" title="0">{
                if !strings.HasPrefix(absPath, homeDir) &amp;&amp; !strings.HasPrefix(absPath, "/tmp") </span><span class="cov0" title="0">{
                        return fmt.Errorf("refusing to delete directory outside home directory: %s", absPath)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *DirectoryResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// BackupStrategyModel defines the backup strategy configuration block.
type BackupStrategyModel struct {
        Enabled         types.Bool   `tfsdk:"enabled"`
        Directory       types.String `tfsdk:"directory"`
        RetentionPolicy types.String `tfsdk:"retention_policy"`
        Compression     types.Bool   `tfsdk:"compression"`
        Incremental     types.Bool   `tfsdk:"incremental"`
        MaxBackups      types.Int64  `tfsdk:"max_backups"`
}

// RecoveryModel defines the recovery configuration block.
type RecoveryModel struct {
        CreateRestoreScripts types.Bool `tfsdk:"create_restore_scripts"`
        ValidateBackups      types.Bool `tfsdk:"validate_backups"`
        TestRecovery         types.Bool `tfsdk:"test_recovery"`
        BackupIndex          types.Bool `tfsdk:"backup_index"`
}

// BackupPolicyModel defines file-specific backup policy.
type BackupPolicyModel struct {
        AlwaysBackup    types.Bool   `tfsdk:"always_backup"`
        VersionedBackup types.Bool   `tfsdk:"versioned_backup"`
        BackupFormat    types.String `tfsdk:"backup_format"`
        RetentionCount  types.Int64  `tfsdk:"retention_count"`
        BackupMetadata  types.Bool   `tfsdk:"backup_metadata"`
        Compression     types.Bool   `tfsdk:"compression"`
}

// RecoveryTestModel defines recovery testing configuration.
type RecoveryTestModel struct {
        Enabled types.Bool   `tfsdk:"enabled"`
        Command types.String `tfsdk:"command"`
        Timeout types.String `tfsdk:"timeout"`
}

// EnhancedProviderModel extends DotfilesProviderModel with enhanced backup features.
// Since DotfilesProviderModel now includes backup_strategy and recovery fields,
// this is now just an alias for backward compatibility.
type EnhancedProviderModel = DotfilesProviderModel

// EnhancedFileResourceModelWithBackup extends EnhancedFileResourceModel with backup features.
type EnhancedFileResourceModelWithBackup struct {
        EnhancedFileResourceModel
        BackupPolicy *BackupPolicyModel `tfsdk:"backup_policy"`
        RecoveryTest *RecoveryTestModel `tfsdk:"recovery_test"`
}

// EnhancedSymlinkResourceModelWithBackup extends EnhancedSymlinkResourceModel with backup features.
type EnhancedSymlinkResourceModelWithBackup struct {
        EnhancedSymlinkResourceModel
        BackupPolicy *BackupPolicyModel `tfsdk:"backup_policy"`
        RecoveryTest *RecoveryTestModel `tfsdk:"recovery_test"`
}

// GetBackupStrategySchemaBlock returns the schema block for backup strategy.
func GetBackupStrategySchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Enhanced backup strategy configuration",
                Attributes: map[string]schema.Attribute{
                        "enabled": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Enable enhanced backup features",
                        },
                        "directory": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("~/.dotfiles-backups"),
                                MarkdownDescription: "Directory to store backup files",
                        },
                        "retention_policy": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("30d"),
                                MarkdownDescription: "Backup retention policy (e.g., '30d', '7d', '1y')",
                        },
                        "compression": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Enable backup compression (gzip)",
                        },
                        "incremental": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Only backup when content changes",
                        },
                        "max_backups": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             int64default.StaticInt64(50),
                                MarkdownDescription: "Maximum number of backups to keep per file",
                        },
                },
        }
}</span>

// GetRecoverySchemaBlock returns the schema block for recovery configuration.
func GetRecoverySchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Recovery and validation configuration",
                Attributes: map[string]schema.Attribute{
                        "create_restore_scripts": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Generate restore scripts for backups",
                        },
                        "validate_backups": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Validate backup integrity with checksums",
                        },
                        "test_recovery": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Test backup recovery functionality",
                        },
                        "backup_index": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Create searchable backup index",
                        },
                },
        }
}</span>

// GetBackupPolicySchemaBlock returns the schema block for file-specific backup policy.
func GetBackupPolicySchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "File-specific backup policy configuration",
                Attributes: map[string]schema.Attribute{
                        "always_backup": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Force backup even if globally disabled",
                        },
                        "versioned_backup": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Keep multiple backup versions",
                        },
                        "backup_format": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("timestamped"),
                                MarkdownDescription: "Backup naming format: timestamped, numbered, or git_style",
                        },
                        "retention_count": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             int64default.StaticInt64(5),
                                MarkdownDescription: "Number of backup versions to retain",
                        },
                        "backup_metadata": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Store backup metadata (checksums, timestamps)",
                        },
                        "compression": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Compress this file's backups",
                        },
                },
        }
}</span>

// GetRecoveryTestSchemaBlock returns the schema block for recovery testing.
func GetRecoveryTestSchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Recovery testing configuration",
                Attributes: map[string]schema.Attribute{
                        "enabled": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                                MarkdownDescription: "Enable recovery testing for this file",
                        },
                        "command": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Command to validate backup ({{.backup_path}} template available)",
                        },
                        "timeout": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("30s"),
                                MarkdownDescription: "Timeout for recovery test commands",
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// EnhancedFileResourceModelWithTemplate extends EnhancedFileResourceModelWithBackup with template features.
type EnhancedFileResourceModelWithTemplate struct {
        EnhancedFileResourceModelWithBackup
        TemplateEngine       types.String `tfsdk:"template_engine"`
        PlatformTemplateVars types.Map    `tfsdk:"platform_template_vars"`
        TemplateFunctions    types.Map    `tfsdk:"template_functions"`
}

// EnhancedSymlinkResourceModelWithTemplate extends EnhancedSymlinkResourceModelWithBackup with template features.
type EnhancedSymlinkResourceModelWithTemplate struct {
        EnhancedSymlinkResourceModelWithBackup
        TemplateEngine       types.String `tfsdk:"template_engine"`
        PlatformTemplateVars types.Map    `tfsdk:"platform_template_vars"`
        TemplateFunctions    types.Map    `tfsdk:"template_functions"`
}

// EnhancedFileResourceModelWithApplicationDetection extends template model with app detection.
type EnhancedFileResourceModelWithApplicationDetection struct {
        EnhancedFileResourceModelWithTemplate
        RequireApplication    types.String `tfsdk:"require_application"`
        ApplicationVersionMin types.String `tfsdk:"application_version_min"`
        ApplicationVersionMax types.String `tfsdk:"application_version_max"`
        SkipIfAppMissing      types.Bool   `tfsdk:"skip_if_app_missing"`
}

// ApplicationDetectionConfig represents application detection configuration.
type ApplicationDetectionConfig struct {
        RequiredApplication string
        MinVersion          string
        MaxVersion          string
        SkipIfMissing       bool
}

// GetEnhancedTemplateAttributes returns template-related schema attributes.
func GetEnhancedTemplateAttributes() map[string]schema.Attribute <span class="cov8" title="1">{
        return map[string]schema.Attribute{
                "template_engine": schema.StringAttribute{
                        Optional:            true,
                        Computed:            true,
                        Default:             stringdefault.StaticString("go"),
                        MarkdownDescription: "Template engine to use: go (default), handlebars, or mustache",
                        Validators: []validator.String{
                                validators.ValidTemplateEngine(),
                        },
                },
                "platform_template_vars": schema.MapAttribute{
                        Optional: true,
                        ElementType: types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "credential_helper": types.StringType,
                                        "diff_tool":         types.StringType,
                                        "homebrew_path":     types.StringType,
                                        "config_dir":        types.StringType,
                                        "shell":             types.StringType,
                                },
                        },
                        MarkdownDescription: "Platform-specific template variables (macos, linux, windows)",
                },
                "template_functions": schema.MapAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Custom template functions (name -&gt; value mappings)",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var _ datasource.DataSource = &amp;FileInfoDataSource{}

func NewFileInfoDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;FileInfoDataSource{}
}</span>

type FileInfoDataSource struct {
        client *DotfilesClient
}

type FileInfoDataSourceModel struct {
        ID          types.String `tfsdk:"id"`
        Path        types.String `tfsdk:"path"`
        Exists      types.Bool   `tfsdk:"exists"`
        IsSymlink   types.Bool   `tfsdk:"is_symlink"`
        Permissions types.String `tfsdk:"permissions"`
        Size        types.Int64  `tfsdk:"size"`
}

func (d *FileInfoDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_file_info"
}</span>

func (d *FileInfoDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "File information data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Data source identifier",
                        },
                        "path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the file to examine",
                        },
                        "exists": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the file exists",
                        },
                        "is_symlink": schema.BoolAttribute{
                                Computed:            true,
                                MarkdownDescription: "Whether the file is a symlink",
                        },
                        "permissions": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "File permissions",
                        },
                        "size": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "File size in bytes",
                        },
                },
        }
}</span>

func (d *FileInfoDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError("Unexpected Data Source Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *FileInfoDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data FileInfoDataSourceModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // TODO: Implement actual file info reading logic
        <span class="cov0" title="0">data.ID = data.Path
        data.Exists = types.BoolValue(false)
        data.IsSymlink = types.BoolValue(false)
        data.Permissions = types.StringValue("0644")
        data.Size = types.Int64Value(0)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/errors"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/template"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;FileResource{}

func NewFileResource() resource.Resource <span class="cov8" title="1">{
        return &amp;FileResource{}
}</span>

// FileResource defines the resource implementation.
type FileResource struct {
        client *DotfilesClient
}

// FileResourceModel describes the resource data model.
type FileResourceModel struct {
        ID            types.String `tfsdk:"id"`
        Repository    types.String `tfsdk:"repository"`
        Name          types.String `tfsdk:"name"`
        SourcePath    types.String `tfsdk:"source_path"`
        TargetPath    types.String `tfsdk:"target_path"`
        IsTemplate    types.Bool   `tfsdk:"is_template"`
        FileMode      types.String `tfsdk:"file_mode"`
        BackupEnabled types.Bool   `tfsdk:"backup_enabled"`

        // Template variables (for template processing)
        TemplateVars types.Map `tfsdk:"template_vars"`

        // Computed attributes for state tracking
        ContentHash  types.String `tfsdk:"content_hash"`
        LastModified types.String `tfsdk:"last_modified"`
        FileExists   types.Bool   `tfsdk:"file_exists"`
}

func (r *FileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_file"
}</span>

func (r *FileResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        // Get post-hooks attributes and merge with base attributes
        baseAttributes := map[string]schema.Attribute{
                "id": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "File identifier",
                },
                "repository": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Repository ID this file belongs to",
                },
                "name": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "File name/identifier",
                },
                "source_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Path to source file in repository",
                        Validators: []validator.String{
                                validators.ValidPath(),
                                validators.EnvironmentVariableExpansion(),
                        },
                },
                "target_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Target path where file should be placed",
                        Validators: []validator.String{
                                validators.ValidPath(),
                                validators.EnvironmentVariableExpansion(),
                        },
                },
                "is_template": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Whether the file should be processed as a template",
                },
                "file_mode": schema.StringAttribute{
                        Optional:            true,
                        MarkdownDescription: "File permissions (e.g., '0644') - deprecated, use permissions block",
                        Validators: []validator.String{
                                validators.ValidFileMode(),
                        },
                },
                "backup_enabled": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Whether to backup existing files",
                },
                "template_vars": schema.MapAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Variables for template processing",
                },
                "permission_rules": GetPermissionRulesAttribute(),
                "content_hash": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "SHA256 hash of file content",
                },
                "last_modified": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Last modification timestamp",
                },
                "file_exists": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the target file exists",
                },
        }

        // Add post-hooks attributes
        postHooksAttrs := GetPostHooksAttributes()
        for key, attr := range postHooksAttrs </span><span class="cov8" title="1">{
                baseAttributes[key] = attr
        }</span>

        // Add enhanced template attributes
        <span class="cov8" title="1">templateAttrs := GetEnhancedTemplateAttributes()
        for key, attr := range templateAttrs </span><span class="cov8" title="1">{
                baseAttributes[key] = attr
        }</span>

        // Add application detection attributes
        <span class="cov8" title="1">appDetectionAttrs := GetApplicationDetectionAttributes()
        for key, attr := range appDetectionAttrs </span><span class="cov8" title="1">{
                baseAttributes[key] = attr
        }</span>

        <span class="cov8" title="1">resp.Schema = schema.Schema{
                MarkdownDescription: "Manages individual dotfiles with comprehensive features: permissions, backup, templates, hooks, and application detection",
                Attributes:          baseAttributes,
                Blocks: map[string]schema.Block{
                        "permissions":   GetPermissionsSchemaBlock(),
                        "backup_policy": GetBackupPolicySchemaBlock(),
                        "recovery_test": GetRecoveryTestSchemaBlock(),
                },
        }</span>
}

func (r *FileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else. Please report this issue to the provider developers.",
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

func (r *FileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithApplicationDetection

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
                "is_template": data.IsTemplate.ValueBool(),
        })

        // Check application requirements before proceeding
        if !data.RequireApplication.IsNull() </span><span class="cov0" title="0">{
                appDetectionConfig := buildApplicationDetectionConfig(&amp;data)

                shouldSkip := r.checkApplicationRequirements(ctx, appDetectionConfig, &amp;resp.Diagnostics)

                if shouldSkip </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Skipping file resource - required application not available", map[string]interface{}{
                                "required_app": appDetectionConfig.RequiredApplication,
                        })
                        // Set ID and save state without creating file
                        data.ID = data.Name
                        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
                        return
                }</span>
        }

        // Get repository information (for local path if it's a Git repository)
        <span class="cov0" title="0">repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())

        // Build source file path
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()

        // Pre-apply validation: check if source file exists
        if err := r.validateSourceFileExists(sourcePath); err != nil </span><span class="cov0" title="0">{
                sourceErr := errors.ValidationError("validate_source_file", "file", "Source file validation failed", err).
                        WithPath(sourcePath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("repository", data.Repository.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, sourceErr, "Source file not found")
                return
        }</span>

        // Expand target path
        <span class="cov0" title="0">platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                pathErr := errors.ValidationError("expand_target_path", "file", "Could not expand target path", err).
                        WithPath(targetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, pathErr, "Invalid target path")
                return
        }</span>

        // Create file manager
        <span class="cov0" title="0">fileManager := fileops.NewFileManager(platformProvider, r.client.Config.DryRun)

        // Build permission configuration
        permConfig, err := buildFilePermissionConfig(&amp;data.EnhancedFileResourceModel)
        if err != nil </span><span class="cov0" title="0">{
                configErr := errors.ConfigurationError("build_permission_config", "file", "Failed to build permission configuration", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, configErr, "Invalid permission configuration")
                return
        }</span>

        // Build enhanced backup configuration
        <span class="cov0" title="0">enhancedBackupConfig, err := buildEnhancedBackupConfigFromAppModel(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                backupErr := errors.ConfigurationError("build_backup_config", "file", "Failed to build backup configuration", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, backupErr, "Invalid backup configuration")
                return
        }</span>

        // Handle backup - use enhanced if available, otherwise fall back to legacy
        <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                if enhancedBackupConfig != nil &amp;&amp; enhancedBackupConfig.Enabled </span><span class="cov0" title="0">{
                        // Use enhanced backup with retry
                        enhancedBackupConfig.Directory = r.client.Config.BackupDirectory

                        if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                                backupErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                        _, err := fileManager.CreateEnhancedBackup(expandedTargetPath, enhancedBackupConfig)
                                        return err
                                }</span>)

                                <span class="cov0" title="0">if backupErr != nil </span><span class="cov0" title="0">{
                                        backupWarnErr := errors.IOError("create_enhanced_backup", "file", "Could not create enhanced backup", backupErr).
                                                WithPath(expandedTargetPath).
                                                WithContext("backup_directory", r.client.Config.BackupDirectory)
                                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Enhanced backup failed", backupWarnErr.Error())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "DRY RUN: Skipping enhanced backup operation", map[string]interface{}{
                                        "target_path":      expandedTargetPath,
                                        "backup_directory": r.client.Config.BackupDirectory,
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fall back to legacy backup
                        backupEnabled := r.client.Config.BackupEnabled
                        if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                                backupEnabled = data.BackupEnabled.ValueBool()
                        }</span>

                        <span class="cov0" title="0">if backupEnabled </span><span class="cov0" title="0">{
                                if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                                        backupErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                                return err
                                        }</span>)

                                        <span class="cov0" title="0">if backupErr != nil </span><span class="cov0" title="0">{
                                                backupWarnErr := errors.IOError("create_backup", "file", "Could not create backup", backupErr).
                                                        WithPath(expandedTargetPath).
                                                        WithContext("backup_directory", r.client.Config.BackupDirectory)
                                                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Backup failed", backupWarnErr.Error())
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        tflog.Info(ctx, "DRY RUN: Skipping backup operation", map[string]interface{}{
                                                "target_path":      expandedTargetPath,
                                                "backup_directory": r.client.Config.BackupDirectory,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var finalErr error

        if data.IsTemplate.ValueBool() </span><span class="cov0" title="0">{
                // Build enhanced template configuration
                templateConfig, err := buildEnhancedTemplateConfigFromAppModel(&amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        templateErr := errors.ConfigurationError("build_template_config", "file", "Failed to build template configuration", err).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString()).
                                WithContext("source_path", sourcePath)
                        errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, templateErr, "Invalid template configuration")
                        return
                }</span>

                // Process template with enhanced features and retry
                <span class="cov0" title="0">if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                        finalErr = errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                return r.processEnhancedTemplate(sourcePath, expandedTargetPath, templateConfig, permConfig)
                        }</span>)

                        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                                templateErr := errors.TemplateError("process_template", "file", "Template processing failed", finalErr).
                                        WithPath(expandedTargetPath).
                                        WithContext("file_name", data.Name.ValueString()).
                                        WithContext("source_path", sourcePath).
                                        WithContext("template_engine", templateConfig.Engine)
                                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, templateErr, "Template processing failed")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "DRY RUN: Skipping template processing", map[string]interface{}{
                                "source_path":     sourcePath,
                                "target_path":     expandedTargetPath,
                                "template_engine": templateConfig.Engine,
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                // Regular file copy with enhanced permissions and retry
                if !r.client.Config.DryRun </span><span class="cov0" title="0">{
                        finalErr = errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                                return fileManager.CopyFileWithPermissions(sourcePath, expandedTargetPath, permConfig)
                        }</span>)

                        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                                copyErr := errors.IOError("copy_file", "file", "File copy operation failed", finalErr).
                                        WithPath(expandedTargetPath).
                                        WithContext("file_name", data.Name.ValueString()).
                                        WithContext("source_path", sourcePath)
                                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, copyErr, "File operation failed")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "DRY RUN: Skipping file copy operation", map[string]interface{}{
                                "source_path": sourcePath,
                                "target_path": expandedTargetPath,
                        })
                }</span>
        }

        // Execute post-create commands
        <span class="cov0" title="0">if err := executePostCommands(ctx, data.PostCreateCommands, "post-create"); err != nil </span><span class="cov0" title="0">{
                postCmdErr := errors.IOError("execute_post_commands", "file", "Post-create commands failed", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("command_type", "post-create")
                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Post-create commands failed",
                        "File created successfully but post-create commands failed: "+postCmdErr.Error())
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                metadataErr := errors.IOError("update_metadata", "file", "Could not update file metadata", err).
                        WithPath(expandedTargetPath).
                        WithContext("file_name", data.Name.ValueString())
                errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Could not update file metadata",
                        "File created successfully but could not update metadata: "+metadataErr.Error())
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "File resource created successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
                "is_template": data.IsTemplate.ValueBool(),
        })</span>
}

func (r *FileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithApplicationDetection

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Expand target path to check current state
        targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        pathErr := errors.ValidationError("expand_target_path", "file", "Could not expand target path", err).
                                WithPath(targetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, pathErr, "Invalid target path")
                        return
                }</span>

                // Update computed attributes with current file state
                <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                        metadataErr := errors.IOError("read_metadata", "file", "Could not read file metadata", err).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Could not read file metadata", metadataErr.Error())
                }</span>

                // Check for drift if file doesn't exist
                <span class="cov0" title="0">if !data.FileExists.ValueBool() </span><span class="cov0" title="0">{
                        driftErr := errors.IOError("check_file_existence", "file", "Managed file no longer exists", nil).
                                WithPath(expandedTargetPath).
                                WithContext("file_name", data.Name.ValueString())
                        errors.AddWarningToDiagnostics(ctx, &amp;resp.Diagnostics, "Managed file not found", driftErr.Error())
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *FileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithApplicationDetection

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "source_path": data.SourcePath.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Get repository local path
        repositoryLocalPath := r.getRepositoryLocalPath(data.Repository.ValueString())

        // Build paths
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()

        // Pre-apply validation: check if source file exists
        if err := r.validateSourceFileExists(sourcePath); err != nil </span><span class="cov0" title="0">{
                sourceErr := errors.ValidationError("validate_source_file", "file", "Source file validation failed", err).
                        WithPath(sourcePath).
                        WithContext("file_name", data.Name.ValueString()).
                        WithContext("repository", data.Repository.ValueString())
                errors.AddErrorToDiagnostics(ctx, &amp;resp.Diagnostics, sourceErr, "Source file not found")
                return
        }</span>

        // Expand target path
        <span class="cov0" title="0">platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid target path",
                        fmt.Sprintf("Could not expand target path %s: %s", targetPath, err.Error()),
                )
                return
        }</span>

        // Create file manager
        <span class="cov0" title="0">fileManager := fileops.NewFileManager(platformProvider, r.client.Config.DryRun)

        // Build permission configuration
        permConfig, err := buildFilePermissionConfig(&amp;data.EnhancedFileResourceModel)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid permission configuration",
                        fmt.Sprintf("Failed to build permission config: %s", err.Error()),
                )
                return
        }</span>

        // Build enhanced backup configuration
        <span class="cov0" title="0">enhancedBackupConfig, err := buildEnhancedBackupConfigFromAppModel(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid backup configuration",
                        fmt.Sprintf("Failed to build backup config: %s", err.Error()),
                )
                return
        }</span>

        // Handle backup before update - use enhanced if available, otherwise fall back to legacy
        <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                if enhancedBackupConfig != nil &amp;&amp; enhancedBackupConfig.Enabled </span><span class="cov0" title="0">{
                        // Use enhanced backup
                        enhancedBackupConfig.Directory = r.client.Config.BackupDirectory
                        _, err := fileManager.CreateEnhancedBackup(expandedTargetPath, enhancedBackupConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Enhanced backup failed",
                                        fmt.Sprintf("Could not create enhanced backup before update: %s", err.Error()),
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fall back to legacy backup
                        backupEnabled := r.client.Config.BackupEnabled
                        if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                                backupEnabled = data.BackupEnabled.ValueBool()
                        }</span>

                        <span class="cov0" title="0">if backupEnabled </span><span class="cov0" title="0">{
                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddWarning(
                                                "Backup failed",
                                                fmt.Sprintf("Could not create backup before update: %s", err.Error()),
                                        )
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var finalErr error

        if data.IsTemplate.ValueBool() </span><span class="cov0" title="0">{
                // Build enhanced template configuration
                templateConfig, err := buildEnhancedTemplateConfigFromAppModel(&amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Invalid template configuration",
                                fmt.Sprintf("Failed to build template config: %s", err.Error()),
                        )
                        return
                }</span>

                // Process template with enhanced features
                <span class="cov0" title="0">finalErr = r.processEnhancedTemplate(sourcePath, expandedTargetPath, templateConfig, permConfig)</span>
        } else<span class="cov0" title="0"> {
                // Regular file copy with enhanced permissions
                finalErr = fileManager.CopyFileWithPermissions(sourcePath, expandedTargetPath, permConfig)
        }</span>

        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "File update failed",
                        fmt.Sprintf("Could not update file %s: %s", expandedTargetPath, finalErr.Error()),
                )
                return
        }</span>

        // Execute post-update commands
        <span class="cov0" title="0">if err := executePostCommands(ctx, data.PostUpdateCommands, "post-update"); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Post-update commands failed",
                        fmt.Sprintf("File updated successfully but post-update commands failed: %s", err.Error()),
                )
        }</span>

        // Update computed attributes
        <span class="cov0" title="0">if err := r.updateComputedAttributes(ctx, &amp;data.FileResourceModel, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Could not update file metadata",
                        fmt.Sprintf("File updated successfully but could not update metadata: %s", err.Error()),
                )
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "File resource updated successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
        })</span>
}

func (r *FileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data EnhancedFileResourceModelWithApplicationDetection

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting file resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Execute pre-destroy commands
        if err := executePostCommands(ctx, data.PreDestroyCommands, "pre-destroy"); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Pre-destroy commands failed",
                        fmt.Sprintf("Pre-destroy commands failed: %s", err.Error()),
                )
        }</span>

        // For file resources, we typically remove the managed file
        // but preserve any backups
        <span class="cov0" title="0">targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                // Expand target path
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Could not expand target path",
                                fmt.Sprintf("Could not expand target path for cleanup: %s", err.Error()),
                        )
                        return
                }</span>

                // Remove the file if it exists
                <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                        err := os.Remove(expandedTargetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Could not remove file",
                                        fmt.Sprintf("Could not remove file %s: %s", expandedTargetPath, err.Error()),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "File resource removed", map[string]interface{}{
                                        "target_path": expandedTargetPath,
                                })
                        }</span>
                }
        }
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *FileResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>

// updateComputedAttributes updates computed attributes for state tracking.
func (r *FileResource) updateComputedAttributes(ctx context.Context, data *FileResourceModel, targetPath string) error <span class="cov0" title="0">{
        _ = ctx // Context reserved for future logging
        // Check if file exists
        exists := utils.PathExists(targetPath)
        data.FileExists = types.BoolValue(exists)

        if exists </span><span class="cov0" title="0">{
                // Get file info
                info, err := os.Stat(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stat file: %w", err)
                }</span>

                // Set last modified time
                <span class="cov0" title="0">data.LastModified = types.StringValue(info.ModTime().Format(time.RFC3339))

                // Calculate content hash
                content, err := os.ReadFile(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read file for hash: %w", err)
                }</span>

                <span class="cov0" title="0">hash := sha256.Sum256(content)
                data.ContentHash = types.StringValue(fmt.Sprintf("%x", hash))</span>
        } else<span class="cov0" title="0"> {
                data.LastModified = types.StringNull()
                data.ContentHash = types.StringNull()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildEnhancedBackupConfigFromFileModel builds enhanced backup config from file model.
func buildEnhancedBackupConfigFromFileModel(data *EnhancedFileResourceModelWithBackup) (*fileops.EnhancedBackupConfig, error) <span class="cov8" title="1">{
        if data.BackupPolicy == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">config := &amp;fileops.EnhancedBackupConfig{
                Enabled:        data.BackupPolicy.AlwaysBackup.ValueBool() || !data.BackupPolicy.AlwaysBackup.IsNull(),
                BackupFormat:   data.BackupPolicy.BackupFormat.ValueString(),
                MaxBackups:     data.BackupPolicy.RetentionCount.ValueInt64(),
                BackupMetadata: data.BackupPolicy.BackupMetadata.ValueBool(),
                Compression:    data.BackupPolicy.Compression.ValueBool(),
                Incremental:    data.BackupPolicy.VersionedBackup.ValueBool(),
                BackupIndex:    true, // Always enable for file-level policies
        }

        // Set defaults if not specified
        if config.BackupFormat == "" </span><span class="cov0" title="0">{
                config.BackupFormat = "timestamped"
        }</span>
        <span class="cov8" title="1">if config.MaxBackups == 0 </span><span class="cov8" title="1">{
                config.MaxBackups = 5
        }</span>

        <span class="cov8" title="1">return config, fileops.ValidateEnhancedBackupConfig(config)</span>
}

// buildEnhancedBackupConfigFromTemplateModel builds enhanced backup config from template model.
func buildEnhancedBackupConfigFromTemplateModel(data *EnhancedFileResourceModelWithTemplate) (*fileops.EnhancedBackupConfig, error) <span class="cov8" title="1">{
        return buildEnhancedBackupConfigFromFileModel(&amp;data.EnhancedFileResourceModelWithBackup)
}</span>

// buildEnhancedTemplateConfigFromAppModel builds template config from application detection model.
func buildEnhancedTemplateConfigFromAppModel(data *EnhancedFileResourceModelWithApplicationDetection) (*EnhancedTemplateConfig, error) <span class="cov8" title="1">{
        return buildEnhancedTemplateConfig(&amp;data.EnhancedFileResourceModelWithTemplate)
}</span>

// buildEnhancedBackupConfigFromAppModel builds backup config from application detection model.
func buildEnhancedBackupConfigFromAppModel(data *EnhancedFileResourceModelWithApplicationDetection) (*fileops.EnhancedBackupConfig, error) <span class="cov8" title="1">{
        return buildEnhancedBackupConfigFromTemplateModel(&amp;data.EnhancedFileResourceModelWithTemplate)
}</span>

// buildEnhancedTemplateConfig builds template configuration from template model.
func buildEnhancedTemplateConfig(data *EnhancedFileResourceModelWithTemplate) (*EnhancedTemplateConfig, error) <span class="cov8" title="1">{
        config := &amp;EnhancedTemplateConfig{
                Engine:          "go", // default
                UserVars:        make(map[string]interface{}),
                PlatformVars:    make(map[string]map[string]interface{}),
                CustomFunctions: make(map[string]interface{}),
        }

        // Set template engine
        if !data.TemplateEngine.IsNull() </span><span class="cov8" title="1">{
                config.Engine = data.TemplateEngine.ValueString()
        }</span>

        // Parse template vars
        <span class="cov8" title="1">if !data.TemplateVars.IsNull() </span><span class="cov8" title="1">{
                elements := data.TemplateVars.Elements()
                for key, value := range elements </span><span class="cov8" title="1">{
                        if strValue, ok := value.(types.String); ok </span><span class="cov8" title="1">{
                                // Validate template variable name
                                if key == "" </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("template variable name cannot be empty")
                                }</span>
                                <span class="cov8" title="1">config.UserVars[key] = strValue.ValueString()</span>
                        } else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("template variable '%s' must be a string", key)
                        }</span>
                }
        }

        // Parse platform template vars
        <span class="cov8" title="1">if !data.PlatformTemplateVars.IsNull() </span><span class="cov8" title="1">{
                elements := data.PlatformTemplateVars.Elements()
                for platform, platformVarsValue := range elements </span><span class="cov8" title="1">{
                        if objValue, ok := platformVarsValue.(types.Object); ok </span><span class="cov8" title="1">{
                                platformMap := make(map[string]interface{})
                                objAttrs := objValue.Attributes()
                                for key, attrValue := range objAttrs </span><span class="cov8" title="1">{
                                        if strValue, ok := attrValue.(types.String); ok </span><span class="cov8" title="1">{
                                                platformMap[key] = strValue.ValueString()
                                        }</span>
                                }
                                <span class="cov8" title="1">config.PlatformVars[platform] = platformMap</span>
                        }
                }
        }

        // Parse template functions (simple string mappings for now)
        <span class="cov8" title="1">if !data.TemplateFunctions.IsNull() </span><span class="cov8" title="1">{
                elements := data.TemplateFunctions.Elements()
                for name, funcValue := range elements </span><span class="cov8" title="1">{
                        if strValue, ok := funcValue.(types.String); ok </span><span class="cov8" title="1">{
                                // For now, store as string values - could be enhanced to support actual functions
                                config.CustomFunctions[name] = strValue.ValueString()
                        }</span>
                }
        }

        <span class="cov8" title="1">return config, ValidateEnhancedTemplateConfig(config)</span>
}

// EnhancedTemplateConfig represents enhanced template configuration.
type EnhancedTemplateConfig struct {
        Engine          string
        UserVars        map[string]interface{}
        PlatformVars    map[string]map[string]interface{}
        CustomFunctions map[string]interface{}
}

// ValidateEnhancedTemplateConfig validates enhanced template configuration.
func ValidateEnhancedTemplateConfig(config *EnhancedTemplateConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate template engine
        <span class="cov8" title="1">validEngines := []string{"go", "handlebars", "mustache"}
        valid := false
        for _, engine := range validEngines </span><span class="cov8" title="1">{
                if config.Engine == engine </span><span class="cov8" title="1">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template engine: %s (must be one of: %v)", config.Engine, validEngines)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// buildFilePermissionConfig builds a PermissionConfig from the enhanced model data.
func buildFilePermissionConfig(data *EnhancedFileResourceModel) (*fileops.PermissionConfig, error) <span class="cov8" title="1">{
        config := &amp;fileops.PermissionConfig{}

        // Handle permissions block
        if data.Permissions != nil </span><span class="cov8" title="1">{
                if !data.Permissions.Directory.IsNull() </span><span class="cov0" title="0">{
                        config.DirectoryMode = data.Permissions.Directory.ValueString()
                }</span>
                <span class="cov8" title="1">if !data.Permissions.Files.IsNull() </span><span class="cov8" title="1">{
                        config.FileMode = data.Permissions.Files.ValueString()
                }</span>
                <span class="cov8" title="1">if !data.Permissions.Recursive.IsNull() </span><span class="cov0" title="0">{
                        config.Recursive = data.Permissions.Recursive.ValueBool()
                }</span>
        }

        // Handle permission rules
        <span class="cov8" title="1">if !data.PermissionRules.IsNull() &amp;&amp; !data.PermissionRules.IsUnknown() </span><span class="cov0" title="0">{
                config.Rules = make(map[string]string)
                elements := data.PermissionRules.Elements()
                for pattern, permValue := range elements </span><span class="cov0" title="0">{
                        if strPerm, ok := permValue.(types.String); ok </span><span class="cov0" title="0">{
                                config.Rules[pattern] = strPerm.ValueString()
                        }</span>
                }
        }

        // Fallback to legacy file_mode if no permissions are set
        <span class="cov8" title="1">if config.FileMode == "" &amp;&amp; !data.FileMode.IsNull() </span><span class="cov0" title="0">{
                config.FileMode = data.FileMode.ValueString()
        }</span>

        <span class="cov8" title="1">return config, fileops.ValidatePermissionConfig(config)</span>
}

// executePostCommands executes post-creation/update commands.
func executePostCommands(ctx context.Context, commands types.List, operation string) error <span class="cov8" title="1">{
        if commands.IsNull() || commands.IsUnknown() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, fmt.Sprintf("Executing %s commands", operation))

        elements := commands.Elements()
        for i, cmdValue := range elements </span><span class="cov8" title="1">{
                if strCmd, ok := cmdValue.(types.String); ok </span><span class="cov8" title="1">{
                        cmd := strCmd.ValueString()
                        tflog.Debug(ctx, fmt.Sprintf("Executing %s command %d: %s", operation, i+1, cmd))

                        if err := executeShellCommand(ctx, cmd); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("command %d failed: %w", i+1, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processEnhancedTemplate processes a template with enhanced features.
func (r *FileResource) processEnhancedTemplate(sourcePath, targetPath string, config *EnhancedTemplateConfig, permConfig *fileops.PermissionConfig) error <span class="cov0" title="0">{
        // Create template engine based on configuration
        var engine template.TemplateEngine
        var err error

        if len(config.CustomFunctions) &gt; 0 </span><span class="cov0" title="0">{
                engine, err = template.CreateTemplateEngineWithFunctions(config.Engine, config.CustomFunctions)
        }</span> else<span class="cov0" title="0"> {
                engine, err = template.CreateTemplateEngine(config.Engine)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create template engine: %w", err)
        }</span>

        // Build comprehensive template context
        <span class="cov0" title="0">systemInfo := r.client.GetPlatformInfo()
        templateContext := template.BuildPlatformAwareTemplateContext(
                systemInfo,
                config.UserVars,
                config.PlatformVars,
        )

        // Process template file
        err = engine.ProcessTemplateFile(sourcePath, targetPath, templateContext, permConfig.FileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process template file: %w", err)
        }</span>

        // Apply permissions after template processing
        <span class="cov0" title="0">err = r.fileManager().ApplyPermissions(targetPath, permConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply permissions after template processing: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// fileManager creates a file manager instance for this resource.
func (r *FileResource) fileManager() *fileops.FileManager <span class="cov0" title="0">{
        platformProvider := platform.DetectPlatform()
        return fileops.NewFileManager(platformProvider, r.client.Config.DryRun)
}</span>

// checkApplicationRequirements checks if required applications are available.
func (r *FileResource) checkApplicationRequirements(ctx context.Context, config *ApplicationDetectionConfig, diagnostics *diag.Diagnostics) bool <span class="cov8" title="1">{
        if config.RequiredApplication == "" </span><span class="cov0" title="0">{
                return false // No application required
        }</span>

        // Create a temporary ApplicationResource for detection
        <span class="cov8" title="1">appResource := &amp;ApplicationResource{client: r.client}

        // Create model for detection
        detectionModel := ApplicationResourceModel{
                Application:        types.StringValue(config.RequiredApplication),
                DetectInstallation: types.BoolValue(true),
                // Detection methods will use defaults since blocks are handled separately
        }

        // Perform detection
        result := appResource.performApplicationDetection(ctx, &amp;detectionModel)

        // Check if application is installed
        if !result.Installed </span><span class="cov0" title="0">{
                if config.SkipIfMissing </span><span class="cov0" title="0">{
                        return true // Skip this resource
                }</span>
                // Add warning if configured to warn
                <span class="cov0" title="0">diagnostics.AddWarning(
                        "Required application not found",
                        fmt.Sprintf("Required application %s is not installed", config.RequiredApplication),
                )</span>
        }

        // Check version compatibility if version info is available
        <span class="cov8" title="1">if result.Version != "" &amp;&amp; result.Version != "unknown" </span><span class="cov0" title="0">{
                if !isVersionCompatible(result.Version, config.MinVersion, config.MaxVersion) </span><span class="cov0" title="0">{
                        message := fmt.Sprintf("Application %s version %s is not compatible", config.RequiredApplication, result.Version)
                        if config.MinVersion != "" </span><span class="cov0" title="0">{
                                message += fmt.Sprintf(" (min: %s)", config.MinVersion)
                        }</span>
                        <span class="cov0" title="0">if config.MaxVersion != "" </span><span class="cov0" title="0">{
                                message += fmt.Sprintf(" (max: %s)", config.MaxVersion)
                        }</span>

                        <span class="cov0" title="0">if config.SkipIfMissing </span><span class="cov0" title="0">{
                                diagnostics.AddWarning("Application version incompatible", message+" - skipping configuration")
                                return true // Skip this resource
                        }</span> else<span class="cov0" title="0"> {
                                diagnostics.AddWarning("Application version incompatible", message+" - proceeding anyway")
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span> // Don't skip
}

// buildApplicationDetectionConfig builds application detection config from model.
func buildApplicationDetectionConfig(data *EnhancedFileResourceModelWithApplicationDetection) *ApplicationDetectionConfig <span class="cov8" title="1">{
        config := &amp;ApplicationDetectionConfig{}

        if !data.RequireApplication.IsNull() </span><span class="cov8" title="1">{
                config.RequiredApplication = data.RequireApplication.ValueString()
        }</span>
        <span class="cov8" title="1">if !data.ApplicationVersionMin.IsNull() </span><span class="cov8" title="1">{
                config.MinVersion = data.ApplicationVersionMin.ValueString()
        }</span>
        <span class="cov8" title="1">if !data.ApplicationVersionMax.IsNull() </span><span class="cov8" title="1">{
                config.MaxVersion = data.ApplicationVersionMax.ValueString()
        }</span>
        <span class="cov8" title="1">if !data.SkipIfAppMissing.IsNull() </span><span class="cov8" title="1">{
                config.SkipIfMissing = data.SkipIfAppMissing.ValueBool()
        }</span>

        <span class="cov8" title="1">return config</span>
}

// isVersionCompatible checks if a version is within specified bounds.
func isVersionCompatible(detected, minVersion, maxVersion string) bool <span class="cov8" title="1">{
        // Simplified version comparison for now
        // A real implementation would use proper semantic versioning
        if minVersion == "" &amp;&amp; maxVersion == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Basic string comparison (would need proper semver library in production)
        <span class="cov8" title="1">if minVersion != "" &amp;&amp; detected &lt; minVersion </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if maxVersion != "" &amp;&amp; detected &gt; maxVersion </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// executeShellCommand executes a shell command safely.
func executeShellCommand(ctx context.Context, cmdStr string) error <span class="cov8" title="1">{
        // Parse command and arguments
        parts := strings.Fields(cmdStr)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("empty command")
        }</span>

        // Use shell to execute complex commands
        <span class="cov8" title="1">var cmd *exec.Cmd

        // Determine shell based on OS
        var shell, shellFlag string
        if strings.Contains(os.Getenv("SHELL"), "fish") </span><span class="cov8" title="1">{
                shell = "fish"
                shellFlag = "-c"
        }</span> else<span class="cov0" title="0"> if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                shell = "cmd"
                shellFlag = "/c"
        }</span> else<span class="cov0" title="0"> {
                shell = "sh"
                shellFlag = "-c"
        }</span>

        <span class="cov8" title="1">cmd = exec.CommandContext(ctx, shell, shellFlag, cmdStr)

        // Set environment variables
        cmd.Env = os.Environ()

        // Capture output
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov8" title="1">{
                tflog.Error(ctx, fmt.Sprintf("Command failed: %s", cmdStr), map[string]interface{}{
                        "error":  err.Error(),
                        "output": string(output),
                })
                return fmt.Errorf("command '%s' failed: %w (output: %s)", cmdStr, err, string(output))
        }</span>

        <span class="cov8" title="1">tflog.Info(ctx, fmt.Sprintf("Command executed successfully: %s", cmdStr), map[string]interface{}{
                "output": string(output),
        })

        return nil</span>
}

// validateSourceFileExists checks if the source file exists and is readable.
func (r *FileResource) validateSourceFileExists(sourcePath string) error <span class="cov8" title="1">{
        // Check if source file exists
        info, err := os.Stat(sourcePath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("source file '%s' does not exist", sourcePath)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot access source file '%s': %w", sourcePath, err)
        }</span>

        // Check if it's a regular file (not a directory or special file)
        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov8" title="1">{
                return fmt.Errorf("source path '%s' is not a regular file (mode: %s)", sourcePath, info.Mode().String())
        }</span>

        // Check if file is readable by attempting to open it
        <span class="cov8" title="1">file, err := os.Open(sourcePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("source file '%s' is not readable: %w", sourcePath, err)
        }</span>
        <span class="cov8" title="1">file.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "fmt"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// PermissionsModel defines the permissions configuration block.
type PermissionsModel struct {
        Directory types.String `tfsdk:"directory"`
        Files     types.String `tfsdk:"files"`
        Recursive types.Bool   `tfsdk:"recursive"`
}

// EnhancedFileResourceModel extends FileResourceModel with permission management.
type EnhancedFileResourceModel struct {
        FileResourceModel
        Permissions     *PermissionsModel `tfsdk:"permissions"`
        PermissionRules types.Map         `tfsdk:"permission_rules"`

        // Post-creation hooks (Priority 2 feature)
        PostCreateCommands types.List `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List `tfsdk:"pre_destroy_commands"`
}

// EnhancedSymlinkResourceModel extends SymlinkResourceModel with permission management.
type EnhancedSymlinkResourceModel struct {
        SymlinkResourceModel
        Permissions     *PermissionsModel `tfsdk:"permissions"`
        PermissionRules types.Map         `tfsdk:"permission_rules"`

        // Post-creation hooks (Priority 2 feature)
        PostCreateCommands types.List `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List `tfsdk:"pre_destroy_commands"`
}

// GetPermissionsSchemaBlock returns the schema block for permissions.
func GetPermissionsSchemaBlock() schema.SingleNestedBlock <span class="cov8" title="1">{
        return schema.SingleNestedBlock{
                MarkdownDescription: "Permission management for files and directories",
                Attributes: map[string]schema.Attribute{
                        "directory": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("0755"),
                                MarkdownDescription: "Directory permission mode (e.g., '0755')",
                        },
                        "files": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("0644"),
                                MarkdownDescription: "File permission mode (e.g., '0644')",
                        },
                        "recursive": schema.BoolAttribute{
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(true),
                                MarkdownDescription: "Apply permissions recursively to subdirectories and files",
                        },
                },
        }
}</span>

// GetPermissionRulesAttribute returns the schema attribute for permission rules.
func GetPermissionRulesAttribute() schema.MapAttribute <span class="cov8" title="1">{
        return schema.MapAttribute{
                Optional:            true,
                ElementType:         types.StringType,
                MarkdownDescription: "Pattern-based permission rules (e.g., 'id_*' = '0600')",
        }
}</span>

// GetPostHooksAttributes returns the schema attributes for post-creation hooks.
func GetPostHooksAttributes() map[string]schema.Attribute <span class="cov8" title="1">{
        return map[string]schema.Attribute{
                "post_create_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute after resource creation",
                },
                "post_update_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute after resource update",
                },
                "pre_destroy_commands": schema.ListAttribute{
                        Optional:            true,
                        ElementType:         types.StringType,
                        MarkdownDescription: "Commands to execute before resource destruction",
                },
        }
}</span>

// parsePermission parses a permission string (e.g., "0644") to uint32.
func parsePermission(perm string) (uint32, error) <span class="cov8" title="1">{
        if perm == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("permission cannot be empty")
        }</span>

        // Remove leading zeros for parsing, but preserve them for validation
        <span class="cov8" title="1">trimmed := strings.TrimLeft(perm, "0")
        if trimmed == "" </span><span class="cov0" title="0">{
                trimmed = "0"
        }</span>

        // Parse as octal
        <span class="cov8" title="1">parsed, err := strconv.ParseUint(trimmed, 8, 32)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid permission format %q: %w", perm, err)
        }</span>

        // Validate permission range (0-777)
        <span class="cov8" title="1">if parsed &gt; 0777 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("permission %q is out of valid range (0-777)", perm)
        }</span>

        <span class="cov8" title="1">return uint32(parsed), nil</span>
}

// matchesPermissionPattern checks if a filename matches a permission rule pattern.
func matchesPermissionPattern(pattern, filename string) bool <span class="cov8" title="1">{
        // Simple glob matching - can be enhanced with more sophisticated patterns
        matched, err := filepath.Match(pattern, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return matched</span>
}

// isMoreSpecific determines if pattern1 is more specific than pattern2.
func isMoreSpecific(pattern1, pattern2 string) bool <span class="cov8" title="1">{
        // Count wildcards - fewer wildcards means more specific
        wildcards1 := strings.Count(pattern1, "*") + strings.Count(pattern1, "?")
        wildcards2 := strings.Count(pattern2, "*") + strings.Count(pattern2, "?")

        if wildcards1 != wildcards2 </span><span class="cov0" title="0">{
                return wildcards1 &lt; wildcards2
        }</span>

        // If same number of wildcards, prefer exact character matches
        <span class="cov8" title="1">exactChars1 := len(pattern1) - wildcards1
        exactChars2 := len(pattern2) - wildcards2

        return exactChars1 &gt; exactChars2</span>
}

// ApplyPermissionRules applies permission rules to a file based on patterns.
func ApplyPermissionRules(filename string, rules types.Map, defaultPerm string) (string, error) <span class="cov8" title="1">{
        if rules.IsNull() || rules.IsUnknown() </span><span class="cov0" title="0">{
                return defaultPerm, nil
        }</span>

        <span class="cov8" title="1">elements := rules.Elements()
        bestMatch := ""
        bestPerm := ""

        // Find the most specific pattern match
        for pattern, permValue := range elements </span><span class="cov8" title="1">{
                if strPerm, ok := permValue.(types.String); ok </span><span class="cov8" title="1">{
                        if matchesPermissionPattern(pattern, filename) </span><span class="cov8" title="1">{
                                // Prefer more specific patterns (patterns with more characters are generally more specific)
                                if bestMatch == "" || len(pattern) &gt; len(bestMatch) || isMoreSpecific(pattern, bestMatch) </span><span class="cov8" title="1">{
                                        // Validate the permission
                                        if _, err := parsePermission(strPerm.ValueString()); err != nil </span><span class="cov0" title="0">{
                                                return defaultPerm, fmt.Errorf("invalid permission in rule %s: %w", pattern, err)
                                        }</span>
                                        <span class="cov8" title="1">bestMatch = pattern
                                        bestPerm = strPerm.ValueString()</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if bestMatch != "" </span><span class="cov8" title="1">{
                return bestPerm, nil
        }</span>

        <span class="cov8" title="1">return defaultPerm, nil</span>
}

// ValidatePermissionsModel validates the permissions configuration.
func ValidatePermissionsModel(permissions *PermissionsModel) error <span class="cov0" title="0">{
        if permissions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate directory permission
        <span class="cov0" title="0">if !permissions.Directory.IsNull() </span><span class="cov0" title="0">{
                if _, err := parsePermission(permissions.Directory.ValueString()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory permission: %w", err)
                }</span>
        }

        // Validate file permission
        <span class="cov0" title="0">if !permissions.Files.IsNull() </span><span class="cov0" title="0">{
                if _, err := parsePermission(permissions.Files.ValueString()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid files permission: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidatePermissionRules validates permission rules map.
func ValidatePermissionRules(rules types.Map) error <span class="cov0" title="0">{
        if rules.IsNull() || rules.IsUnknown() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">elements := rules.Elements()
        for pattern, permValue := range elements </span><span class="cov0" title="0">{
                if strPerm, ok := permValue.(types.String); ok </span><span class="cov0" title="0">{
                        if _, err := parsePermission(strPerm.ValueString()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid permission in rule %s: %w", pattern, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("permission rule %s has invalid type", pattern)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/ephemeral"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/validators"
)

// Ensure DotfilesProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;DotfilesProvider{}

// DotfilesProvider defines the provider implementation.
type DotfilesProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// DotfilesProviderModel describes the provider data model.
type DotfilesProviderModel struct {
        DotfilesRoot       types.String         `tfsdk:"dotfiles_root"`
        BackupEnabled      types.Bool           `tfsdk:"backup_enabled"`
        BackupDirectory    types.String         `tfsdk:"backup_directory"`
        Strategy           types.String         `tfsdk:"strategy"`
        ConflictResolution types.String         `tfsdk:"conflict_resolution"`
        DryRun             types.Bool           `tfsdk:"dry_run"`
        AutoDetectPlatform types.Bool           `tfsdk:"auto_detect_platform"`
        TargetPlatform     types.String         `tfsdk:"target_platform"`
        TemplateEngine     types.String         `tfsdk:"template_engine"`
        LogLevel           types.String         `tfsdk:"log_level"`
        BackupStrategy     *BackupStrategyModel `tfsdk:"backup_strategy"`
        Recovery           *RecoveryModel       `tfsdk:"recovery"`
}

func (p *DotfilesProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = "dotfiles"
        resp.Version = p.version
}</span>

func (p *DotfilesProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Terraform provider for managing dotfiles in a declarative, cross-platform manner.",
                Attributes: map[string]schema.Attribute{
                        "dotfiles_root": schema.StringAttribute{
                                MarkdownDescription: "Root directory of the dotfiles repository. Defaults to ~/dotfiles",
                                Optional:            true,
                        },
                        "backup_enabled": schema.BoolAttribute{
                                MarkdownDescription: "Enable automatic backups of existing files before modification. Defaults to true",
                                Optional:            true,
                        },
                        "backup_directory": schema.StringAttribute{
                                MarkdownDescription: "Directory to store backup files. Defaults to ~/.dotfiles-backups",
                                Optional:            true,
                        },
                        "strategy": schema.StringAttribute{
                                MarkdownDescription: "Default strategy for file management: symlink (default), copy, or template",
                                Optional:            true,
                        },
                        "conflict_resolution": schema.StringAttribute{
                                MarkdownDescription: "How to handle conflicts: backup (default), overwrite, skip, or prompt",
                                Optional:            true,
                        },
                        "dry_run": schema.BoolAttribute{
                                MarkdownDescription: "Preview changes without applying them. Defaults to false",
                                Optional:            true,
                        },
                        "auto_detect_platform": schema.BoolAttribute{
                                MarkdownDescription: "Automatically detect the target platform. Defaults to true",
                                Optional:            true,
                        },
                        "target_platform": schema.StringAttribute{
                                MarkdownDescription: "Target platform: auto (default), macos, linux, or windows",
                                Optional:            true,
                        },
                        "template_engine": schema.StringAttribute{
                                MarkdownDescription: "Template engine to use: go (default), handlebars, or mustache",
                                Optional:            true,
                                Validators: []validator.String{
                                        validators.ValidTemplateEngine(),
                                },
                        },
                        "log_level": schema.StringAttribute{
                                MarkdownDescription: "Log level: debug, info (default), warn, or error",
                                Optional:            true,
                        },
                },
                Blocks: map[string]schema.Block{
                        "backup_strategy": GetBackupStrategySchemaBlock(),
                        "recovery":        GetRecoverySchemaBlock(),
                },
        }
}</span>

func (p *DotfilesProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{
        var data EnhancedProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create and configure the client
        <span class="cov0" title="0">config := &amp;DotfilesConfig{}

        // Set configuration values from provider data
        if !data.DotfilesRoot.IsNull() </span><span class="cov0" title="0">{
                config.DotfilesRoot = data.DotfilesRoot.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.BackupEnabled.IsNull() </span><span class="cov0" title="0">{
                config.BackupEnabled = data.BackupEnabled.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.BackupEnabled = true // default to true
        }</span>

        <span class="cov0" title="0">if !data.BackupDirectory.IsNull() </span><span class="cov0" title="0">{
                config.BackupDirectory = data.BackupDirectory.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.Strategy.IsNull() </span><span class="cov0" title="0">{
                config.Strategy = data.Strategy.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.ConflictResolution.IsNull() </span><span class="cov0" title="0">{
                config.ConflictResolution = data.ConflictResolution.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.DryRun.IsNull() </span><span class="cov0" title="0">{
                config.DryRun = data.DryRun.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.DryRun = false
        }</span>

        <span class="cov0" title="0">if !data.AutoDetectPlatform.IsNull() </span><span class="cov0" title="0">{
                config.AutoDetectPlatform = data.AutoDetectPlatform.ValueBool()
        }</span> else<span class="cov0" title="0"> {
                config.AutoDetectPlatform = true
        }</span>

        <span class="cov0" title="0">if !data.TargetPlatform.IsNull() </span><span class="cov0" title="0">{
                config.TargetPlatform = data.TargetPlatform.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.TemplateEngine.IsNull() </span><span class="cov0" title="0">{
                config.TemplateEngine = data.TemplateEngine.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.LogLevel.IsNull() </span><span class="cov0" title="0">{
                config.LogLevel = data.LogLevel.ValueString()
        }</span>

        // Set defaults for any empty values
        <span class="cov0" title="0">if err := config.SetDefaults(); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to set configuration defaults",
                        "An error occurred while setting default configuration values: "+err.Error(),
                )
                return
        }</span>

        // Handle backup strategy configuration
        <span class="cov0" title="0">if data.BackupStrategy != nil </span><span class="cov0" title="0">{
                // Warn if both top-level and backup_strategy block are used
                if !data.BackupEnabled.IsNull() &amp;&amp; !data.BackupStrategy.Enabled.IsNull() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Conflicting backup configuration",
                                "Both top-level 'backup_enabled' and 'backup_strategy.enabled' are set. The backup_strategy block takes precedence.",
                        )
                }</span>
                <span class="cov0" title="0">if !data.BackupDirectory.IsNull() &amp;&amp; !data.BackupStrategy.Directory.IsNull() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Conflicting backup directory configuration",
                                "Both top-level 'backup_directory' and 'backup_strategy.directory' are set. The backup_strategy block takes precedence.",
                        )
                }</span>

                // Apply backup strategy configuration (overrides top-level settings)
                <span class="cov0" title="0">if !data.BackupStrategy.Enabled.IsNull() </span><span class="cov0" title="0">{
                        config.BackupEnabled = data.BackupStrategy.Enabled.ValueBool()
                }</span>
                <span class="cov0" title="0">if !data.BackupStrategy.Directory.IsNull() </span><span class="cov0" title="0">{
                        config.BackupDirectory = data.BackupStrategy.Directory.ValueString()
                }</span>
                // Additional backup strategy fields can be handled here as needed
                // For now, we keep the existing simple backup configuration approach
        }

        // Handle recovery configuration
        <span class="cov0" title="0">if data.Recovery != nil </span><span class="cov0" title="0">{
                // Recovery configuration is mainly used by resources
                // Log that recovery features are enabled if configured
                if !data.Recovery.CreateRestoreScripts.IsNull() &amp;&amp; data.Recovery.CreateRestoreScripts.ValueBool() </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Recovery restore scripts enabled")
                }</span>
                <span class="cov0" title="0">if !data.Recovery.ValidateBackups.IsNull() &amp;&amp; data.Recovery.ValidateBackups.ValueBool() </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Backup validation enabled")
                }</span>
        }

        // Validate configuration
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid provider configuration",
                        "The provider configuration is invalid: "+err.Error(),
                )
                return
        }</span>

        // Create the client
        <span class="cov0" title="0">client, err := NewDotfilesClient(config)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create dotfiles client",
                        "An error occurred while creating the dotfiles client: "+err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Info(ctx, "Configured dotfiles provider", map[string]interface{}{
                "dotfiles_root":   config.DotfilesRoot,
                "backup_enabled":  config.BackupEnabled,
                "strategy":        config.Strategy,
                "target_platform": config.TargetPlatform,
                "dry_run":         config.DryRun,
        })

        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

func (p *DotfilesProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov8" title="1">{
        return []func() resource.Resource{
                NewRepositoryResource,
                NewFileResource,
                NewSymlinkResource,
                NewDirectoryResource,
                NewApplicationResource,
        }
}</span>

func (p *DotfilesProvider) EphemeralResources(ctx context.Context) []func() ephemeral.EphemeralResource <span class="cov8" title="1">{
        return []func() ephemeral.EphemeralResource{
                // No ephemeral resources planned for initial implementation
        }
}</span>

func (p *DotfilesProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov8" title="1">{
        return []func() datasource.DataSource{
                NewSystemDataSource,
                NewFileInfoDataSource,
        }
}</span>

func (p *DotfilesProvider) Functions(ctx context.Context) []func() function.Function <span class="cov8" title="1">{
        return []func() function.Function{
                // Functions will be added in later phases
        }
}</span>

func New(version string) func() provider.Provider <span class="cov8" title="1">{
        return func() provider.Provider </span><span class="cov8" title="1">{
                return &amp;DotfilesProvider{
                        version: version,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/git"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;RepositoryResource{}

func NewRepositoryResource() resource.Resource <span class="cov8" title="1">{
        return &amp;RepositoryResource{}
}</span>

// RepositoryResource defines the resource implementation.
type RepositoryResource struct {
        client *DotfilesClient
}

// RepositoryResourceModel describes the resource data model.
type RepositoryResourceModel struct {
        ID                   types.String `tfsdk:"id"`
        Name                 types.String `tfsdk:"name"`
        SourcePath           types.String `tfsdk:"source_path"`
        Description          types.String `tfsdk:"description"`
        DefaultBackupEnabled types.Bool   `tfsdk:"default_backup_enabled"`
        DefaultFileMode      types.String `tfsdk:"default_file_mode"`
        DefaultDirMode       types.String `tfsdk:"default_dir_mode"`

        // Git-specific attributes
        GitBranch              types.String `tfsdk:"git_branch"`
        GitPersonalAccessToken types.String `tfsdk:"git_personal_access_token"`
        GitUsername            types.String `tfsdk:"git_username"`
        GitSSHPrivateKeyPath   types.String `tfsdk:"git_ssh_private_key_path"`
        GitSSHPassphrase       types.String `tfsdk:"git_ssh_passphrase"`
        GitUpdateInterval      types.String `tfsdk:"git_update_interval"`

        // Computed attributes
        LocalPath  types.String `tfsdk:"local_path"`
        LastCommit types.String `tfsdk:"last_commit"`
        LastUpdate types.String `tfsdk:"last_update"`
}

func (r *RepositoryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_repository"
}</span>

func (r *RepositoryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages a dotfiles repository configuration. Supports both local paths and Git repositories (GitHub, GitLab, etc.)",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Repository identifier",
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Repository name",
                        },
                        "source_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the dotfiles repository. Can be a local path or Git URL (e.g., 'https://github.com/user/dotfiles.git')",
                        },
                        "description": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Repository description",
                        },
                        "default_backup_enabled": schema.BoolAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default backup setting for resources in this repository",
                        },
                        "default_file_mode": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default file permissions (e.g., '0644')",
                        },
                        "default_dir_mode": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Default directory permissions (e.g., '0755')",
                        },

                        // Git-specific attributes
                        "git_branch": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Git branch to checkout (defaults to repository default branch)",
                        },
                        "git_personal_access_token": schema.StringAttribute{
                                Optional:            true,
                                Sensitive:           true,
                                MarkdownDescription: "GitHub Personal Access Token for private repository authentication",
                        },
                        "git_username": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Username for Git authentication (optional when using PAT)",
                        },
                        "git_ssh_private_key_path": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Path to SSH private key for Git authentication",
                        },
                        "git_ssh_passphrase": schema.StringAttribute{
                                Optional:            true,
                                Sensitive:           true,
                                MarkdownDescription: "Passphrase for SSH private key",
                        },
                        "git_update_interval": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "Interval to check for updates (e.g., '1h', '30m'). Use 'never' to disable automatic updates",
                        },

                        // Computed attributes
                        "local_path": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Local path where the repository is stored",
                        },
                        "last_commit": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "SHA of the last commit",
                        },
                        "last_update": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Timestamp of the last repository update",
                        },
                },
        }
}</span>

func (r *RepositoryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else. Please report this issue to the provider developers.",
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

func (r *RepositoryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        tflog.Debug(ctx, "=== REPOSITORY CREATE START ===")
        tflog.Debug(ctx, "Getting plan data from request")
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get plan data", map[string]interface{}{
                        "diagnostics_count": len(resp.Diagnostics),
                })
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating repository resource", map[string]interface{}{
                "name":                   data.Name.ValueString(),
                "source_path":            data.SourcePath.ValueString(),
                "description":            data.Description.ValueString(),
                "default_backup_enabled": data.DefaultBackupEnabled.ValueBool(),
                "default_file_mode":      data.DefaultFileMode.ValueString(),
                "default_dir_mode":       data.DefaultDirMode.ValueString(),
                "git_branch":             data.GitBranch.ValueString(),
                "git_update_interval":    data.GitUpdateInterval.ValueString(),
        })

        sourcePath := data.SourcePath.ValueString()
        tflog.Debug(ctx, "Processing source path", map[string]interface{}{
                "raw_source_path": sourcePath,
        })

        // Check if source is a Git URL
        isGitURL := git.IsGitURL(sourcePath)
        tflog.Debug(ctx, "Checking source type", map[string]interface{}{
                "is_git_url":  isGitURL,
                "source_path": sourcePath,
        })

        if isGitURL </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Processing as Git repository")
                // Handle Git repository
                info, err := r.setupGitRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Git repository setup failed", map[string]interface{}{
                                "error":       err.Error(),
                                "source_path": sourcePath,
                        })
                        resp.Diagnostics.AddError(
                                "Failed to setup Git repository",
                                fmt.Sprintf("Could not clone or setup Git repository: %s", err.Error()),
                        )
                        return
                }</span>

                // Update model with Git info
                <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                data.LastCommit = types.StringValue(info.LastCommit)
                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))

                tflog.Info(ctx, "Git repository cloned successfully", map[string]interface{}{
                        "url":         info.URL,
                        "local_path":  info.LocalPath,
                        "last_commit": info.LastCommit,
                        "last_update": data.LastUpdate.ValueString(),
                })</span>
        } else<span class="cov0" title="0"> {
                tflog.Debug(ctx, "Processing as local repository")
                // Handle local repository
                err := r.setupLocalRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Local repository setup failed", map[string]interface{}{
                                "error":       err.Error(),
                                "source_path": sourcePath,
                        })
                        resp.Diagnostics.AddError(
                                "Failed to setup local repository",
                                fmt.Sprintf("Could not setup local repository: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.LocalPath = data.SourcePath
                data.LastUpdate = types.StringValue(time.Now().Format(time.RFC3339))

                // Check if local repository is a Git repository and get commit info
                localPath := data.SourcePath.ValueString()

                tflog.Debug(ctx, "Checking if repository is a Git repository", map[string]interface{}{
                        "local_path": localPath,
                })

                isGitRepo := r.isGitRepository(localPath)
                tflog.Debug(ctx, "Git repository detection result", map[string]interface{}{
                        "local_path": localPath,
                        "is_git":     isGitRepo,
                })

                if isGitRepo </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Creating Git manager for local repository", map[string]interface{}{
                                "local_path": localPath,
                        })

                        gitManager, err := git.NewGitManager(nil) // No auth needed for local repos
                        if err == nil </span><span class="cov0" title="0">{
                                tflog.Debug(ctx, "Git manager created successfully, retrieving repository info", map[string]interface{}{
                                        "local_path": localPath,
                                })

                                info, err := gitManager.GetRepositoryInfo(localPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        data.LastCommit = types.StringValue(info.LastCommit)
                                        tflog.Info(ctx, "Successfully retrieved Git info for local repository", map[string]interface{}{
                                                "local_path":  localPath,
                                                "last_commit": info.LastCommit,
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        tflog.Error(ctx, "Failed to get Git repository info", map[string]interface{}{
                                                "error":      err.Error(),
                                                "local_path": localPath,
                                        })
                                        // Set empty but valid commit for repositories with Git issues
                                        data.LastCommit = types.StringValue("")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tflog.Error(ctx, "Failed to create Git manager", map[string]interface{}{
                                        "error":      err.Error(),
                                        "local_path": localPath,
                                })
                                data.LastCommit = types.StringValue("")
                        }</span>
                } else<span class="cov0" title="0"> {
                        tflog.Info(ctx, "Repository is not a Git repository, setting empty commit", map[string]interface{}{
                                "local_path": localPath,
                        })
                        // Not a Git repository, set empty but valid commit
                        data.LastCommit = types.StringValue("")
                }</span>

                <span class="cov0" title="0">tflog.Info(ctx, "Local repository setup successfully", map[string]interface{}{
                        "source_path": sourcePath,
                        "local_path":  data.LocalPath.ValueString(),
                        "last_commit": data.LastCommit.ValueString(),
                        "last_update": data.LastUpdate.ValueString(),
                })</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        // Check if this is a Git repository
        sourcePath := data.SourcePath.ValueString()
        if git.IsGitURL(sourcePath) </span><span class="cov0" title="0">{
                // Handle Git repository
                if !data.LocalPath.IsNull() </span><span class="cov0" title="0">{
                        localPath := data.LocalPath.ValueString()

                        // Check if local repository still exists
                        if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                                // Get current repository info
                                authConfig := r.buildAuthConfig(&amp;data)
                                gitManager, err := git.NewGitManager(authConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        tflog.Warn(ctx, "Failed to create Git manager during read", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        info, err := gitManager.GetRepositoryInfo(localPath)
                                        if err == nil </span><span class="cov0" title="0">{
                                                // Update computed attributes
                                                data.LastCommit = types.StringValue(info.LastCommit)
                                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))
                                        }</span> else<span class="cov0" title="0"> {
                                                tflog.Warn(ctx, "Failed to get repository info", map[string]interface{}{
                                                        "error": err.Error(),
                                                })
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                tflog.Warn(ctx, "Local repository path no longer exists", map[string]interface{}{
                                        "local_path": localPath,
                                })
                                // Repository was deleted externally, mark for recreation
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle local repository - just verify it still exists
                localPath := data.LocalPath.ValueString()
                if localPath == "" </span><span class="cov0" title="0">{
                        localPath = sourcePath
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(localPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Local repository not found",
                                fmt.Sprintf("The local repository at %s no longer exists.", localPath),
                        )
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Updating repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        sourcePath := data.SourcePath.ValueString()

        // Check if source is a Git URL and needs updating
        if git.IsGitURL(sourcePath) </span><span class="cov0" title="0">{
                // Handle Git repository update
                if !data.LocalPath.IsNull() </span><span class="cov0" title="0">{
                        localPath := data.LocalPath.ValueString()

                        // Check if local repository exists
                        if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                                // Update the repository
                                authConfig := r.buildAuthConfig(&amp;data)
                                gitManager, err := git.NewGitManager(authConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to create Git manager",
                                                fmt.Sprintf("Could not create Git manager for update: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                <span class="cov0" title="0">info, err := gitManager.UpdateRepository(ctx, localPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to update Git repository",
                                                fmt.Sprintf("Could not update Git repository: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                // Update computed attributes
                                <span class="cov0" title="0">data.LastCommit = types.StringValue(info.LastCommit)
                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))

                                tflog.Info(ctx, "Git repository updated successfully", map[string]interface{}{
                                        "local_path":  info.LocalPath,
                                        "last_commit": info.LastCommit,
                                })</span>
                        } else<span class="cov0" title="0"> {
                                // Repository doesn't exist locally, re-create it
                                tflog.Info(ctx, "Local repository not found, re-cloning", map[string]interface{}{
                                        "local_path": localPath,
                                })

                                info, err := r.setupGitRepository(ctx, &amp;data)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Failed to re-setup Git repository",
                                                fmt.Sprintf("Could not re-clone Git repository: %s", err.Error()),
                                        )
                                        return
                                }</span>

                                // Update model with Git info
                                <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                                data.LastCommit = types.StringValue(info.LastCommit)
                                data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // No local path set, treat as new setup
                        info, err := r.setupGitRepository(ctx, &amp;data)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        "Failed to setup Git repository",
                                        fmt.Sprintf("Could not setup Git repository: %s", err.Error()),
                                )
                                return
                        }</span>

                        // Update model with Git info
                        <span class="cov0" title="0">data.LocalPath = types.StringValue(info.LocalPath)
                        data.LastCommit = types.StringValue(info.LastCommit)
                        data.LastUpdate = types.StringValue(info.LastUpdate.Format(time.RFC3339))</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle local repository update
                err := r.setupLocalRepository(ctx, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Failed to update local repository",
                                fmt.Sprintf("Could not update local repository: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.LocalPath = data.SourcePath
                data.LastUpdate = types.StringValue(time.Now().Format(time.RFC3339))

                // Check if local repository is a Git repository and get commit info
                localPath := data.SourcePath.ValueString()
                if r.isGitRepository(localPath) </span><span class="cov0" title="0">{
                        gitManager, err := git.NewGitManager(nil) // No auth needed for local repos
                        if err == nil </span><span class="cov0" title="0">{
                                info, err := gitManager.GetRepositoryInfo(localPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        data.LastCommit = types.StringValue(info.LastCommit)
                                        tflog.Debug(ctx, "Retrieved Git info for local repository update", map[string]interface{}{
                                                "local_path":  localPath,
                                                "last_commit": info.LastCommit,
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        tflog.Warn(ctx, "Failed to get Git info for local repository update", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                        // Set empty but valid commit for non-Git local repos
                                        data.LastCommit = types.StringValue("")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.LastCommit = types.StringValue("")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not a Git repository, set empty but valid commit
                        data.LastCommit = types.StringValue("")
                }</span>
        }

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RepositoryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data RepositoryResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting repository resource", map[string]interface{}{
                "name": data.Name.ValueString(),
        })

        // For dotfiles repositories, we typically don't delete the actual files,
        // just remove them from Terraform state. The local cache will remain.
        tflog.Info(ctx, "Repository resource removed from state", map[string]interface{}{
                "name": data.Name.ValueString(),
        })</span>
}

// setupGitRepository handles cloning and setting up a Git repository.
func (r *RepositoryResource) setupGitRepository(ctx context.Context, data *RepositoryResourceModel) (*git.RepositoryInfo, error) <span class="cov0" title="0">{
        sourcePath := data.SourcePath.ValueString()

        // Create authentication config
        authConfig := &amp;git.AuthConfig{}

        // Configure PAT authentication
        if !data.GitPersonalAccessToken.IsNull() </span><span class="cov0" title="0">{
                authConfig.PersonalAccessToken = data.GitPersonalAccessToken.ValueString()
                if !data.GitUsername.IsNull() </span><span class="cov0" title="0">{
                        authConfig.Username = data.GitUsername.ValueString()
                }</span>
        }

        // Configure SSH authentication
        <span class="cov0" title="0">if !data.GitSSHPrivateKeyPath.IsNull() </span><span class="cov0" title="0">{
                authConfig.SSHPrivateKeyPath = data.GitSSHPrivateKeyPath.ValueString()
                if !data.GitSSHPassphrase.IsNull() </span><span class="cov0" title="0">{
                        authConfig.SSHPassphrase = data.GitSSHPassphrase.ValueString()
                }</span>
        }

        // Check for environment variable PAT if not provided
        <span class="cov0" title="0">if authConfig.PersonalAccessToken == "" </span><span class="cov0" title="0">{
                if envPAT := os.Getenv("GITHUB_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                        tflog.Debug(ctx, "Using GitHub token from GITHUB_TOKEN environment variable")
                }</span> else<span class="cov0" title="0"> if envPAT := os.Getenv("GH_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                        tflog.Debug(ctx, "Using GitHub token from GH_TOKEN environment variable")
                }</span>
        }

        // Create Git manager
        <span class="cov0" title="0">gitManager, err := git.NewGitManager(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Git manager: %w", err)
        }</span>

        // Determine local cache path
        <span class="cov0" title="0">cacheRoot := filepath.Join(r.client.HomeDir, ".terraform-dotfiles-cache")
        localPath, err := git.GetLocalCachePath(cacheRoot, sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine cache path: %w", err)
        }</span>

        // Check if repository already exists locally
        <span class="cov0" title="0">if _, err := os.Stat(localPath); err == nil </span><span class="cov0" title="0">{
                // Repository exists, try to update it
                tflog.Debug(ctx, "Repository already exists locally, updating", map[string]interface{}{
                        "local_path": localPath,
                })

                info, err := gitManager.UpdateRepository(ctx, localPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to update existing repository, will re-clone", map[string]interface{}{
                                "error": err.Error(),
                        })

                        // Remove existing directory and re-clone
                        if err := os.RemoveAll(localPath); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to remove existing repository: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return info, nil
                }</span>
        }

        // Clone repository
        <span class="cov0" title="0">branch := ""
        if !data.GitBranch.IsNull() </span><span class="cov0" title="0">{
                branch = data.GitBranch.ValueString()
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Cloning Git repository", map[string]interface{}{
                "url":        sourcePath,
                "local_path": localPath,
                "branch":     branch,
        })

        info, err := gitManager.CloneRepository(ctx, sourcePath, localPath, branch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// setupLocalRepository handles validation of a local repository.
func (r *RepositoryResource) setupLocalRepository(ctx context.Context, data *RepositoryResourceModel) error <span class="cov8" title="1">{
        tflog.Debug(ctx, "=== SETUP LOCAL REPOSITORY START ===")

        sourcePath := data.SourcePath.ValueString()
        tflog.Debug(ctx, "Initial source path", map[string]interface{}{
                "source_path": sourcePath,
                "home_dir":    r.client.HomeDir,
        })

        // Expand the path
        originalPath := sourcePath
        if sourcePath[0] == '~' </span><span class="cov8" title="1">{
                sourcePath = filepath.Join(r.client.HomeDir, sourcePath[1:])
                tflog.Debug(ctx, "Expanded tilde path", map[string]interface{}{
                        "original_path": originalPath,
                        "expanded_path": sourcePath,
                })
        }</span>

        // Convert to absolute path
        <span class="cov8" title="1">absPath, err := filepath.Abs(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get absolute path", map[string]interface{}{
                        "error":       err.Error(),
                        "source_path": sourcePath,
                })
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>
        <span class="cov8" title="1">tflog.Debug(ctx, "Converted to absolute path", map[string]interface{}{
                "source_path": sourcePath,
                "abs_path":    absPath,
        })

        // Check if path exists
        tflog.Debug(ctx, "Checking if path exists", map[string]interface{}{
                "abs_path": absPath,
        })
        stat, err := os.Stat(absPath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                tflog.Info(ctx, "Local repository directory does not exist, creating it", map[string]interface{}{
                        "abs_path":    absPath,
                        "permissions": "0755",
                })
                if err := os.MkdirAll(absPath, 0755); err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to create directory", map[string]interface{}{
                                "error":    err.Error(),
                                "abs_path": absPath,
                        })
                        return fmt.Errorf("failed to create local repository directory: %w", err)
                }</span>
                <span class="cov8" title="1">tflog.Debug(ctx, "Local repository directory created successfully", map[string]interface{}{
                        "abs_path": absPath,
                })

                // Re-stat the newly created directory
                stat, err = os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to stat newly created directory", map[string]interface{}{
                                "error":    err.Error(),
                                "abs_path": absPath,
                        })
                        return fmt.Errorf("failed to stat newly created path: %w", err)
                }</span>
                <span class="cov8" title="1">tflog.Debug(ctx, "Successfully re-statted created directory", map[string]interface{}{
                        "abs_path": absPath,
                        "is_dir":   stat.IsDir(),
                        "mode":     stat.Mode().String(),
                        "size":     stat.Size(),
                })</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to stat existing path", map[string]interface{}{
                        "error":    err.Error(),
                        "abs_path": absPath,
                })
                return fmt.Errorf("failed to stat path: %w", err)
        }</span> else<span class="cov8" title="1"> {
                tflog.Debug(ctx, "Path already exists", map[string]interface{}{
                        "abs_path": absPath,
                        "is_dir":   stat.IsDir(),
                        "mode":     stat.Mode().String(),
                        "size":     stat.Size(),
                })
        }</span>

        // Ensure it's a directory
        <span class="cov8" title="1">if !stat.IsDir() </span><span class="cov8" title="1">{
                tflog.Error(ctx, "Source path is not a directory", map[string]interface{}{
                        "abs_path": absPath,
                        "mode":     stat.Mode().String(),
                        "is_dir":   stat.IsDir(),
                })
                return fmt.Errorf("source path is not a directory: %s", absPath)
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "Local repository validated successfully", map[string]interface{}{
                "original_source_path": originalPath,
                "final_abs_path":       absPath,
                "is_directory":         true,
        })

        // Update source path to absolute path
        data.SourcePath = types.StringValue(absPath)
        tflog.Debug(ctx, "Updated source path in data model", map[string]interface{}{
                "new_source_path": absPath,
        })

        tflog.Debug(ctx, "=== SETUP LOCAL REPOSITORY END ===")
        return nil</span>
}

// buildAuthConfig creates authentication config from resource data.
func (r *RepositoryResource) buildAuthConfig(data *RepositoryResourceModel) *git.AuthConfig <span class="cov8" title="1">{
        authConfig := &amp;git.AuthConfig{}

        // Configure PAT authentication
        if !data.GitPersonalAccessToken.IsNull() </span><span class="cov8" title="1">{
                authConfig.PersonalAccessToken = data.GitPersonalAccessToken.ValueString()
                if !data.GitUsername.IsNull() </span><span class="cov8" title="1">{
                        authConfig.Username = data.GitUsername.ValueString()
                }</span>
        }

        // Configure SSH authentication
        <span class="cov8" title="1">if !data.GitSSHPrivateKeyPath.IsNull() </span><span class="cov8" title="1">{
                authConfig.SSHPrivateKeyPath = data.GitSSHPrivateKeyPath.ValueString()
                if !data.GitSSHPassphrase.IsNull() </span><span class="cov8" title="1">{
                        authConfig.SSHPassphrase = data.GitSSHPassphrase.ValueString()
                }</span>
        }

        // Check for environment variable PAT if not provided
        <span class="cov8" title="1">if authConfig.PersonalAccessToken == "" </span><span class="cov8" title="1">{
                if envPAT := os.Getenv("GITHUB_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                }</span> else<span class="cov8" title="1"> if envPAT := os.Getenv("GH_TOKEN"); envPAT != "" </span><span class="cov0" title="0">{
                        authConfig.PersonalAccessToken = envPAT
                }</span>
        }

        <span class="cov8" title="1">return authConfig</span>
}

// isGitRepository checks if a local path contains a Git repository.
func (r *RepositoryResource) isGitRepository(localPath string) bool <span class="cov0" title="0">{
        gitDir := filepath.Join(localPath, ".git")

        stat, err := os.Stat(gitDir)
        if err != nil </span><span class="cov0" title="0">{
                // .git directory/file doesn't exist
                return false
        }</span>

        // .git exists, check if it's a directory (normal repo) or file (worktree/submodule)
        <span class="cov0" title="0">isGitRepo := stat.IsDir() || stat.Mode().IsRegular()
        return isGitRepo</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"

        "github.com/jamesainslie/terraform-provider-dotfiles/internal/fileops"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/platform"
        "github.com/jamesainslie/terraform-provider-dotfiles/internal/utils"
)

var _ resource.Resource = &amp;SymlinkResource{}

func NewSymlinkResource() resource.Resource <span class="cov8" title="1">{
        return &amp;SymlinkResource{}
}</span>

type SymlinkResource struct {
        client *DotfilesClient
}

type SymlinkResourceModel struct {
        ID            types.String `tfsdk:"id"`
        Repository    types.String `tfsdk:"repository"`
        Name          types.String `tfsdk:"name"`
        SourcePath    types.String `tfsdk:"source_path"`
        TargetPath    types.String `tfsdk:"target_path"`
        ForceUpdate   types.Bool   `tfsdk:"force_update"`
        CreateParents types.Bool   `tfsdk:"create_parents"`

        // Enhanced fields
        Permissions        *PermissionsModel `tfsdk:"permissions"`
        PermissionRules    types.Map         `tfsdk:"permission_rules"`
        PostCreateCommands types.List        `tfsdk:"post_create_commands"`
        PostUpdateCommands types.List        `tfsdk:"post_update_commands"`
        PreDestroyCommands types.List        `tfsdk:"pre_destroy_commands"`

        // Computed attributes
        LinkExists   types.Bool   `tfsdk:"link_exists"`
        IsSymlink    types.Bool   `tfsdk:"is_symlink"`
        LinkTarget   types.String `tfsdk:"link_target"`
        LastModified types.String `tfsdk:"last_modified"`
}

func (r *SymlinkResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_symlink"
}</span>

func (r *SymlinkResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        // Build base attributes
        baseAttributes := map[string]schema.Attribute{
                "id": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Symlink identifier",
                },
                "repository": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Repository ID this symlink belongs to",
                },
                "name": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Symlink name/identifier",
                },
                "source_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Path to source in repository",
                },
                "target_path": schema.StringAttribute{
                        Required:            true,
                        MarkdownDescription: "Target symlink path",
                },
                "force_update": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Force update existing symlinks",
                },
                "create_parents": schema.BoolAttribute{
                        Optional:            true,
                        MarkdownDescription: "Create parent directories",
                },
                "permission_rules": GetPermissionRulesAttribute(),
                "link_exists": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the symlink exists",
                },
                "is_symlink": schema.BoolAttribute{
                        Computed:            true,
                        MarkdownDescription: "Whether the target is actually a symlink",
                },
                "link_target": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "The target that the symlink points to",
                },
                "last_modified": schema.StringAttribute{
                        Computed:            true,
                        MarkdownDescription: "Last modification timestamp of the symlink",
                },
        }

        // Add post-hooks attributes
        postHooksAttrs := GetPostHooksAttributes()
        for key, attr := range postHooksAttrs </span><span class="cov8" title="1">{
                baseAttributes[key] = attr
        }</span>

        <span class="cov8" title="1">resp.Schema = schema.Schema{
                MarkdownDescription: "Manages symbolic links to dotfiles with comprehensive permission management",
                Attributes:          baseAttributes,
                Blocks: map[string]schema.Block{
                        "permissions": GetPermissionsSchemaBlock(),
                },
        }</span>
}

func (r *SymlinkResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        "Expected *DotfilesClient, got something else.",
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

func (r *SymlinkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel

        tflog.Debug(ctx, "=== SYMLINK CREATE START ===")
        tflog.Debug(ctx, "Getting plan data from request")
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to get plan data", map[string]interface{}{
                        "diagnostics_count": len(resp.Diagnostics),
                })
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Creating symlink resource", map[string]interface{}{
                "name":           data.Name.ValueString(),
                "repository":     data.Repository.ValueString(),
                "source_path":    data.SourcePath.ValueString(),
                "target_path":    data.TargetPath.ValueString(),
                "force_update":   data.ForceUpdate.ValueBool(),
                "create_parents": data.CreateParents.ValueBool(),
        })

        // Get repository local path
        repositoryID := data.Repository.ValueString()
        repositoryLocalPath := r.getRepositoryLocalPath(repositoryID)
        tflog.Debug(ctx, "Retrieved repository local path", map[string]interface{}{
                "repository_id":   repositoryID,
                "repository_path": repositoryLocalPath,
        })

        // Build source path
        sourcePath := filepath.Join(repositoryLocalPath, data.SourcePath.ValueString())
        targetPath := data.TargetPath.ValueString()
        tflog.Debug(ctx, "Built file paths", map[string]interface{}{
                "raw_source_path":  data.SourcePath.ValueString(),
                "full_source_path": sourcePath,
                "raw_target_path":  targetPath,
        })

        // Expand target path
        platformProvider := platform.DetectPlatform()
        tflog.Debug(ctx, "Detected platform", map[string]interface{}{
                "platform_type": fmt.Sprintf("%T", platformProvider),
        })

        expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to expand target path", map[string]interface{}{
                        "error":       err.Error(),
                        "target_path": targetPath,
                })
                resp.Diagnostics.AddError(
                        "Invalid target path",
                        fmt.Sprintf("Could not expand target path %s: %s", targetPath, err.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Expanded target path", map[string]interface{}{
                "original_target": targetPath,
                "expanded_target": expandedTargetPath,
        })

        // Expand source path
        expandedSourcePath, err := platformProvider.ExpandPath(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Failed to expand source path", map[string]interface{}{
                        "error":       err.Error(),
                        "source_path": sourcePath,
                })
                resp.Diagnostics.AddError(
                        "Invalid source path",
                        fmt.Sprintf("Could not expand source path %s: %s", sourcePath, err.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Expanded source path", map[string]interface{}{
                "original_source": sourcePath,
                "expanded_source": expandedSourcePath,
        })

        // Verify source exists
        tflog.Debug(ctx, "Checking if source exists", map[string]interface{}{
                "expanded_source": expandedSourcePath,
        })
        sourceExists := utils.PathExists(expandedSourcePath)
        if !sourceExists </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Source path does not exist", map[string]interface{}{
                        "expanded_source": expandedSourcePath,
                })
                resp.Diagnostics.AddError(
                        "Source not found",
                        fmt.Sprintf("Source path does not exist: %s", expandedSourcePath),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Source path verified", map[string]interface{}{
                "expanded_source": expandedSourcePath,
        })

        // Create file manager
        dryRun := r.client.Config.DryRun
        tflog.Debug(ctx, "Creating file manager", map[string]interface{}{
                "dry_run": dryRun,
        })
        fileManager := fileops.NewFileManager(platformProvider, dryRun)

        // Handle existing target
        tflog.Debug(ctx, "Checking if target exists", map[string]interface{}{
                "expanded_target": expandedTargetPath,
        })
        targetExists := utils.PathExists(expandedTargetPath)
        tflog.Debug(ctx, "Target existence check result", map[string]interface{}{
                "target_exists": targetExists,
        })

        if targetExists </span><span class="cov0" title="0">{
                if !data.ForceUpdate.ValueBool() </span><span class="cov0" title="0">{
                        // Create backup if enabled
                        if r.client.Config.BackupEnabled </span><span class="cov0" title="0">{
                                _, err := fileManager.CreateBackup(expandedTargetPath, r.client.Config.BackupDirectory)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddWarning(
                                                "Backup failed",
                                                fmt.Sprintf("Could not create backup of existing target: %s", err.Error()),
                                        )
                                }</span>
                        }
                }

                // Remove existing target (handle both files and directories)
                <span class="cov0" title="0">tflog.Debug(ctx, "Statting existing target for removal", map[string]interface{}{
                        "expanded_target": expandedTargetPath,
                })
                info, err := os.Stat(expandedTargetPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to stat existing target", map[string]interface{}{
                                "error":           err.Error(),
                                "expanded_target": expandedTargetPath,
                        })
                        resp.Diagnostics.AddError(
                                "Could not stat existing target",
                                fmt.Sprintf("Could not stat existing target at %s: %s", expandedTargetPath, err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">isDir := info.IsDir()
                tflog.Debug(ctx, "Target stat results", map[string]interface{}{
                        "is_directory": isDir,
                        "mode":         info.Mode().String(),
                        "size":         info.Size(),
                })

                if isDir </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Removing existing directory with RemoveAll")
                        // Use RemoveAll for directories
                        err = os.RemoveAll(expandedTargetPath)
                }</span> else<span class="cov0" title="0"> {
                        tflog.Debug(ctx, "Removing existing file with Remove")
                        // Use Remove for files
                        err = os.Remove(expandedTargetPath)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Failed to remove existing target", map[string]interface{}{
                                "error":           err.Error(),
                                "expanded_target": expandedTargetPath,
                                "was_directory":   isDir,
                        })
                        resp.Diagnostics.AddError(
                                "Could not remove existing target",
                                fmt.Sprintf("Could not remove existing target at %s: %s", expandedTargetPath, err.Error()),
                        )
                        return
                }</span>
                <span class="cov0" title="0">tflog.Debug(ctx, "Successfully removed existing target", map[string]interface{}{
                        "expanded_target": expandedTargetPath,
                        "was_directory":   isDir,
                })</span>
        }

        // Create symlink
        <span class="cov0" title="0">tflog.Debug(ctx, "Creating symlink", map[string]interface{}{
                "source_path":    expandedSourcePath,
                "target_path":    expandedTargetPath,
                "create_parents": data.CreateParents.ValueBool(),
        })

        var finalErr error
        if data.CreateParents.ValueBool() </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Using CreateSymlinkWithParents")
                finalErr = fileManager.CreateSymlinkWithParents(expandedSourcePath, expandedTargetPath)
        }</span> else<span class="cov0" title="0"> {
                tflog.Debug(ctx, "Using CreateSymlink")
                finalErr = fileManager.CreateSymlink(expandedSourcePath, expandedTargetPath)
        }</span>

        <span class="cov0" title="0">if finalErr != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Symlink creation failed", map[string]interface{}{
                        "error":       finalErr.Error(),
                        "source_path": expandedSourcePath,
                        "target_path": expandedTargetPath,
                })
                resp.Diagnostics.AddError(
                        "Symlink creation failed",
                        fmt.Sprintf("Could not create symlink %s -&gt; %s: %s", expandedTargetPath, expandedSourcePath, finalErr.Error()),
                )
                return
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "Symlink created successfully")

        // Update computed attributes
        tflog.Debug(ctx, "Updating computed attributes")
        if err := r.updateComputedAttributes(ctx, &amp;data, expandedTargetPath); err != nil </span><span class="cov0" title="0">{
                tflog.Warn(ctx, "Failed to update computed attributes, setting defaults", map[string]interface{}{
                        "error": err.Error(),
                })
                // Set default values for computed attributes if update fails
                data.LinkExists = types.BoolValue(utils.PathExists(expandedTargetPath))
                data.IsSymlink = types.BoolValue(false)
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))

                resp.Diagnostics.AddWarning(
                        "Could not update symlink metadata",
                        fmt.Sprintf("Symlink created successfully but could not update metadata: %s", err.Error()),
                )
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">tflog.Debug(ctx, "Setting resource ID and saving state", map[string]interface{}{
                "id": data.Name.ValueString(),
        })
        data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Info(ctx, "Symlink resource created successfully", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": expandedTargetPath,
                "source_path": expandedSourcePath,
                "link_exists": data.LinkExists.ValueBool(),
                "is_symlink":  data.IsSymlink.ValueBool(),
        })
        tflog.Debug(ctx, "=== SYMLINK CREATE END ===")</span>
}

func (r *SymlinkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Reading symlink resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Expand target path to check current state
        platformProvider := platform.DetectPlatform()
        expandedTargetPath, err := platformProvider.ExpandPath(data.TargetPath.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to expand target path",
                        fmt.Sprintf("Error expanding target path for symlink %s: %v", data.Name.ValueString(), err),
                )
                return
        }</span>

        // Update computed attributes with current state
        <span class="cov0" title="0">err = r.updateComputedAttributes(ctx, &amp;data, expandedTargetPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Failed to update computed attributes",
                        fmt.Sprintf("Error updating attributes for symlink %s: %v", data.Name.ValueString(), err),
                )
                // Set default values if update fails
                data.LinkExists = types.BoolValue(utils.PathExists(expandedTargetPath))
                data.IsSymlink = types.BoolValue(utils.IsSymlink(expandedTargetPath))
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))
        }</span>

        // Verify symlink integrity if it exists
        <span class="cov0" title="0">if data.LinkExists.ValueBool() &amp;&amp; data.IsSymlink.ValueBool() </span><span class="cov0" title="0">{
                // Check if the symlink target matches our expected source
                actualTarget, err := os.Readlink(expandedTargetPath)
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Could not read symlink target", map[string]interface{}{
                                "target_path": expandedTargetPath,
                                "error":       err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        // Expand the source path to compare
                        expandedSourcePath, err := platformProvider.ExpandPath(data.SourcePath.ValueString())
                        if err == nil </span><span class="cov0" title="0">{
                                // Make paths absolute for comparison
                                expectedTarget, _ := filepath.Abs(expandedSourcePath)
                                actualTargetAbs, _ := filepath.Abs(actualTarget)

                                if expectedTarget != actualTargetAbs </span><span class="cov0" title="0">{
                                        tflog.Info(ctx, "Symlink target drift detected", map[string]interface{}{
                                                "expected": expectedTarget,
                                                "actual":   actualTargetAbs,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SymlinkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Set ID and save state
        <span class="cov0" title="0">data.ID = data.Name
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SymlinkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SymlinkResourceModel

        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Deleting symlink resource", map[string]interface{}{
                "name":        data.Name.ValueString(),
                "target_path": data.TargetPath.ValueString(),
        })

        // Remove the symlink
        targetPath := data.TargetPath.ValueString()
        if targetPath != "" </span><span class="cov0" title="0">{
                platformProvider := platform.DetectPlatform()
                expandedTargetPath, err := platformProvider.ExpandPath(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Could not expand target path",
                                fmt.Sprintf("Could not expand target path for cleanup: %s", err.Error()),
                        )
                        return
                }</span>

                <span class="cov0" title="0">if utils.PathExists(expandedTargetPath) </span><span class="cov0" title="0">{
                        err := os.Remove(expandedTargetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        "Could not remove symlink",
                                        fmt.Sprintf("Could not remove symlink %s: %s", expandedTargetPath, err.Error()),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                tflog.Info(ctx, "Symlink resource removed", map[string]interface{}{
                                        "target_path": expandedTargetPath,
                                })
                        }</span>
                }
        }
}

// getRepositoryLocalPath returns the local path for a repository.
func (r *SymlinkResource) getRepositoryLocalPath(repositoryID string) string <span class="cov0" title="0">{
        // For now, assume repository ID maps to the dotfiles root
        // TODO: Implement proper repository lookup when repository state management is added
        _ = repositoryID // TODO: Use repositoryID when repository lookup is implemented
        return r.client.Config.DotfilesRoot
}</span>

// updateComputedAttributes updates computed attributes for state tracking.
func (r *SymlinkResource) updateComputedAttributes(ctx context.Context, data *SymlinkResourceModel, targetPath string) error <span class="cov0" title="0">{
        tflog.Debug(ctx, "Updating computed attributes for symlink", map[string]interface{}{
                "target_path": targetPath,
        })

        // Check if link exists
        exists := utils.PathExists(targetPath)
        data.LinkExists = types.BoolValue(exists)
        tflog.Debug(ctx, "Link exists check", map[string]interface{}{
                "exists": exists,
        })

        if exists </span><span class="cov0" title="0">{
                // Check if it's actually a symlink
                isSymlink := utils.IsSymlink(targetPath)
                data.IsSymlink = types.BoolValue(isSymlink)
                tflog.Debug(ctx, "Symlink check", map[string]interface{}{
                        "is_symlink": isSymlink,
                })

                if isSymlink </span><span class="cov0" title="0">{
                        // Get symlink target
                        linkTarget, err := os.Readlink(targetPath)
                        if err != nil </span><span class="cov0" title="0">{
                                tflog.Warn(ctx, "Failed to read symlink target", map[string]interface{}{
                                        "error": err.Error(),
                                })
                                data.LinkTarget = types.StringNull()
                                // Return error for critical symlink read failures
                                return fmt.Errorf("failed to read symlink target: %w", err)
                        }</span> else<span class="cov0" title="0"> {
                                data.LinkTarget = types.StringValue(linkTarget)
                                tflog.Debug(ctx, "Symlink target read", map[string]interface{}{
                                        "target": linkTarget,
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.LinkTarget = types.StringNull()
                }</span>

                // Get modification time
                <span class="cov0" title="0">info, err := os.Lstat(targetPath) // Use Lstat to get symlink info, not target info
                if err != nil </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Failed to stat symlink, using current time", map[string]interface{}{
                                "error": err.Error(),
                        })
                        data.LastModified = types.StringValue(time.Now().Format(time.RFC3339))
                        // Don't return error for stat failures - they're not critical
                }</span> else<span class="cov0" title="0"> {
                        data.LastModified = types.StringValue(info.ModTime().Format(time.RFC3339))
                        tflog.Debug(ctx, "Modification time set", map[string]interface{}{
                                "mod_time": info.ModTime().Format(time.RFC3339),
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                data.IsSymlink = types.BoolValue(false)
                data.LinkTarget = types.StringNull()
                data.LastModified = types.StringNull()
                tflog.Debug(ctx, "Link does not exist, set default values")
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Computed attributes updated successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0.

package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var _ datasource.DataSource = &amp;SystemDataSource{}

func NewSystemDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;SystemDataSource{}
}</span>

type SystemDataSource struct {
        client *DotfilesClient
}

type SystemDataSourceModel struct {
        ID           types.String `tfsdk:"id"`
        Platform     types.String `tfsdk:"platform"`
        Architecture types.String `tfsdk:"architecture"`
        HomeDir      types.String `tfsdk:"home_dir"`
        ConfigDir    types.String `tfsdk:"config_dir"`
}

func (d *SystemDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_system"
}</span>

func (d *SystemDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "System information data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Data source identifier",
                        },
                        "platform": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Operating system platform",
                        },
                        "architecture": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "System architecture",
                        },
                        "home_dir": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "User home directory",
                        },
                        "config_dir": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "User config directory",
                        },
                },
        }
}</span>

func (d *SystemDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*DotfilesClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError("Unexpected Data Source Configure Type", "Expected *DotfilesClient")
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *SystemDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SystemDataSourceModel

        data.ID = types.StringValue("system")
        data.Platform = types.StringValue(d.client.Platform)
        data.Architecture = types.StringValue(d.client.Architecture)
        data.HomeDir = types.StringValue(d.client.HomeDir)
        data.ConfigDir = types.StringValue(d.client.ConfigDir)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
